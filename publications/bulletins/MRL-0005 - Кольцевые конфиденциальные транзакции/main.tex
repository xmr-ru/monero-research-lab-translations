\documentclass{mrl}
\usepackage[utf8x]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english, russian]{babel}
\usepackage{comment}

\theoremstyle{definition}
\newtheorem{thm}{Теорема}
\numberwithin{thm}{section}
\newtheorem{rem}[thm]{Примечание}
\newtheorem{lem}[thm]{Лемма}
\newtheorem{defn}[thm]{Определение}

\renewcommand\refname{Ссылки}
\renewcommand\proof{Доказательство.}

\title{Кольцевые конфиденциальные транзакции}
\authors{Шен Ноезер (Shen Noether)\footnote{\texttt{lab@getmonero.org}}, Адам Маккензи (Adam Mackenzie) и Monero Core Team}
\affiliations{Исследовательская лаборатория Monero (Monero Research Lab)}
\date{Февраль 2016}

\type{ИССЛЕДОВАТЕЛЬСКИЙ БЮЛЛЕТЕНЬ}
\ident{MRL-0005}

\begin{document}

\begin{center}
{\bfАннотация}
\end{center}

В данной статье предлагается метод сокрытия сумм транзакций децентрализованной анонимной криптовалюты Monero. Подобно Bitcoin, Monero является криптовалютой, распределяемой с использованием доказательства работы в процессе «майнинга». В основе оригинального протокола Monero лежит CryptoNote, протокол, предполагающий использование кольцевых подписей и одноразовых ключей с целью сокрытия адресата и источника транзакций. Недавно ведущим разработчиком Bitcoin Грегори Максвеллом (Gregory Maxwell) была рассмотрена и реализована технология сокрытия суммы транзакций при помощи схемы обязательства. В этой статье описан новый тип кольцевой подписи, многоуровневая связываемая подпись спонтанной анонимной группы (Multi-layered Linkable Spontaneous Anonymous Group signature), позволяющая скрывать суммы, источники и адресатов транзакций с разумной эффективностью, обеспечивая при этом верифицируемое и не требующее доверия создание монет. Предлагаются некоторые расширения протокола, такие как агрегированные доказательства диапазона Шнорра (Aggregate Schnorr Range Proofs) и кольцевые мультиподписи (Ring Multisignature). Автору хотелось бы отметить, что ранние версии этой работы публиковались на исследовательском IRC канале сообществ Monero и Bitcoin. Укороченная черновая версия блокчейна рассматривается в работе \cite{Snoe}, и это свидетельствует о том, что работа началась летом 2015 года, а завершена была в октябре 2015. Электронная версия также доступна по ссылке \url{http://eprint.iacr.org/2015/1098}.

\section{Введение}
\subsection{Применение специализированных (ad hoc) спонтанных кольцевых подписей в криптовалютах}

Вспомним, что каждая транзакция Bitcoin подписывается владельцем передаваемых монет, и такие подписи подтверждают, что владелец имеет право отправлять эти монеты. Это полностью аналогично подписанию банковского чека.

Работы по CryptoNote \cite{CN} и Ring Coin \cite{B2} развивают идею использования «кольцевых подписей», которая изначально была описана в работе \cite{RST} как «цифровая подпись, указывающая на группу вероятных подписантов таким образом, что верификатор не может точно сказать, кто из членов этой группы является создателем подписи». Следовательно, идея заключается в обладании оригинальным публичным ключом транзакции, который будет скрыт внутри группы публичных ключей, каждый из которых будет соответствовать одной и той же сумме монет, чтобы никто не мог точно сказать, который из пользователей отправил монеты.

Оригинальный протокол CryptoNote, описанный в работе \cite{CN}, включает в себя небольшое изменение этой схемы, направленное на предотвращение двойной траты. Это изменение, предлагаемое в работе \cite{CN}, представляет собой небольшую модификацию «отслеживаемой кольцевой подписи», описанной в работе \cite{FS}. Этот тип кольцевой подписи обеспечивает преимущество, которое заключается в том, что владелец монеты не сможет создать две различные кольцевые подписи, используя один и тот же публичный ключ так, чтобы этого нельзя было увидеть в блокчейне. Очевидной причиной этого изменения является предотвращение «двойной траты», которая в случае с Bitcoin означает, что одна и та же монета будет потрачена дважды. Ring Coin \cite{B2,B} использует более эффективную схему связываемой кольцевой подписи, которая является небольшой модификацией связываемой подписи спонтанной анонимной группы (Linkable Spontaneous Anonymous Group signature), описанной в работе \cite{LWW}.

Одним из преимуществ, указанных выше типов кольцевых подписей относительно других методов обеспечения анонимности, таких как CoinJoin \cite{GMc} или сервисы для смешивания монет (миксеры), является то, что они дают возможность «спонтанного» смешивания. В случае с CoinJoin или миксерами также можно скрыть источник отдельно взятой транзакции, но на практике эти методы требуют привлечения своего рода менеджера централизованной группы, например, использования централизованного сервера CoinJoin, чтобы такая доверенная сторона смогла комбинировать соответствующие транзакции. В случае, если доверенная сторона будет взломана, анонимность транзакции также будет подвергнута риску.

Некоторые монеты, такие как \cite{DASH} (которая изначально называлась Darkcoin), пытаются избежать этого, используя большое количество доверенных миксеров (в этом случае именуемых masternode), но всё же это количество по-прежнему не так велико, как количество пользователей монеты. При использовании спонтанной кольцевой подписи, транзакции, напротив, создаются владельцем соответствующего публичного ключа (это спонтанное или «специальное» свойство) без привлечения какого-либо доверенного сервера, что гораздо безопасней с точки зрения анонимности.

Одним из возможных вариантов атаки на оригинальный протокол CryptoNote или Ring Coin \cite{CN,B2} является анализ блокчейна, в основе которого лежат данные по сумме, отправляемой в определённой транзакции. Например, если злоумышленнику известно, что в определённое время было отправлено $.9$ монет, ему необходимо сузить список возможных отправителей, и для этого он ищет транзакции с $.9$ монет. Этого можно некоторым образом избежать при помощи одноразовых ключей \cite{CN}, так как у отправителя есть возможность включить ряд адресов сдачи в транзакцию, скрыв таким образом сумму, которая была отправлена с применением такого «рюкзачного смешивания». Тем не менее, этот метод имеет оборотную сторону: в блокчейне создаётся большое количество транзакций с «пылью», то есть, транзакций с небольшими суммами, которые занимают непропорционально много места относительно своей важности. Кроме того, получатель монет может «отмести» пыль, когда захочет отправить их, что, вероятно, позволит злоумышленнику отследить, какие ключи были некоторым образом связаны. Более того, довольно просто установить верхнюю и нижнюю границы отправляемых сумм.

Другой оборотной стороной оригинального решения протокола CryptoNote является то, что оно требует использования в кольцевой подписи пары $\left(P,A\right)$, состоящей из публичного ключа $P$ и суммы $A$, наряду с другими публичными ключами с той же суммой. В случае с необычными суммами это будет означать наличие меньшего количества потенциальных пар $\left(P^{\prime},A^{\prime}\right)$ в блокчейне при $A^{\prime}=A$ для соответствующей кольцевой подписи. Таким образом, в оригинальной версии протокола CryptoNote размер потенциальной анонимной группы будет меньше желаемого. Анализ вышеуказанного недостатка содержится в работе \cite{mrl4}.

\subsection{Применение Ring CT в Monero}

Очевидным способом избежать недостатков протокола CryptoNote, описанных в предыдущем подразделе, является сокрытие суммы любой транзакции. В этой работе мною описывается изменение протокола Monero, криптовалюты, использующей алгоритм доказательства работы, расширяющий оригинальную версию CryptoNote, которое позволит скрывать суммы в проводимых транзакциях. В основе этого изменения лежат конфиденциальные транзакции, описанные в работе \cite{GM} и используемые в сайдчейне Elements криптовалюты Bitcoin. Отличие состоит в возможности их применения с кольцевыми подписями. Поэтому, применительно к Monero изменение носит название «кольцевые конфиденциальные транзакции» (Ring Confidential Transactions).

В целях сохранения свойства, не позволяющего тратить монеты дважды, мною приводится обобщение LSAG из работы \cite{LWW}, многоуровневая связываемая подпись спонтанной анонимной группы (MLSAG), позволяющая объединить схему конфиденциальных транзакций с кольцевой подписью таким образом, что становится возможным использование множества входов и выходов, при этом сохраняется анонимность, а двойная трата остаётся невозможной. Автор хотел бы отметить, что примерно через месяц после публикации второго черновика этой работы подобный протокол был предложен Коннором Френкенехтом (Connor Frenkenecht).

\subsection{Строго децентрализованные схемы анонимных платежей}

Протокол Ring CT позволяет скрывать суммы, источник и адресатов транзакций, подобно тому, как это делается в случае Zerocash \cite{Z}. Разница состоит в том, что в отличие от ZeroCash протокол Ring CT при создании монет позволяет использовать доказательство работы. ZeroCash предполагает предварительное генерирование всех монет доверенной группой.

Следует отметить, что самой большой инновацией Bitcoin \cite{SN} стала модель децентрализованного распределения, позволяющая любому желающему использовать свою вычислительную мощь для создания криптовалюты. Некоторые преимущества этого типа доказательства работы включают в себя не требующий доверия стимул, обеспечивающий безопасность и более высокий уровень децентрализации сети (например, защиту от атак методом «отравленной таблетки»).

Последним очевидным преимуществом создания монет с использованием доказательства работы является защита Ring CT от сильного злоумышленника, способного каким-то образом завладеть всеми частями главного ключа, необходимого для создания монет. Поскольку существует очевидный значительный стимул (способность генерировать свободные деньги \footnote{Автор ранее допустил возможность «демаскировки» транзакций, но в более позднем документе ZeroCash утверждается, что это невозможно.}) собирать все части доверенного ключа генерации, это, безусловно, важно.

\subsection{Благодарность}

Мне хотелось бы поблагодарить команду Monero за помощь и обсуждение проблемы при создании этой работы, а также сообщества Monero и Bitcoin за поддержку и рассмотрение вопроса. Автором также было получено несколько пожертвований от сообщества Monero на общую сумму от 2 до 3 Bitcoin в благодарность за его работу над этим исследованием.

\section{Многоуровневые связываемые подписи спонтанной анонимной группы}\label{MLSAGsection}

В этом разделе мною даётся определение многоуровневой связываемой подписи спонтанной анонимной группы (MLSAG), используемой протоколом Ring CT. Следует отметить, что я определяю эту подпись как общую, а не только относительно её применения в кольцевых конфиденциальных транзакциях. Подпись MLSAG во многом схожа с подписью LSAG, описанной в работе \cite{LWW}, но скорее является не подписью по набору, включающему в себя $n$ ключей, а а подписью по набору, состоящему из $n$ векторов ключей.

\begin{defn}
\label{defn:A-key-vector-is} \textbf{Вектор ключа} представляет собой простой набор из $\overline{y}=\left(y_{1},...,y_{r}\right)$ публичных ключей с соответствующими приватными ключами $\overline{x}=\left(x_{1},...,x_{r}\right)$.
\end{defn}

\subsection{\label{sub:BackLSAG}Сравнение LWW и FS подписей}

Кольцевые подписи, используемые Monero и оригинальным протоколом CryptoNote, получены на основе отслеживаемых кольцевых подписей, предложенных в работе \cite{FS}. Кольцевые подписи CryptoNote \cite{CN} предполагают наличие «образа ключа», а это означает, что подписант сможет оставить в блокчейне только одну подпись с одной отдельно взятой парой, состоящей из публичного и приватного ключа, в противном случае его транзакция будет помечена как недействительная. Поэтому, CryptoNote использует одноразовые ключи, что также способствует анонимности.

В работе \cite{B} Адам Бэк (Adam Back) отметил, что связываемые подписи спонтанной анонимной группы (LSAG), описанные в работе \cite{LWW}, могут быть изменены так, чтобы получилась более эффективная связываемая кольцевая подпись, которая бы работала так же, как кольцевые подписи, предложенные в работе \cite{FS}. Такое изменение позволило бы сократить место, необходимое для хранения в блокчейне вдвое.

Сначала я почти дословно приведу изменение, предложенное в работе \cite{B}:

\textbf{Keygen}: Найти ряд публичных ключей $P_{i},i=0,1,...,n$ и такой секретный индекс $j$ чтобы $xG=P_{j}$ где $G$ является базовой точкой ed25519, а $x$ является ключом траты подписанта. Допустим, $I=xH_p\left(P_{j}\right)$ где $H_p$ является хеш-функцией, возвращающей точку \footnote{На практике $H_p(P) = Keccak(P)\cdot G$ где $G$ является базовой точкой ed25519, вместе с тем означает, что в схеме обязательства мною используется $toPoint(Keccak(P))$, производящая последовательное хеширование до тех пор, пока $Keccak(P)$ не возвратит кратное значение базовой точки.}

Допустим, $\mathfrak{m}$ является определённым сообщением.

\textbf{SIGN}: Допустим, $\alpha,s_{i},\ i\neq j,\ i\in\left\{ 1,...,n\right\}$ являются случайными значениями в $\mathbb{Z}_{q}$ (базовом поле ed25519).

Вычисляем
\[
L_{j}=\alpha G
\]
\[
R_{j}=\alpha H_p\left(P_{j}\right)
\]
\[
c_{j+1}=h\left(\mathfrak{m},L_{j},R_{j}\right)
\]
где $h$ является хеш-функцией, возвращающей значение в $\mathbb{Z}_{q}$.
Теперь, действуя последовательно в $j$ по модулю $n$ определяем
\[
L_{j+1}=s_{j+1}G+c_{j+1}P_{j+1}
\]
\[
R_{j+1}=s_{j+1}H_p\left(P_{j+1}\right)+c_{j+1}\cdot I
\]
\[
c_{j+2}=h\left(\mathfrak{m},\ L_{j+1},\ R_{j+1}\right)
\]
\[
\cdots
\]
\[
L_{j-1}=s_{j-1}G+c_{j-1}P_{j-1}
\]
\[
R_{j-1}=s_{j-1}H_p\left(P_{j-1}\right)+c_{j-1}\cdot I
\]
\[
c_{j}=h\left(\mathfrak{m},L_{j-1},\ R_{j-1}\right)
\]
таким образом, что определяются $c_{1},...,c_{n}$.

Допустим, $s_{j}=\alpha-c_{j}\cdot x_j\ mod\ l$, (где $l$ имеет значение порядка кривой ed25519), следовательно $\alpha=s_{j}+c_{j}x_j\ mod\ l$ так, что
\[
L_{j}=\alpha G=s_{j}G+c_{j}x_jG=s_{j}G+c_{j}P_{j}
\]
\[
R_{j}=\alpha
H_p\left(P_{j}\right)=s_{j}H_p\left(P_{j}\right)+c_{j}I
\]
и
\[
c_{j+1}=h\left(\mathfrak{m},\ L_{j},\ R_{j}\right)
\]
и таким образом, при одном известном значении $c_{i}$ и значениях $P_{j}$, образ ключа $I$ и все значения $s_{j}$, все остальные $c_{k},\ k\neq i$, могут быть восстановлены наблюдателем. Следовательно, подпись приобретает следующую форму:
\[
\sigma=\left(I,c_{1},s_{1},...,s_{n}\right)
\]
что даёт большую экономию места, чем в \cite[4.4]{CN}, где кольцевая подпись выглядела бы так:
 \[
\sigma=\left(I,c_{1}, ..., c_{n},s_{1},...,s_{n}\right)
\]
\textbf{Верификация} выполняется следующим образом. Наблюдатель вычисляет $L_{i},R_{i},$ и $c_{i}$ для всех $i$ и проверяет равенство $c_{n+1}=c_{1}$. Затем верификатор проверяет, чтобы
\[
c_{i+1}=h\left(\mathfrak{m},L_{i},R_{i}\right)
\]
для всех $i$ по модулю $n$

\textbf{LINK}: Подписи с дублирующими друг друга образами ключей $I$ отклоняются.

Следует отметить, что доказательства невозможности подделки, анонимности и связываемости, используемые вышеуказанным протоколом, являются лишь незначительными модификациями доказательств, описанных в работе \cite{LWW}. Мною будет приведена более обобщённая версия этих доказательств для MLSAG.

\subsection{\label{sub:MLSAG-Description}Описание MLSAG}

В случае с протоколом Ring CT, о котором пойдёт речь в Разделе \ref{sec:Ring-CT-ForMonero}, мне потребовалась генерализация обратных LSAG-подписей, описанная в предыдущем разделе и позволяющая использовать векторы ключей (Определение \ref{defn:A-key-vector-is}), а не просто ключи.

Предположим, что каждый подписант (обобщённого) кольца, включающего в себя $n$ участников, имеет точное количество $m$ ключей $\left\{ P_{i}^{j}\right\} _{j=1,...,m}^{i=1,...,n}$.
Задача кольцевой MLSAG-подписи состоит в следующем:
\begin{itemize}
\item доказать, что одному из n подписантов известны секретные ключи ко всему вектору ключей;
\item гарантировать, что в случае использования подписантом одного из m подписывающих ключей в другой MLSAG-подписи, два кольца будут связаны, и вторая такая MLSAG-подпись (прописанная в блокчейне) будет забракована.
\end{itemize}

Алгоритм выполняется следующим образом: допустим, $\mathfrak{m}$ является определённым сообщением. Допустим, $\pi$ является секретным индексом, соответствующим подписанту созданного кольца. Для $j=1,...,m$, допустим, что $I_{j}=x_{j}H\left(P_{\pi}^{j}\right)$, а для $j=1,...,m$, $i=1,...,\hat{\pi},...n$ (где $\hat{\pi}$ означает опущение $\pi$) допустим, что $s_{i}^{j}$ является некоторыми случайными скалярными величинами (элементами $\mathbb{Z}_q$). Теперь, аналогично тому, как это делалось в подразделе \ref{sub:BackLSAG}, определяем
\[
L_{\pi}^{j}=\alpha_{j}G
\]
\[
R_{\pi}^{j}=\alpha_{j}H\left(P_{\pi}^{j}\right)
\]
для случайных скалярных величин $\alpha_j$ и $j=1,...,m$. Теперь, также аналогично тому, как это делалось в подразделе \ref{sub:BackLSAG}, задаём:
\[
c_{\pi+1}=H\left(\mathfrak{m},L_{\pi}^{1},R_{\pi}^{1},...,L_{\pi}^{m},R_{\pi}^{m}\right).
\]
\[
L_{\pi+1}^{j}=s_{\pi+1}^{j}G+c_{\pi+1}P_{\pi+1}^{j}
\]
\[
R_{\pi+1}^{j}=s_{\pi+1}^{j}H\left(P_{\pi+1}^{j}\right)+c_{\pi+1}I_{j}
\]
и повторяем это, увеличивая $i$ по модулю $n$, пока не получим
\[
L_{\pi-1}^{j}=s_{i-1}^{j}G+c_{i-1}P_{i-1}^{j}
\]
\[
R_{\pi-1}^{j}=s_{i-1}^{j}H\left(P_{i-1}^{j}\right)+c_{i-1}\cdot I_{j}
\]
\[
c_{\pi}=H\left(\mathfrak{m},L_{\pi-1}^{1},R_{\pi-1}^{1},...,L_{\pi-1}^{m},R_{\pi-1}^{m}\right).
\]
Наконец, находим решение для каждого $s_{\pi}^{j}$, используя $\alpha_{j}=s_{\pi}^{j}+c_{\pi}x_{j} \mod \ell$.
Получаем следующую подпись: $\left(I_{1},...,I_{m},c_{1},s_{1}^{1},...,s_{1}^{m},s_{2}^{1},...,s_{2}^{m},...,s_{n}^{1},...,s_{n}^{m}\right)$. Таким образом, сложность будет следующей: $O\left(m\left(n+1\right)\right).$
Верификация продолжается путём повторного генерирования $L_{i}^{j},R_{i}^{j}$, начиная с $i=1$ как это делалось в подразделе \ref{sub:BackLSAG} (что является особым случаем при $m=1$) и верифицируя хеш $c_{n+1}=c_{1}.$ сли они использовались в блокчейне подобном Monero, подписи с образами ключей $I_j$, которые уже появлялись в нём, будут отклоняться. Это легко демонстрируется подобно тому, как это сделано в работе \cite{LWW}:
\begin{itemize}
\item вероятность того, что подписант сгенерирует действительную подпись, не зная всё количество ``$m$'' приватных ключей, принадлежащее вектору ключей для индекса $\pi$ ничтожна;
\item вероятность того, что подписант не подпишется по какому-либо ключу с индексом $\pi$ ничтожна (другими словами, образы ключей в подписи, все будут основаны на индексе $\pi$);
\item если подписант подписывает два кольца, используя, по крайней мере, один из одинаковых публичных ключей, то два кольца связаны.
\end{itemize}
Я расширяю эти определения ниже, приводя доказательства безопасности.

\subsection{Модель безопасности MLSAG}

MLSAG соответствуют следующим трём свойствам: невозможности поделки, связываемости и неопределённости подписанта, что очень схоже с определениями, приводимыми в работе \cite{LWW}.
\begin{defn}
\label{defn:(Unforgeability)--An}(невозможность подделки) %
{} Схему MLSAG-подписи невозможно подделать, даже в случае с вероятностным алгоритмом полиномиальной временной сложности (PPT) $\mathcal{A}$ с подписывающим оракулом $\mathcal{SO}$, выдающим действительные подписи, при наличии определённого списка $n$ векторов публичных ключей, выбираемых $\mathcal{A}$, такой алгоритм $\mathcal{A}$ лишь с ничтожной вероятностью сможет создать действительную подпись, если $\mathcal{A}$ не будет известен один из соответствующих векторов приватных ключей.
\end{defn}
\begin{rem}
Следует отметить, что в следующее определение мною было включено отрицание возможности использования дублирующих друг друга образов ключей в качестве части критерия верификации MLSAG, что несколько отличает моё определение связываемости от того, что приводится в работе \cite{LWW}.
\end{rem}
\begin{defn}
\label{defn:(Linkability)}(связываемость) Допустим, $L$ является набором публичных ключей в текущей структуре (например, в блокчейне). Схема MLSAG-подписи с $L$ будет связной по образам ключей, если вероятность того, что злоумышленник, использующий PPT-алгоритм $\mathcal{A}$, сможет создать две подписи $\sigma,\sigma^{\prime}$ подписанные соответствующими векторами ключей $\overline{y}$ и $\overline{y}^{\prime}$, каждый из которых будет содержать один и тот же публичный ключ $y_{i}=y$$_{i}^{\prime}$ в $L$, и каждый будет верифицирован и не помечен как дублирующий, будет ничтожной.
\end{defn}
\begin{defn}
\label{defn:(Signer-Ambiguity-)}(неопределённость подписанта) Считается, что схема MLSAG-подписи обеспечивает неопределённость подписанта, если в случае с любой верифицируемой подписью $\sigma$ по векторам ключей $\left(\overline{y}_{1},...,\overline{y}_{n}\right)$ и любому набору из $t$ приватных ключей, ни один из них не имеет ни одного одинакового индекса, и ни одного одинакового секретного индекса, и тогда вероятность угадывания секретного ключа составляет менее $\frac{1}{n-t}+\frac{1}{Q\left(k\right)}$.
\end{defn}
Доказательства приведённых выше определений MLSAG-подписей содержатся в приложении.

\section{\label{sec:Background-on-ConfidentialT}История конфиденциальных транзакций}

\subsection{Конфиденциальные транзакции в Bitcoin}

В своей работе \cite{GM} Грег Максвелл (Greg Maxwell) говорит о конфиденциальных транзакциях, как о способе проведения транзакций Bitcoin с сокрытием суммы. Основная идея состоит в использовании обязательства Педерсена в качестве, и сам метод хорошо описан в указанном источнике. В этой работе я немного изменяю рабочий механизм конфиденциальных транзакций и вместо того, чтобы использовать обязательства по сумме с нулевым разглашением, я подписываю обязательство, чтобы доказать, что мне известен приватный ключ. Более подробное описание приводится в следующем разделе.

\subsection{Модификация для кольцевых подписей}

Допустим, $G$ является базовой точкой ed25519. Допустим \footnote{$H=MiniNero.getHForCT()$ с точки зрения кода рассматривается в работе \cite{Snoe}}
\[
H=toPoint\left(cn\_fast\_hash\left(G\right)\right)
\]
Следует отметить, что не каждый хеш даёт точку в группе базовой точки (то есть, $H=\psi G$ для некоторой неизвестной $\psi$) (в этом состоит отличие от того, что происходит в случае с secp256k1, кривой, используемой Bitcoin). Тем не менее, кажется, выбор самой базовой точки сам по себе работает (ранее я использовал H(123456G), что касалось мне более безопасным, но использовать базовую точку более естественно).
Выбор $H = \gamma G$ для некоторой неизвестной $\gamma$ олжен обязательно быть таким, чтобы сохранялась вся обычная математика эллиптической кривой.
Учитывая допуск дискретного логарифмирования ed25519, вероятность того, что злоумышленник найдёт $\gamma$, ничтожна. Находим $C\left(a,x\right)=xG+aH$, обязательство по значению $a$ с маской $x$. Следует отметить, что поскольку $log_{G}H$ неизвестен, и если $a\neq0$, то и $log_{G}C\left(a,x\right)$ будет неизвестен. С другой стороны, если $a=0$, то $log_{G}C\left(a,x\right)=x$, и можно будет создать подпись, используя sk-pk пару ключей $\left(x,C\left(0,x\right)\right).$

В работе \cite{GM} используются обязательства по входу, обязательства по выходу, и сеть проверяет, чтобы
\[
\sum Inputs=\sum Outputs.
\]
Тем не менее, этого недостаточно в случае с Monero: так как определённая транзакция содержит множество возможных входов $P_{i},i=1,...,n$, только один из которых принадлежит отправителю (см. \cite[4.4]{CN}), если мы сможем проверить приведённое выше равенство, сеть также сможет увидеть, какой $P_{i}$ принадлежит отправителю транзакции. Это нежелательно, так как нейтрализуется анонимность, обеспечиваемая кольцевыми подписями. Поэтому, вместо этого используются обязательства по входам и выходам, которые создаются следующим образом (сначала предположим, что имеется только один вход):
\[
C_{in}=x_{c}G+aH
\]
\[
C_{out-1}=y_{1}G+b_{1}H
\]
\[
C_{out-2}=y_{2}G+b_{2}H
\]
так, чтобы $x_{c}=y_{1}+y_{2}+z$, $x_{c}-y_{1}-y_{2}=z$, $y_{i}$ являлись значениями маски, $z>0$ и $a=b_{1}+b_{2}.$ В данном случае $x_{c}$ является специальным приватным ключом, «ключом суммы», известным только отправителю, а также лицу, которому отправляются монеты, и он должен отличаться от обычного приватного ключа. В этом случае
\[
C_{in}-\sum_{i=1}^{2}C_{out-i}
\]
\[
=x_{c}G+aH-y_{1}G-b_{1}H-y_{2}G-b_{2}H
\]
\[
=zG.
\]
Таким образом, приведённое выше суммирование становится обязательством по $0$, где $sk=z$, а $pk=zG$, а не фактическим уравнением с суммой, равной нулю. Следует отметить, что $z$ не может быть вычислено источником монет $x_{c}$, если только ему не будут известны $y_{1},y_{2}$, но даже этого можно избежать, просто включив дополнительный адрес для сдачи (обычно второе обязательство, использующее $y_2$ в качестве маски, отправляется себе как сдача).

Так как нежелательно демонстрировать принадлежность конкретного входа отправителю, создаётся кольцевая подпись, состоящая из всех обязательств по входам $C_{i},i=1,...,s,...,n$ (где $s$ является секретным индексом обязательства отправителя), с добавлением соответствующего публичного ключа (чтобы обязательства и публичные ключи были объединены в пары $\left(C_{i},P_{i}\right)$ и их можно было бы отправить только вместе), а также вычитания $\sum C_{out}$:
\[
\left\{ P_{1}+C_{1,in}-\sum_{j}C_{j,out},...,P_{s}+C_{s,in}-\sum_{j}C_{j,out},...,P_{n}+C_{n,in}-\sum_{j}C_{j,out}\right\} .
\]
Эта кольцевая подпись может быть подписана, так как нам известен один из приватных ключей (а именно $z+x^{\prime}$ с $z$, %
\begin{comment}
note you can't use $x_{s}=s$, or else once the output amount is unvelied,
the ring sig is caput - check this, since there are masks...
\end{comment}
как указано выше, и $x^{\prime}G=P_{s}$). По сути, поскольку нам для каждого $i$ известен как приватный ключ для $P_{i}$, так и приватный ключ для $P_{i}+C_{i,in}-\sum_{j}C_{j,out}$, мы можем создать подпись так же, как это было сделано в подразделе \ref{sub:MLSAG-Description}. Подробности содержатся в Определении \ref{RCTProtocol}.

Как было отмечено в работе \cite{GM}, важно доказать, что все суммы выходов\footnote{Так как обязательства по входам потенциально могут быть просто унаследованы из предшествующей транзакции, этого достаточно, чтобы учитывать суммы выходов.} $b_{1},...b_{n}$ находятся в диапазоне положительных значений, например, $(0,2^{16}).$
Это делается в значительной степени так же, как описано в работе \cite{GM} и более подробно в Разделе \ref{AgSchnorr}.
\begin{comment}
\begin{itemize}
\item Write each output amount $b_i$ as
\[
 b_i = \delta_{ij}
\]

\item Prove first $C_{out-i}^{\left(j\right)}\in\left\{ 0,2^{j}\right\} $
for all $j\in\left\{ 0,1,...,16\right\} .$ This is done as in \cite{GM}:
for example, $C_{out-i}^{0}=y_{i}^{0}G+b_{i}^{0}H$ where $b_{i}^{0}\in\left\{ 0,1\right\} $.
Let
\[
C_{out-i}^{\prime0}=C_{out-i}^{0}-H=y_{i}G+b_{i}^{0}H-H
\]
 so that if $b_{i}^{0}=0$, then $C_{out}^{\prime0}=y_{i}G$ and if
$b_{i}^{0}=1$, then $C_{out}^{0}=y_{i}G$, and in either case, the
ring signature on $\left\{ C_{out}^{0},C_{out}^{\prime0}\right\} $
can be signed for.
\item By carefully choosing the blinding values (i.e. ensuring that $\sum_{j}y_{i}^{j}=y_{i}$ for each $j$), define
\[
C_{out-i}=\sum_{j=1}^{16}C_{out-i}^{\left(j\right)}
\]
\item By homomorphicity of the commitments, $b_{i}=\sum_{j}\delta_{ji}2^{j}$,
where $\delta_{ji}$ is the $j^{th}$ digit in the binary expansion
of $b_{i}$.
\end{itemize}
Thus in total, by the above, the sum of inputs into a transaction
equals the outputs, yet the specific input (and it's index!) is hidden.
In addition, the outputs are positive values.
\end{comment}

Наконец, следует отметить, что выше мною никак не упоминалось свойство связываемости по тегам, которое используется Monero и CryptoNote во избежание двойной траты. Свойство связываемости по тегам в нашем случае приводит к объединению тому, что обсуждалось выше, с MLSAG-подписями, как они описаны в Определении \ref{RCTProtocol}.

\section{\label{sec:Ring-CT-ForMonero}Ring CT и протокол Monero}

\subsection{Описание протокола}
\begin{defn}
\label{RCTProtocol}(Связываемые по тегам Ring-CT со множеством входов и одноразовыми ключами)
\end{defn}
\begin{itemize}
\item Допустим, $\left\{ \left(P_{\pi}^{1},C_{\pi}^{1}\right),...,\left(P_{\pi}^{m},C_{\pi}^{m}\right)\right\} $
является набором адресов/обязательств с соответствующими секретными ключами $x_{j},\ j=1,...,m$.
\item Находим $q+1$ наборов $\left\{ \left(P_{i}^{1},C_{i}^{1}\right),...,\left(P_{i}^{m},C_{i}^{m}\right)\right\} ,i=1,...,q+1$, которые уже не связываемы по тегам так, как это описано в работе \cite[стр. 6]{FS}.
\item Выбираем набор адресов выходов $\left(Q_{i},C_{i,out}\right)$ так, чтобы $\sum_{j=1}^{m}C_{\pi}^{j}-\sum_{i}C_{i,out}$ была обязательством по нулю.
\item Допустим
\[
\mathfrak{R}:=\left\{ \left\{ \left(P_{1}^{1},C_{1}^{1}\right),...,\left(P_{1}^{m},C_{1}^{m}\right),\left(\sum_{j}P_{1}^{j}+\sum_{j=1}^{m}C_{1}^{j}-\sum_{i}C_{i,out}\right)\right\} ,\right.
\]
\[
...,
\]
\[
\left.\left\{ \left(P_{q+1}^{1},C_{q+1}^{1}\right),...,\left(P_{q+1}^{m},C_{q+1}^{m}\right),\left(\sum_{j}P_{q+1}^{j}+\sum_{j=1}^{m}C_{q+1}^{j}-\sum_{i}C_{i,out}\right)\right\} \right\} .
\]
является обобщённым кольцом, которое мы хотим подписать. Следует отметить, что последний столбец является кольцом Ring-CT, как это описано в Разделе \ref{sec:Ring-CT-ForMonero}.
\item Вычисляем MLSAG-подпись $\Sigma$ по $\mathfrak{R}.$
\end{itemize}
В этом случае, согласно Теореме \ref{thm:Unforgeability}, $P_{\pi}^{j},j=1,...,m$ не может являться подписантом какой-либо дополнительной несвязанной кольцевой подписи в данном поднаборе $\mathcal{P}$ всех таких пар $\mathcal{P}=\left\{ \left(P,C\right)\right\} $ после подписания $\Sigma$.
\begin{rem}
Пространственная сложность указанного выше протокола. Необходимо отметить, что размер подписи $\Sigma$ по $\mathfrak{R}$ в соответствии с Определением \ref{RCTProtocol} при $m>1$ 1 фактически меньше, чем в случае с используемой в настоящее время кольцевой подписью CryptoNote \cite{CN}, основанной на транзакции, включающей в себя множество входов. Причина состоит в улучшении размера, предлагаемого в работе \cite{LWW} для каждого столбца. Также следует отметить вероятное отсутствие необходимости во включении образа ключа вводимых данных обязательства в случае с вышеуказанной подписью. Кроме того, вполне возможна дальнейшая оптимизация размера.\end{rem}

\subsection{Преобразование видимого номинала в обязательства}
\label{conversion}

Поскольку в настоящее время Monero использует в блокчейне видимые скалярные величины, важная задача состоит в преобразовании видимых сумм в обязательства с сохранением анонимности. По сути, это сделать несложно. При наличии пары $(P, a)$, где $P$ является публичным ключом, а $a$ обозначает сумму, её можно использовать в качестве входа транзакции в виде $(P, aH)$, а верификатор должен проверить, чтобы сумма входа $a$, умноженная на точку маскировки $H$, на самом деле составляла $aH$. Таким образом, на первом этапе суммы входов не будут скрыты, но выходы транзакций скрыть можно, и все необходимые отношения, о которых говорится в Разделе \ref{sec:Ring-CT-ForMonero}, сохраняются. Необходимо отметить, что необходимость в доказательстве диапазона в случае с таким входом отсутствует.
\begin{rem}
Очевидным преимуществом данного метода преобразования видимых сумм в обязательства является то, что сумма монет, созданных в процессе майнинга, может быть верифицирована на доверительной основе. Это преимущество протокола Ring CT относительно платёжных схем, подобных описанной в работе \cite{Z}, в основе которых лежит этап доверительной настройки.
\end{rem}
\subsection{Комиссии за проведение транзакций}
Поскольку Monero является строго децентрализованной криптовалютой (то есть, использует алгоритм доказательства работы), майнеры должны получать комиссию с каждой транзакции. Это способствует безопасности сети, предотвращая раздувание блокчейна. Эти комиссии должны выплачиваться «в открытую», то есть, просто как $bH$, а не как $xG+bH$, и с какой-то стандартной суммы $b$, чтобы майнер мог проверить, что $b\cdot H = bH$, а следовательно, имеется достаточное количество денег для уплаты такой комиссии, но с сохранением уравнений, касающихся $H$, чтобы необходимые отношения, описанные в Разделе \ref{sec:Ring-CT-ForMonero}, также сохранялись.
\subsection{Кольцевая мультиподпись}
Необходимо отметить, что реализация простой версии кольцевой мультиподписи $t$ из $m$ из $n$ также возможна и в случае с MLSAG-подписями. Это позволяет группе, состоящей из $m$ участников, создавать мультиподпись, которую должно будет подписать $t$ из $m$ участников, чтобы она была принята как действительная, и кроме того, подписант остаётся неопределённым, в силу сокрытия того, какое количество $m$ из $n$ ключей принадлежит участникам.
\begin{itemize}
 \item $n$ участников мультиподписи создаёт общий секрет $x_e$ и публичный ключ $P_e$ и совместно использует образы ключей мультиподписи
 \[
I_j = x_e H(P_e | P_j)
 \]
где $P_j$ является публичным ключом участника.
 \item Любой участник мультиподписи выбирает $n-m$ ополнительных публичных ключей в блокчейне и создаёт MLSAG-подпись с первым рядом, состоящим из $n$ ключей, и вторым рядом, в котором каждый элемент содержит общий ключ $P_e$.
 \item Каждый подписант, передающий часть мультиподписи, обеспечивает начальное $I_j,\ j=1,...,m$ и подпись принимается после того, как $t$ верифицированных подписей будет передано в блокчейн, и каждая из них будет соответствовать образам ключей $I_j$.
\end{itemize}

\section{Агрегированные доказательства диапазона Шнорра}
\label{AgSchnorr}
В работе \cite{GM} конфиденциальные транзакции без кольцевых подписей всё же используют определённый тип кольцевой подписи, основанный на том, что было описано в работе \cite{abe}, под названием кольцевой подписи Борромео. Этот тип подписи помогает доказать, что значение суммы, по которой даётся обязательство, находится в пределах определённого диапазона. В этой статье мною предлагается альтернативный метод, вдохновением для которого послужила работа \cite{herranz}, позволяющий в той же мере сэкономить место, но, возможно, имеет более простые доказательства безопасности. В данном случае имелась следующая мотивация: предположим, что в определённой транзакции имеются обязательства по входам
\[
 C_{in} = a_{in} G + 10 H
\]
и обязательства по выходам
\[
 C_{out,1} = a_{out,1} G + 5 H,\ C_{out,2} = a_{out,2} G + 5 H
\]
и этот сценарий является действительным, так как есть возможность подписания по
\[
 C_{in} - C_{out,1} - C_{out,2} = \left(a_{in} - a_{out,1} - a_{out,2} \right) G
\]
Тем не менее, следует отметить, что (при отсутствии доказательств диапазона) существует возможность альтернативного определения обязательств по выходам
\[
C_{out,1} = a_{out,1} G - H,\ C_{out,2} = a_{out,2} G + 11 H
\]
так как $-1$ является довольно большим модулем числа порядка группы кривой, создаются свободные деньги. Следовательно, необходимо доказать, что $C_{out,i}$ являются обязательствами по положительным значениям, лежащим в пределах ограниченного диапазона $[0,2^n]$ для некоторого $n$. Для этого необходимо разбить каждое значение выхода на двоичные значения:
\[
 b = b_0 2^0 + b_1 2^1 + b_2 2^2 + \cdots + b_n 2^n
\]
и вычислить обязательства $C_{out,i}^j$ для $b_j \cdot 2^j $ и так, чтобы
\[
 C_{out,i}^1 + C_{out,i}^2 + \cdots + C_{out,i}^n = C_{out,i}
\]
Наконец, используя секретный ключ $b_j$ можно вычислить кольцевую подпись по
\[
 (C_{out,i}^j, C_{out,i}^j - 2^j H)
\]
для всех $j$ и предоставить $C_{out,i}^j$ верифицирующим сторонам (в данном случае майнерам).

В целях экономия места мы можем либо использовать кольцевую подпись Борромео (как предлагается в работе \cite{GM}), чтобы объединить все эти простые кольцевые подписи, либо некую агрегированную кольцевую подпись, определяемую следующим образом:
\subsubsection{Создание агрегированной несвязываемой кольцевой подписи Шнорра (ASNL)}
Допустим, $(x_i^j, P_1^j, P_2^j)$ является набором ключей, $j=1,...,n$, где $x_i^j$ является секретным ключом $P_i^j$
\begin{itemize}
 \item Для каждого $j$ допустим, что $i^\prime := i+1\ mod\ 2$, присваиваем $\alpha_j$ случайную скалярную величину и вычисляем $L_i^j = \alpha_j G$.
 \item Задаём $c_{i^\prime}^j= H_s(L_i^j)$, где $H_s$ является криптографической хеш-функцией, возвращающей скалярную величину, и, случайным образом выбрав $s_{i^\prime}^j$, вычисляем
 \[
L_{i^\prime}^j = s_{i^\prime} G + c_{i^\prime} H.
 \]
 \item Задаём $c_i = H_s(L_{i^\prime}^j)$ и вычисляем
 \[
s_i^j = \alpha - c_i^j x_i \ mod\ \ell
 \]
 \item Получаем $(L_1^j, s_2^j)$ для всех $j$ и $s = \sum_j s_1^j$.
\end{itemize}

\subsubsection{Верификация агрегированной несвязываемой кольцевой подписи Шнорра (ASNL)}
Берём $(P_1^j, P_2^j, L_1^j, s_2^j)$ для $j=1,...,n$ и $s$.
\begin{itemize}
 \item Для всех $j$ вычисляем $c_2^j = H_s (L_1^j)$, $L_2^j = s_2^j G + c_2^j H$ и $c_1^j = H_s(L_2^j)$.
 \item Если $\sum_{j=1}^n L_1^j = s G + (c_1^j + \cdots + c_n^j) H$, в случае действительной подписи получаем $0$. В противном случае получаем $-1$.
\end{itemize}
 \begin{thm}
Агрегированную несвязываемую кольцевую подпись Шнорра нельзя поделать согласно допуску дискретного логарифмирования.
 \end{thm}
\begin{proof}
Мною приводится доказательство для случая, в котором $n=2$. Общий случай будет подобным. Предположим, злоумышленник $\mathcal{A}$ может подделать ASNL-подпись по
\[
\left\{ (x_i^1, P_1^1, P_2^1), (x_i^2, P_1^2, P_2^2) \right\}
 \]
с незначительной вероятностью, если ему известен, по крайней мере, один из $x_i^j$ (не в ущерб общности предположим, что $\mathcal{A}$ известен $x_i^1$). Для любой такой подделки:
 \[
\{s,(P_1^j, P_2^j, L_1^j, s_2^j)\},\ j=1,2,
 \]
я с незначительной вероятностью решаю дискретный логарифм $P_1^2$. В соответствии с алгоритмом верификации, допустим, $c_1^j = H_s\left(s_2^j G + H_s(L_1^j)H\right)$. В таком случае, действительным будет
\[
 L_1^1 + L_1^2 = sG + \left(c_1^1 P_1^1 + c_1^2 P_1^2\right).
\]
Предположим, что $L_1^1 = a G$ and $L_1^2 = bG$, где $a$ и $b$ известны $\mathcal{A}$, тогда
\[
 aG + bG - sG - c_1^1 P_1^1 = c_1^2 P_1^2
\]
Таким образом, поскольку $c_1^2$ определяется протоколом верификации, это тот случай, когда $\mathcal{A}$ известен приватный ключ $P_1^2$,
\[
 x_1^2 := \frac{a+b-s-c_1^1 x_1^1}{c_1^2} \mod \ell
\]
Это противоречит допуску дискретного логарифмирования для данной группы.
\end{proof}
\subsection{Представление суммы}
При использовании протокола Ring CT представление суммы происходит подобно тому, как это описано в работе \cite{GM}, но с небольшим изменением, необходимым в случае с Monero. Монеты CryptoNote организуют монеты с определённым номиналом в базы данных индексов, чтобы их можно было использовать в порядке их появления в качестве входов в кольцевых подписях. Поскольку все значения представлены в виде 64-битных целых чисел без знака, мы можем использовать доказательство диапазона по всему реестру для шифровки суммы в выходе, передаваемом получателю. Благоприятно то, что это также позволяет смешивать все выходы друг с другом. Таким образом, для представления выходов требуется только один индекс. Размер доказательства диапазона в этом случае составляет приблизительно 5 килобайт. Кольцевые подписи со входами при этом становятся более устойчивыми к анализу, так как анонимная группа значительно расширяется.

Несмотря на большой размер доказательств диапазона, применение схемы хеширования транзакций, используемой для подписи «префикса» транзакции (индексов входов и выходов) и сохранения доказательства диапазона, наряду с кольцевыми подписями также позволяет сэкономить довольно много места при синхронизации или при выполнении роли SPV-узла. Подобно тому, как это делается в случае с элементами сайдчейна \cite{El}, мы сохраняем $H(H(prefix) || H(signatures))$ в дереве Меркла. Затем, узлам, синхронизирующимся и доверяющим контрольной точке, необходимо только загрузить префикс и хеш подписей, что значительно сокращает объём пропускной способности, необходимой для синхронизации. Так как префикс транзакции использует варинт для выходов, на которые он ссылается в кольцевых подписях и выводит средства по отдельным публичным ключам, они предельно малы, если сравнивать с данными кольцевых подписей во входах и доказательствах диапазона. В дальнейшем некоторые узлы смогут даже вырезать кольцевые подписи из баз данных в целях экономии места, а вместо них хранить сравнительно небольшой набор непотраченных выходов транзакций (UTXO).
\subsubsection{Передача суммы получателю}
Теперь, когда есть сумма в выходе, $b = b_0 2^0 + b_1 2^1 + \cdots b_n 2^n $, отправитель вычисляет новую пару приватных/публичных ключей и соответствующий общий ECDH секрет $ss$ и создаёт следующую информацию, которая будет содержаться в его транзакции:
\begin{itemize}
 \item $C_j = a_j G + (b_j 2^j) H$, где $a_i$ является некоторыми случайными числами для $j=0,...,n$.
 \item Данные $\left\{(L_1^i, s_2^j),s\right\}$.
 \item Публичный ключ ECDH и $a + ss\ mod\ \ell$, где $a = a_0 + \cdots + a_n$.
\end{itemize}
Затем, получатель:
\begin{itemize}
 \item Вычисляет общий секрет $ss$ и на основе $a$ вычисляет $a + ss\ mod\ \ell$.
 \item Вычисляет $C = \sum C_i$, вычисляет $C - aG = bH$ и путём сравнения со всеми $bH$ в заданном диапазоне $[0, 2^n]$ находит $b$. (На практике это будет быстрый поиск на 500 килобайт при $n = 14$, как в предыдущем разделе. Если же в качестве верхнего предела будет выбрано значение $2^{32}$, как в работе \cite{GM}, поиск станет сложным с вычислительной точки зрения).
\end{itemize}

\section{Заключение}
Протокол кольцевых конфиденциальных транзакций обеспечивает строгую децентрализацию криптовалюты (то есть, отсутствие привилегированных сторон), что даёт возможность доказуемой оценки безопасности с точки зрения сокрытия сумм, источника и адресатов транзакций. Кроме того, создание монет согласно протоколу кольцевых конфиденциальных транзакций не требует доверия и является верифицируемо безопасным. Соблюдение этих пяти факторов необходимо в случае с подобными наличным деньгам криптовалютам, таким как Monero.

\bibliographystyle{plain}
\bibliography{main}

\appendix

\section{Приложение. Доказательства безопасности}

\subsection{Невозможность подделки MLSAG}

Невозможность подделки доказывается подобно тому, как это делается в работе \cite[Теорема 1]{LWW}. Допустим, $H_{1}$ и $H_{2}$ являются случайными оракулами, а $\mathcal{SO}$ является подписывающим оракулом, который выдаёт действительные MLSAG-подписи. Предположим, существует вредоносный алгоритм полиномиальной временной сложности (PPT) $\mathcal{A}$, с не ничтожной вероятностью способный подделать MLSAG на основе списка векторов ключей $L$
\[
Pr\left(\mathcal{A}\left(\mathcal{L}\right)\to\left(m,\sigma\right):Ver\left(L,m,\sigma\right)=True\right)>\frac{1}{Q_{1}\left(k\right)}
\]
где $Q_{1}$ является полиномиальным вводом параметра безопасности $k$, и где $\left(m,\sigma\right)$ не является одной из подписей, возвращаемой $\mathcal{S}\mathcal{O}$. Предположим, что $\mathcal{A}$ делает не более $q_{H}+nq_{S}$ (где $n$ является количеством ключей в $\mathcal{L}$)
запросов подписывающим оракулам $H_{1},H_{2}$ и $\mathcal{SO}$ соответственно. Предполагается, что оракулы $H_{1}$ и $H_{2}$ являются независимыми и случайными, а также соответствуют дублирующим запросам. Подписывающий оракул $\mathcal{SO}$ также может запрашивать $H_{1}$ и $H_{2}$. При наличии $\mathcal{A}$ я продемонстрирую возможность создания вредоносного PPT-алгоритма $\mathcal{M}$, который будет использовать $\mathcal{A}$ для вычисления дискретного логарифма одного из ключей в $\mathcal{L}$.

Если $L$ является набором векторов $\left\{ \overline{y_{1}},...,\overline{y_{n}}\right\}$, каждый из которых имеет размер $r$, (то есть, $\overline{y_{i}}=\left(y_{1}^{i},...,y_{r}^{i}\right)$ где $y_{1},...,y_{r}$ являются публичными ключами), то подделанная подпись
\[
\sigma=\left(c_{1},s_{1},...,s_{n},y_{0}\right)
\]
созданная $\mathcal{A}$, должна соответствовать
\[
c_{i+1}=H\left(\mathfrak{m},L_{i}^{1},R_{i}^{1},...,L_{i}^{m},R_{i}^{m}\right)
\]
где $i$ выбираются по модулю $n$, а $L_{i}^{j}$ и $R_{i}^{j}$ определяются так же, как описано в подразделе \ref{sub:MLSAG-Description}. Новый злоумышленник $\mathcal{M}$ может запросить $\mathcal{A}$ подделать подписи полиномиальное количество раз, используя Turing script $\mathcal{T}$, независимо от того, была или нет попытка подделки успешной.
\begin{lem}
\label{lem:RewindingLemma}\cite[Лемма 1]{LWW} %
{} Допустим, $\mathcal{M}$ задействует $\mathcal{A}$ для получения транскрипта $\mathcal{T}$. Если получение $\mathcal{T}$ будет успешным, $\mathcal{M}$, $\mathcal{T}$ перейдёт к заголовку $H$ и перемоделирует $\mathcal{A}$, чтобы получить $\mathcal{T}^{\prime}$ . Если $Pr\left(\mathcal{T}\ \mbox{успешен}\right)=\epsilon$, значит и $Pr\left(\mathcal{T}^{\prime}\mbox{успешен}\right)=\epsilon.$ \end{lem}
Доказательство вытекает из указанной Теоремы.

\begin{thm}
\label{thm:Unforgeability}При наличии допуска дискретного логарифмирования вероятность того, что $\mathcal{A}$ создаст верифицируемую поддельную MLSAG-подпись, ничтожна.
\end{thm}
\begin{proof}
Я следую системе обозначений, использованной выше. Подобно тому, как это изложено в работе \cite[Теорема 1]{LWW}, поскольку вероятность того, что выход случайного оракула будет угадан, ничтожна, для каждой успешной подделки $\mathcal{A}$ получает транскрипт $\mathcal{T}$, $H_{1}$ делается $m_{\mathcal{T}}$ запросов, соответствующих $n$ запросам, используемым для верификации подписи. Следовательно, допустим, что $X_{i_{1}},...,X_{i_{m}}$ обозначают эти запросы, используемые при верификации для такой $i^{ной}$ подделки, и допустим, что $\pi$ является индексом, соответствующим такому последнему запросу верификации для данной поделки
\[
X_{i_{m}}=H_{1}\left(m,L_{\pi-1}^{1},R_{\pi-1}^{1},...,L_{\pi-1}^{m_{\mathcal{T}}},R_{\pi-1}^{m_{\mathcal{T}}}\right).
\]
(Интуитивно, $\pi$ соответствует секретному индексу подделанной подписи, так как соответствует последнему запросу, переданному случайному оракулу по данной подписи).

Попытка подделки $\sigma$, сделанная $\mathcal{A}$, является $\left(\ell,\pi\right)$-подделкой если $i_{1}=\ell$ и $\pi$ такие же, как указано выше (таким образом, эта подделка соответствует запросам $\ell$ через $\ell+\pi$). Согласно допуску, существует такая пара $\left(\ell,\pi\right)$, что вероятность создания транскриптом $\mathcal{T}$ удачной подделки, $\epsilon_{\ell,\pi}\left(\mathcal{T}\right)$, будет соответствовать условию
\[
\epsilon_{\ell,\pi}\ge\frac{1}{m_{\mathcal{T}}\left(q_{H}+m_{\mathcal{T}}q_{S}\right)}\cdot\frac{1}{Q_{1}\left(k\right)}\ge\frac{1}{n\left(q_{H}+nq_{S}\right)}\cdot\frac{1}{Q_{1}\left(k\right)}.
\]
Теперь возвращаемся к началу $\mathcal{T}$ в место перед $\ell^{th}$запросом и снова пытаемся создать подделку по тому же набору ключей (и позволяем $H_{1}$ вычислить новые случайные варианты для всех последующих запросов), следовательно, согласно Лемме \ref{lem:RewindingLemma}, вероятность того, что $\mathcal{\mathcal{T}^{\prime}}$ также приведёт к удачной подделке, соответствует условию
\[
\epsilon_{\ell,\pi}\left(\mathcal{T}^{\prime}\right)\ge\frac{1}{n\left(q_{H}+nq_{S}\right)}\cdot\frac{1}{Q_{1}\left(k\right)}.
\]
Следовательно, вероятность того, что $\mathcal{T}$, так и $\mathcal{T}^{\prime}$ соответствуют верифицируемым поделкам $\sigma$ и $\sigma^{\prime}$ не ничтожна:
\[
\epsilon_{l,\pi}\left(\mathcal{T\ }and\ \mathcal{T}^{\prime}\right)\ge\left(\epsilon_{l,\pi}\left(\mathcal{T}\right)\right)^{2}.
\]


Поскольку новые случайные варианты были вычислены для выходов случайного оракула для $H_{1},$ , существует огромная вероятность того, что есть такое $j$, что $s_{\pi}^{j}\neq s_{\pi}^{\prime j}$ и $c_{\pi}\neq c_{\pi+1}$. Таким образом, мы можем найти решение для приватного ключа по индексу $\pi$:
\[
x_{\pi}^{j}=\frac{s_{\pi}^{\prime j}-s_{\pi}^{j}}{c_{\pi}-c_{\pi}^{\prime}}\ mod\ q
\]
что противоречит допуску дискретного логарифмирования.
\end{proof}

\subsection{Связываемость MLSAG}
\begin{thm}
(Cвязываемость образов ключей). Вероятность того, что PPT-алгоритм злоумышленника $\mathcal{A}$ сможет создать такие две верифицируемые (и несвязываемые при заданных параметрах) подписи $\sigma,\sigma^{\prime}$, подписанные согласно векторов ключей $\overline{y}$ и $\overline{y}^{\prime}$, соответственно, и что в обоих $\overline{y}$ и $\overline{y}^{\prime}$ будет присутствовать публичный ключ $y$, ничтожна. \end{thm}
\begin{proof}
Предположим, наоборот, что $\mathcal{A}$ создал две верифицируемые подписи $\sigma$ и $\sigma^{\prime}$, каждая из которых подписана по векторам ключей $\overline{y}$ и $\overline{y}^{\prime}$, соответственно, таким образом, что существует публичный ключ $y$, как в $\overline{y}$, так и в $\overline{y}^{\prime}.$
Допустим, $y$ появляется в качестве элемента $j$ из $\overline{y}$, а также $j^{\prime}$, в качестве элемента $\overline{y}^{\prime}.$ Согласно Теореме \ref{thm:Unforgeability}, существует большая вероятность существования таких индексов $\pi$ и $\pi^{\prime}$ для публичных ключей в $\sigma$ и $\sigma^{\prime}$, соответственно, что
\[
L_{\pi}^{j}=s_{\pi}^{j}G+c_{\pi}y_{\pi}^{j}
\]
\[
R_{\pi}^{j}=s_{\pi}^{j}H\left(y_{\pi}^{j}\right)+c_{\pi}I_{j}
\]
и
\[
L_{\pi^{\prime}}^{j\prime}=s_{\pi^{\prime}}^{j^{\prime}}G+c_{\pi^{\prime}}y_{\pi^{\prime}}^{j^{\prime}}
\]
\[
R_{\pi^{\prime}}^{j^{\prime}}=s_{\pi^{\prime}}^{j^{\prime}}H\left(y_{\pi^{\prime}}^{j^{\prime}}\right)+c_{\pi^{\prime}}I_{j^{\prime}}
\]
с
\[
log_{G}L_{\pi}^{j}=log_{H\left(y_{\pi}^{j}\right)}R_{\pi}^{j}
\]
и
\[
log_{G}L_{\pi^{\prime}}^{j^{\prime}}=log_{H\left(y_{\pi^{\prime}}^{j^{\prime}}\right)}R_{\pi^{\prime}}^{j^{\prime}}
\]
При допуске, что $x$ обозначает приватный ключ $y,$ $y=xG$, после решения вышеуказанных уравнений для $I_{j}$ и $I_{j^{\prime}}$, следует, что $I_{j}=xH\left(y_{\pi}^{j}\right)=xH\left(y\right)$ и подобным образом $I_{j^{\prime}}=xH\left(y\right).$ Таким образом, две подписи включают в себя $I_{j}=I_{j^{\prime}}$, а следовательно, так как дублирующие друг друга образы ключей отклоняются, один из них не будет верифицирован.
\end{proof}
\subsection{Анонимность MLSAG}
Чтобы доказать анонимность, обеспечиваемую вышеуказанным протоколом в рамках модели случайного оракула, допустим, что $H_{1}$ и $H_{2}$ являются случайными оракулами, моделирующими дискретные хеш-функции. Допустим, $\mathcal{A}$ направлен на нейтрализацию анонимности. Я создаю злоумышленника $\mathcal{M}$ против допуска задачи решения Диффи-Хеллмана (DDH) следующим образом. Допуск DDH предполагает, что при наличии набора элементов $\left(G,aG,bG,\gamma G\right)$ вероятность определения того, что $\gamma G=abG$, ничтожна.
\begin{thm}
\label{thm:Ring-CT-protocol}Протокол Ring CT обеспечивает сокрытие подписанта согласно допуску задачи решения Диффи-Хеллмана. \end{thm}
%asdf stopped editing here
\begin{proof}
(Подобно доказательству, приведённому в работе \cite[Теорема 2]{LWW}). Предположим, что задача решения Дифии-Хеллмана сложна в случае циклической группой, созданной $G$, и предположим, что существует некоторый PPT-алгоритм, используемый злоумышленником $\mathcal{A}$, направленный на раскрытие подписанта. Таким образом, при наличии списка $L$, в который входит $n$ векторов публичных ключей длиной $m$, набора, состоящего из $t$ приватных ключей $\mathcal{D}_{t}=\left\{ x_{1},...,x_{t}\right\} $, действительная подпись $\sigma$ по $L$, подписанная пользователем по вектору ключа $\overline{y}$ так, что соответствующий вектор приватного ключа $\overline{x}=\left(x_{1}^{\pi},...,x_{m}^{\pi}\right)$
соответствует $x_{j}^{\pi}\notin\mathcal{D}_{t}$, $\mathcal{A}$ сможет вычислить $\pi$ с вероятностью
\[
Pr\left(\mathcal{A}\to\pi\right)>\frac{1}{n-t}+\frac{1}{Q\left(k\right)}
\]
для некоторого полиномиального $Q\left(k\right)$. Мною строится PPT-алгоритм $\mathcal{M}$, который в качестве входа берёт набор элементов $\left(G,aG,bG,c_{i}G\right)$, в котором значение $i\in \{0,1\}$ выбирается случайным образом (и не известно $\mathcal{M}$ заранее), $c_{1}=ab$ и $c_{0}$ является случайной скалярной величиной, и выводит $i$ с вероятностью
\[
Pr\left(\mathcal{M}\left(G, aG,bG,c_{i}G\right)\to i\right)\ge\frac{1}{2}+\frac{1}{Q_{2}\left(k\right)}
\]
для некоторого полиномиального $Q_{2}\left(k\right)$.

Рассмотрим алгоритм SIMNIZKP (подобный тому, определение которому даётся в работе \cite{FS}), который в качестве входа берёт скалярные величины $a$ и $c$, вектор приватного ключа $\overline{x}$, набор векторов публичных ключей $\overline{y}_{i},i=1,...,m$, индекс $\pi$, сообщение $\mathfrak{m}$ и использует их следующим образом:

1. Генерирует случайные скалярные величины $s_{1},...,s_{m}$ и случайную скалярную величину $c_{\pi}\leftarrow H$.

2. Для $j$ индексирование $\overline{x}$ задаёт
\[
L_{\pi}^{1}=aG
\]
\[
R_{\pi}^{1}=cG
\]
и для всех остальных $j$
\[
L_{\pi}^{j}=s_{\pi}^{j}G+c_{\pi}y_{\pi}^{j}
\]
\[
R_{\pi}^{j}=s_{\pi}^{j}H\left(y_{\pi}^{j}\right)+c_{\pi}x^{j}H\left(y_{\pi}^{j}\right)
\]

3. На основе случайного оракула вычисляет случайный выход
\[
c_{\pi+1}\leftarrow H\left(\mathfrak{m},L_{\pi}^{1},R_{\pi}^{1},...,L_{\pi}^{m},R_{\pi}^{m}\right).
\]

4. Для каждого $i$, по модулю $m$, вычисляет
\[
L_{i}^{j}=s_{i}^{j}G+c_{i}y_{\pi}^{j}
\]
\[
R_{i}^{j}=s_{i}^{j}H\left(y_{i}^{j}\right)+c_{i}x^{j}H\left(y_{i}^{j}\right)
\]
\[
c_{i+1}\leftarrow H\left(\mathfrak{m},L_{i}^{1},R_{i}^{1},...,L_{i}^{m}+R_{i}^{m}\right).
\]
и следует отметить, что, по крайней мере, на последнем этапе, где $i=\pi-1$, значение $c_{i+1}$ уже определено, что обеспечивает соответствие выходу случайного оракула.

Также необходимо отметить, что независимо от того, является ли $\overline{x}$ фактическим приватным ключом, соответствующим $\overline{y}$, из-за того, что в последующих вызовах соответствие поддерживается случайными оракулами, вышеуказанная подпись является верифицируемой. Если $\overline{x}$ действительно является вектором приватного ключа $\overline{y}$, нет никакой разницы между SIMNIZKP и подлинной подписью.

Наконец, при наличии набора элементов $\left(G,aG,bG,c_{i}G\right)$, в котором $a$ и $b$ являются случайно выбранными скалярными величинами, $c_{1}=ab$, $c_{0}$ является случайным элементом, $i\in\left\{ 0,1\right\}$, $\mathcal{M}$ для решения задачи Диффи-Хеллмана с не незначительной вероятностью выполняет следующие шаги. $\mathcal{M}$ берёт у случайного оракула случайное $\gamma\leftarrow H$ и берёт пару векторов приватного/публичного ключа $\left(\overline{x},\overline{y}\right)$, а затем вычисляет $s$ так, чтобы $a=s+\gamma x$. Затем, $\mathcal{M}$ выполняет алгоритм SIMNIZKP, используя произвольно выбранные векторы ключей $\left\{ \overline{y_{i}}\right\} _{i=1,...,n}$ так, чтобы $\overline{y}=\overline{y}_{\pi},$ $a\to a$, $c_{i}\to c$ некоторое сообщение $\mathfrak{m}$ и $\overline{x}\to\overline{x}$.

В том случае, если $i=1$, то $c=ab$ и
\[
log_{G}aG=log_{bG}cG=a
\]
и поскольку предполагается, что $\mathcal{A}$ с не ничтожной вероятностью способен найти $\pi$ , существует и не ничтожная вероятность более $\frac{1}{2}$, что $\mathcal{A}$ выдаст $1$ (по которой $\mathcal{M}$ выдаст $1$). Если $i=0$, то $\mathcal{A}$
выдаёт $1$ только с вероятностью $\frac{1}{2}$, и с не незначительной вероятностью более $\frac{1}{2}$, $\mathcal{M}$выдаёт то же значение, что и $\mathcal{A}$, и таким образом решает задачу Диффи-Хеллмана для случайно выбранных скалярных величин с не незначительной вероятностью более $\frac{1}{2}$, что является противоречием.
\end{proof}

\section{Пример кода Ring CT}
В репозитории \cite{Snoe} мною был опубликован простой пример работы протокола кольцевых конфиденциальных транзакций с применением MLSAG-подписей, описанных в Разделе \ref{MLSAGsection}, а также ASNL-подписей, о которых говорится в Разделе \ref{AgSchnorr}:
\begin{verbatim}
H_ct = RingCT.getHForCT()
print("H", H_ct)
sr, Pr = PaperWallet.skpkGen() #receivers private/ public
se, pe, ss = ecdh.ecdhgen(Pr) #compute shared secret ss
digits = 14 #in practice it will be 14
print("inputs")
Cia, L1a, s2a, sa, ska = RingCT.genRangeProof(10000, digits)
print("outputs")
Cib, L1b, s2b, sb, skb = RingCT.genRangeProof(7000, digits)
Cic, L1c, s2c, sc, skc = RingCT.genRangeProof(3000, digits)
print("verifying range proofs of outputs")
RingCT.verRangeProof(Cib, L1b, s2b, sb)
RingCT.verRangeProof(Cic, L1c, s2c, sc)
x, P1 = PaperWallet.skpkGen()
P2 = PaperWallet.pkGen()
C2 = PaperWallet.pkGen()
#some random commitment grabbed from the blockchain
ind = 0
Ca = RingCT.sumCi(Cia)
Cb = RingCT.sumCi(Cib)
Cc = RingCT.sumCi(Cic)
sk = [x, MiniNero.sc_sub_keys(ska, MiniNero.sc_add_keys(skb, skc))]
pk = [[P1, P2], [MiniNero.subKeys(Ca, MiniNero.addKeys(Cb, Cc)), \
MiniNero.subKeys(C2, MiniNero.addKeys(Cb, Cc)) ] ]
II, cc, ssVal = MLSAG.MLSAG_Sign(pk, sk, ind)
print("Sig verified?", MLSAG.MLSAG_Ver(pk, II, cc, ssVal) )
print("Finding received amount corresponding to Cib")
RingCT.ComputeReceivedAmount(pe, sr, MiniNero.addScalars(ss, skb), Cib)
print("Finding received amount corresponding to Cic")
RingCT.ComputeReceivedAmount(pe, sr, MiniNero.addScalars(ss, skc), Cic)
\end{verbatim}
Вот пример транзакции со входом номиналом $10,000$ и выходами номиналом $3,000$ и $7,000$.
\begin{verbatim}
('H', '61fe7f0f5a607a33427d01dd1fded5ffa03fae2e9df9ebccf2e0a2f5bd77a204')
inputs
('b, b in binary', 10000, [0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 1])
Generating Aggregate Schnorr Non-linkable Ring Signature
outputs
('b, b in binary', 7000, [0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0])
Generating Aggregate Schnorr Non-linkable Ring Signature
('b, b in binary', 3000, [0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0])
Generating Aggregate Schnorr Non-linkable Ring Signature
verifying range proofs of outputs
Verifying Aggregate Schnorr Non-linkable Ring Signature
Verified
Verifying Aggregate Schnorr Non-linkable Ring Signature
Verified
('Generating MLSAG sig of dimensions ', 2, 'x ', 2)
('verifying MLSAG sig of dimensions ', 2, 'x ', 2)
('c',
['80a3cfd06dd2862307cd75c2a1566f20cd743dbb0b9feb22d79dcbecb9023f42',
'a9b7342ba7bf2f102505ca19dab734fde638916c0a29f5b30e49833ab51393ea',
'80a3cfd06dd2862307cd75c2a1566f20cd743dbb0b9feb22d79dcbecb9023f42'])
('sig verifies?', True)
('Sig verified?', True)
Finding received amount corresponding to Cib
('received ', 7000,
'a488ec68732fb551841c2c6dcc7ffac895d98ec7e9378275ed20ea12805fc18e')
Finding received amount corresponding to Cic
('received ',3000,
'1b46626858e130a0f3884c74c9fdeabc4d812c519103ea16a35a3f82a3d0ed6d')
\end{verbatim}

\end{document}
