% This is based on the LLNCS.DEM the demonstration file of % the LaTeX macro
% package from Springer-Verlag % for Lecture Notes in Computer Science, version
% 2.4 for LaTeX2e as of 16. April 2010
%
% See http://www.springer.com/computer/lncs/lncs+authors?SGWID=0-40209-0-0-0
% for the full guidelines.
\documentclass{llncs}

 \addtolength{\oddsidemargin}{-.875in}
 \addtolength{\evensidemargin}{-.875in}
 \addtolength{\textwidth}{1.75in}

 \addtolength{\topmargin}{-.875in}
 \addtolength{\textheight}{1.75in}

\usepackage{graphicx}
\graphicspath{ {./assets/} }

\usepackage{enumitem}
\setlist[enumerate]{itemsep=2mm}

\usepackage{dirtytalk}
\usepackage{minted}
%\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{amsfonts}
\usepackage{extarrows}
\usepackage{pdflscape}
\usepackage[pass]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english,russian]{babel}
\renewcommand\definitionname{Определение}

%
% Tables
% --------
\usepackage[table]{xcolor}
\usepackage{hhline}
\usepackage{booktabs} % much better tables
\usepackage{multirow} % allows to fuse rows
\usepackage{array}    % manipulate array
\usepackage{tabularx} % better tables

% Define new tabularx column types:
%  - R: stretched right aligned
%  - C: stretched centered
%  - N: left aligned, specified space
\newcolumntype{R}{>{\raggedleft\arraybackslash}X}
\newcolumntype{C}{>{\centering\arraybackslash}X}
\newcolumntype{N}[1]{>{\raggedleft\arraybackslash}p{#1}}
\newcolumntype{S}{>{\hsize=.5\hsize}C}

% Set row height multiplier to provide more breathing space
\renewcommand{\arraystretch}{1.5}

\usepackage[backend=biber]{biblatex}
\addbibresource{bibliography.bib}

\pagestyle{plain}
\setcounter{page}{1}
\pagenumbering{arabic}

%\usepackage{pgfplots}
%\pgfplotsset{width=6cm}
\usepackage{float}
\usepackage[caption = false]{subfig}

\newcommand{\BTX}{\texttt{BTX}}
\newcommand{\XTX}{\texttt{XTX}}

\newcommand{\Enc}{\textsf{Enc}}
\newcommand{\EncGen}{\textsf{EncGen}}
\newcommand{\EncSign}{\textsf{EncSign}}
\newcommand{\EncVer}{\textsf{EncVrfy}}

\newcommand{\DecSig}{\textsf{DecSig}}
\newcommand{\KeyGen}{\textsf{Gen}}
\newcommand{\Sign}{\textsf{Sign}}
\newcommand{\Verify}{\textsf{Vrfy}}
\newcommand{\Rec}{\textsf{Rec}}
\newcommand{\RecKey}{\textsf{RecKey}}
\newcommand{\hatsigma}{\hat{\sigma}}

\newcommand{\DLGen}{\textsf{DLGen}}
\newcommand{\DLProve}{\textsf{DLProve}}
\newcommand{\DLVrfy}{\textsf{DLVrfy}}

\newcommand{\InitTx}{\textsf{InitTx}}
\newcommand{\SignTx}{\textsf{SignTx}}
\newcommand{\VrfyTx}{\textsf{VrfyTx}}
\newcommand{\PubTx}{\textsf{PubTx}}
\newcommand{\WatchTx}{\textsf{WatchTx}}
\newcommand{\RecSig}{\textsf{RecSig}}

\newcommand{\skSign}{sk_S}
\newcommand{\pkSign}{pk_S}
\newcommand{\kSign}{(\skSign,\pkSign)}
\newcommand{\skEnc}{sk_E}
\newcommand{\pkEnc}{pk_E}
\newcommand{\kEnc}{(\skEnc, \pkEnc)}
\newcommand{\rec}{\delta}

\newcommand{\bin}{\{0,1\}}

\newcommand{\GG}{\mathbb{G}}
\newcommand{\HH}{\mathbb{H}}

\begin{document}

\title{Атомные свопы между блокчейнами Bitcoin и Monero}
\author{Джоэл Гуггер (Jo\"el Gugger)}

\authorrunning{Jo\"el Gugger et al.}
\tocauthor{Jo\"el Gugger}
\institute{\email{h4sh3d@protonmail.com}}

\maketitle

\begin{abstract}
    Атомные свопы уже используются в случае с блокчейнами, где возможно использование контрактов с хешированной временной блокировкой. Но когда один из блокчейнов не предусматривает такой возможности, это становится проблемой. Данный протокол описывает, как обеспечить возможность проведения атомных свопов между блокчейнами Bitcoin и Monero в рамках двух транзакций на блокчейн без привлечения каких-либо централизованных организаций, серверов или других участников, требующих доверия.
    Нами предлагается вариант проведения свопа между двумя участниками, один из которых владеет Bitcoin, а другой - Monero. При этом, если оба участника последуют этому протоколу, их средства ни на каком этапе не будут подвергаться какому-либо риску. Протокол не требует ни использования временной блокировки со стороны Monero, ни реализации скриптов, но требует наличия двух доказательств знания равного дискретного логарифма в группах \texttt{edward25519} и \texttt{secp256k1}, а также одноразовой подписи VES \texttt{ECDSA}.\linebreak

    \textbf{Ключевые слова:} блокчейн, атомный своп, проведение транзакций между блокчейнами, Bitcoin, Monero
\end{abstract}

\section{Введение}
Нами описывается протокол проведения атомных свопов между блокчейнами Monero и Bitcoin, но данный протокол можно обобщить для любой криптовалюты, которая соответствует тем же требованиям, что и Monero, а также любой другой криптовалюты, которая соответствует тем же требованиям, что и Bitcoin. Подробный список предварительных условий приводится в Главе \ref{prerequisites}.

Участники отправляют средства на определенный адрес, генерируемый во время процесса (блокировка) в каждом блокчейне (обмен между блокчейнами), и каждая сторона может взять под контроль средства в другом блокчейне (своп) автоматически (то есть возможность получения средств из любого блокчейна является взаимоисключающей из-за возможности забирать средства из другого блокчейна).

В ходе реализации данного процесса участники не раскрывают своих средств, если следуют протоколу надлежащим образом, а это означает, что своп не требует доверия и не требует никакого залога, что позволяет двум незнакомым людям обмениваться криптовалютами без каких-либо рисков или посредничества третьей стороны.

\section{Сценарий}
Опишем участников и их мотивацию. Элис, у которой есть Monero (XMR), и Боб, у которого есть Bitcoin (BTC), хотят обменяться своими средствами. Предполагается, что они договорились о цене заранее (то есть согласовали ту сумму Bitcoin, которая будет обменена на определённую сумму Monero). Такое согласование сумм также может быть интегрировано в протокол, например, с помощью сервисов обмена, которые будут указывать соответствующую цену своим клиентам.

Оба участника желают использовать только один из двух возможных путей выполнения протокола (которые являются взаимоисключающими друг для друга): (1) протокол выполняется успешно, и Элис получает Bitcoin, а Боб получает Monero, или же (2) протокол не выполняется, и оба сохраняют свои изначальные средства за вычетом минимально возможной комиссии за проведение транзакций.

\subsection{Успешный своп}
Если оба участника будут следовать протоколу, то будет проведено всего четыре транзакции (три, если Monero не будут переведены сразу после завершения, что не является проблемой): две в блокчейне Bitcoin и две в блокчейне Monero. Первые транзакции в обоих блокчейнах блокируют средства и готовят их к обмену в каждом из блокчейнов. Вторые разблокируют средства только для одного участника и дают об этом знать другому участнику, который принимает на себя контроль над выходом в другом блокчейне.

Это оптимальный вариант выполнения протокола, не требующий временной блокировки, использующий минимальное количество транзакций и только блокировку средств для минимального подтверждения в каждом из блокчейнов в зависимости от уровня безопасности, ожидаемого каждым участником, то есть сколько подтверждений транзакции потребуется каждому участнику, чтобы она считалась окончательной и можно было бы перейти к следующему шагу, предусмотренному протоколом.

\subsection{Правильное прерывание свопа}
При блокировке Bitcoin (после временной блокировки) Элис или Боб могут запустить процесс возврата заблокированных средств. На этот момент Monero, возможно, еще не будут заблокированы. Если ни одна Monero заблокирована не была, в процессе будут возвращены только Bitcoin. В противном случае у Элис будет достаточно информации, чтобы вернуть и свои Monero.

Когда транслируется транзакция возврата, Боб должен осуществить возврат до истечения срока некоторой временной блокировки, иначе в конечном счёте он может потерять свой Bitcoin, не получив при этом Monero. С точки зрения Боба это можно описать как интерактивный протокол, то есть Боб не может перейти в оффлайн - он должен реагировать на подобную ситуацию во время свопа. Элис, с другой стороны, может оставаться оффлайн.

\subsection{Наихудший сценарий}
Если своп отменяется запуском процесса возврата и Боб не воспользуется возможностью возврата до истечения срока временной блокировки, Элис сможет потребовать возврат средств, не раскрывая известной информации, необходимой Бобу, чтобы воспользоваться возвратом в другом блокчейне. Таким образом, один участник, Боб, оказывается в невыгодном положении, и уже требуется три транзакции Bitcoin вместо двух.

\subsubsection{Обоснование.}
\label{worstCaseRationale}
Мы выбрали этот вариант, чтобы избежать следующего вероятного сценария: если Monero будут заблокированы, Элис сможет вернуть их тогда и только тогда, когда Боб уже вернёт свои Bitcoin. Нам нужен механизм, который бы мотивировал Боба воспользоваться возможностью возврата, чтобы избежать тупиковой ситуации в процессе возврата или чтобы Элис получила компенсацию, если Боб не станет следовать протоколу надлежащим образом.

В противном случае Боб, обладая всей полученной им информацией, может уйти в оффлайн и перевести свои Bitcoin через год после свопа, вынуждая Элис постоянно отслеживать блокчейн, пока она не увидит транзакцию Боба и не узнает последнюю часть информации, которая ей необходима, чтобы разблокировать её Monero.

\section{Необходимые условия}
\label{prerequisites}
Как говорилось ранее, чтобы своп проводился автоматически, необходима возможность условного выполнения. Bitcoin использует простой язык сценариев на базе стеков, который обеспечивает возможность условного выполнения и временных блокировок. С другой стороны, в настоящий момент протокол RingCT, ориентированный на обеспечение анонимности Monero, для разблокировки UTXO предусматривает только использование подписей. Контроль над UTXO связан только с тем, кто контролирует соответствующие приватные ключи. Тогда задача состоит в том, чтобы передать контроль над средствами только при условии знания некоторых приватных ключей.

В этой главе мы рассмотрим все необходимые части информации, необходимые для выполнения атомных свопов в обоих блокчейнах и вне блокчейна в рамках ранее раскрытого сценария.

\subsection{Monero}
Monero не требует использования каких-либо примитивов в блокчейне (блокировки по хешам, временной блокировки). Все структурные элементы являются примитивами, реализуемыми вне блокчейна. Поэтому нам необходимо предоставить доказательства правильной инициализации протокола, подобные тем, что описаны в подпункте \ref{eqDiscreteLog}. Эти доказательства гарантируют атомарность свопа для каждого участника.

\subsubsection{Секретные части.}
В случае с Monero необходимы для обеспечения двустороннего выполнения. Приватный ключ траты Monero разбивается на две секретные части: $k^s_a$ и $k^s_b$. Участники не используют какого-либо протокола мультиподписи. Вместо этого при инициализации процесса свопа секретные части распределяются между участниками, и один из них узнаёт полный ключ $k^s \equiv k^s_a + k^s_b \pmod l$ при окончании выполнения протокола либо при удачном завершении свопа, либо при его прерывании.

\subsection{Bitcoin}
\label{bitcoinPrerequisites}
Транзакции Bitcoin в рамках данного протокола требуют гибкости транзакций, которая была обеспечена обновлением \texttt{SegWit}. Это позволяет нам включать транзакции в блокчейн без их общей трансляции. Данный протокол совместим только с теми криптовалютами, которые используют модель \texttt{UTXO} в стиле Bitcoin и имеют эквивалентный механизм обеспечения гибкости, такими как Litecoin (то есть с Bitcoin Cash этот протокол будет несовместим).

\subsubsection{Временная блокировка.}
Используется для реализации новых путей выполнения по истечении какого-либо предварительно заданного интервала времени, например, для запуска процесса возврата после блокировки средств в одном из блокчейнов без какой-либо конкуренции. Стоит отметить, что при этом в другом блокчейне не требуется никакой временной блокировки.

\subsubsection{Блокировка по хешу.}
Используется для синхронизации обоих блокчейнов перед запуском свопа.

\subsubsection{Схема мультиподписи «2 из 2».}
Используется для создания общего пути, доступного только для двух участников при наличии их согласия. В рамках данного протокола мы используем опцию, реализуемую в блокчейне, в контексте Bitcoin, но схемы мультиподписи, реализуемые вне блокчейна, более эффективны, и при иных вариантах следует использовать именно их.

\subsubsection{Протокол частичного отсутствия скриптов.}
Используется, чтобы раскрыть секретную часть и продолжить выполнение протокола, не прибегая к сложным скриптам. Мы используем одноразовую подпись VES ECDSA, подобную описанной в подпункте \ref{oneTimeEcdsaVES}. Следует отметить, что полный протокол «скриптов без скриптов» \cite{poelstra-adaptor} должен позволить добиться тех же результатов, но с большей эффективностью.

\subsection{Применение равного дискретного логарифма в групповых доказательствах знания с нулевым разглашением}
Применение равного дискретного логарифма в групповых доказательствах знания с нулевым разглашением, описанное в технической записке \cite{MRL0010}, позволяет верифицировать общий дискретный логарифм $\alpha$ при наличии двух групп с заданными генераторами $G \in \GG$ и $H \in \HH$, где $\alpha \leq min(|G|,|H|)$, что возвращает в результате $xG$ и $yH$: $x=y=\alpha$.

В нашем контексте мы фокусируем внимание на группах \texttt{edward25519} с $|G| = l$ и \texttt{secp256k1} с $|H| = n$.

\begin{definition}[применение равного дискретного логарифма в групповой схеме]
    Применение равного дискретного логарифма в групповой схеме определяется двумя алгоритмами с набором параметров $(\GG,\HH,G,G',H,H')$:
\begin{itemize}
    \item $\DLProve(\alpha) \rightarrow (\phi,A,B)$: вероятностный алгоритм доказательства, который при наличии вводного дискретного логарифма $\alpha$ выдаёт доказательство $\phi$, точку $A \in \GG$ и точку $B \in \HH$.
    \item $\DLVrfy(\phi,A,B) \rightarrow \{0,1\}$: детерминированный алгоритм верификации доказательства,  который при наличии вводного доказательства $\phi$, точки $A \in \GG$ и точки $B \in \HH$ выдаёт 1, если (и только в том случае) $(A,B)$ имеют общий дискретный логарифм в соответствующих группах.
\end{itemize}
\end{definition}

\subsubsection{Параметры кривой.}
\label{curveParams}
Bitcoin и Monero используют разные эллиптические кривые. Bitcoin в соответствии со \textit{стандартами эффективной криптографии (SEC)} использует кривую \texttt{secp256k1} и алгоритм \texttt{ECDSA}. Monero, в основе которой лежит вторая версия протокола CryptoNote \cite{van2013cryptonote}, использует кривую \texttt{curve25519}, далее также называемую \texttt{edward25519}, предложенную Дэниелом Дж. Бернштейном \cite{CerRes10}.

Мы обозначаем параметры

\subsubsection{\texttt{для кривой edward25519}} как
\begin{equation}
\begin{split}
    q&: \text{простое число;}\ q = 2^{255} - 19 \\
    d&: \text{элемент } \mathbb{F}_q;\ d = - 121665/121666 \\
    \mathcal{E}&: \text{уравнение эллиптической кривой};\ -x^2 + y^2 = 1 + dx^2y^2 \\
    G&: \text{базовая точка};\ G = (x, -4/5) \\
    l&: \text{порядок базовой точки};\ l = 2^{252} + \text{\scriptsize27742317777372353535851937790883648493} \\
\end{split}
\end{equation}

\subsubsection{\texttt{для кривой secp256k1}} как
\begin{equation}
\begin{split}
    p&: \text{простое число;}\ p = 2^{256} - 2^{32} - 977 \\
    a&: \text{элемент } \mathbb{F}_p;\ a = 0 \\
    b&: \text{элемент } \mathbb{F}_p;\ b = 7 \\
    \mathcal{E}'&: \text{уравнение эллиптической кривой};\ y^2 = x^3 + ax + b \\
    H&: \text{базовая точка};\ H = \\ (&\texttt{\scriptsize0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798},\\ &\texttt{\scriptsize0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8}) \\
    n&: \text{порядок базовой точки};\ n = 2^{256} - \text{\scriptsize{432420386565659656852420866394968145599}} \\
\end{split}
\end{equation}

\subsection{\texttt{Одноразовая подпись VES} ECDSA}
\label{oneTimeEcdsaVES}
\texttt{Схема одноразовой подписи VES ECDSA} предложена Фурнье и др. в работе \cite{oneTimeVES} в качестве обобщения концепции адаптивных подписей в рамках схемы \texttt{Шнорра} \cite{Schnorr:1989:EIS:646754.705037} и \texttt{ECDSA}. Одноразовые верифицируемые зашифрованные подписи, далее именуемые нами одноразовыми подписями VES, построены таким образом, что при знании шифротекста и простого текста появляется возможность восстановления ключа шифрования.

Мы перечисляем некоторые из алгоритмов, определяемых в работе \cite{oneTimeVES}:

\begin{definition}[\texttt{одноразовая подпись VES} ECDSA]
    Схема \texttt{одноразовой подписи VES} ECDSA содержит:
\begin{itemize}
    \item $\EncSign(\skSign, \pkEnc, m) \hskip2.3pt{\mbox{\tiny${\$}$\normalsize}}\!\!\rightarrow \hatsigma$: возможный вероятностный алгоритм создания зашифрованной подписи, который при наличии вводного секретного ключа подписи $\skSign$, публичного ключа шифрования $\pkEnc$ и сообщения $m$ выдаёт шифротекст $\hatsigma$.
    \item $\EncVer(\pkSign, \pkEnc, m, \hatsigma) \rightarrow \bin$: детерминированный алгоритм верификации зашифрованной подписи, который при наличии вводного публичного ключа подписи $\pkSign$, публичного ключа шифрования $\pkEnc$, сообщения $m$ и шифротекста $\hatsigma$ выводит 1, если и только если $\hatsigma$ является действительной зашифрованной версией подписи сообщения $m$ для $\pkSign$ при $\pkEnc$.
    \item $\DecSig(\skEnc, \hatsigma) \rightarrow \sigma$: (как правило) детерминированный алгоритм расшифровки подписи, который при наличии вводного ключа расшифровки $\skEnc$ и действительного шифротекста $\hatsigma$, соответствующего ключу шифрования, выдаёт действительную подпись $\sigma$.
    \item $\RecKey(\pkEnc, \hatsigma) \rightarrow \delta$: детерминированный алгоритм выведения ключа восстановления, который на основе шифротекста $\hatsigma$ и публичного ключа шифрования $\pkEnc$ выводит ключ восстановления $\delta$.
    \item $\Rec(\sigma,\rec) \rightarrow \skEnc$: детерминированный алгоритм восстановления ключа расшифровки, который при наличии расшифрованной подписи $\sigma$ и ключа восстановления $\rec$, связанного с оригинальным шифротекстом, выдаёт секретный ключ расшифровки $\skEnc$.
\end{itemize}
\end{definition}

\subsection{Обобщение}
Как было сказано в подпункте, связанном с Monero, требования к наличию примитивов в блокчейне отсутствуют. Мы только генерируем приватный ключ и используем адреса. А это значит, что данная схема может быть обобщена для пары криптовалют, одна из которых будет соответствовать предварительным условиям, связанным с Bitcoin, что делает эту схему очень агностической в отношении блокчейна, о чём говорится в работе \cite{succinct-atomic-swap} (при условии наличия вышеуказанных криптографических примитивов для базовых параметров блокчейнов). Тем не менее стоит отметить, что другие схемы будут проще и эффективней, если оба блокчейна в паре будут обладать возможностями реализации в блокчейне. Но такие схемы уже в целом были развёрнуты \cite{atomic-swap, scriptless-atomic-swap, btcGrinSwap}.

\section{Протокол}
Протокол работает следующим образом: Элис переводит Monero на определённый адрес. При этом каждый из участников владеет своей половиной приватного ключа траты (далее именуемой «частью»). Затем для раскрытия одной из половин приватного ключа траты (в зависимости от того, кто из участников забирает Bitcoin) используется язык сценариев Bitcoin и протоколы частичного отсутствия скриптов. В зависимости от того, кто раскрывает свою половину приватного ключа траты, Monero меняет владельца. Транзакции Bitcoin строятся таким образом, что в том случае, если участники будут следовать протоколу, при завершении свопа никаких потерь быть не должно.

Если сделка состоится, Элис потратит свой Bitcoin, раскрыв свою часть приватного ключа траты, что позволит Бобу потратить заблокированный Monero. Если сделка будет отменена, Боб потратит Bitcoin по истечении времени первой временной блокировки, раскрыв свою часть приватного ключа, что позволит Элис потратить Monero. В обеих случаях комиссии за проведение транзакции будут минимальными.

Обмен ключами выполняется при помощи одноразовой подписи VES \texttt{ECDSA} (а также адаптивных подписей) и применения равного дискретного логарифма в групповых доказательствах знания с нулевым разглашением. Одноразовые подписи VES строятся таким образом, что при наличии шифротекста и расшифрованной подписи ключ расшифровки легко восстанавливается. При выборе части приватного ключа (половины полного приватного ключа траты Monero) в качестве ключа расшифровки мы получаем способ автоматической продажи части приватного ключа другому участнику. Таким образом, поскольку Bitcoin и Monero используют различные кривые, нам необходимо доказать отношение между точками на \texttt{edward25519} и \texttt{secp256k1}, чтобы гарантировать отсутствие в необходимости доверия в рамках протокола.

\subsection{Неинтерактивный возврат}
Если Элис или Боб заблокировали свои средства, но один из них в определённый момент прерывает своп или связь, протокол не должен требовать наличия интерактивности для выполнения процедуры возврата средств обоим участникам.  В противном случае Элис, не отвечая, сделает Боба заложником, которому придётся ждать истечения срока второй временной блокировки, чтобы забрать Bitcoin. При надлежащим образом прерванном свопе Боб должен раскрыть свою часть приватного ключа Monero, что позволит Элис вернуть свои Monero при помощи одноразовой подписи VES.

Одноразовая подпись VES \texttt{ECDSA} является интерактивной: один из участников должен предоставить зашифрованную подпись, и если её верификация будет успешной, другой участник в ответ предоставит действительную подпись в соответствии со схемой мультиподписи Bitcoin «2 из 2» (протокол частичного отсутствия скриптов), что позволит первому участнику расшифровать и опубликовать две действительные подписи по схеме «2 из 2», а второму — узнать (в блокчейне) расшифрованную подпись и восстановить ключ расшифровки.

Как упоминалось выше, процесс возврата не должен быть интерактивным: протокол разработан таким образом, что Элис становится известна расшифрованная подпись возврата Боба, а сама она предоставляет Бобу действительную подпись, построенную по схеме мультиподписи «2 из 2», до блокировки средств. В случае возврата Боб сможет расшифровать и опубликовать подпись без участия Элис.

\subsection{Приватные ключи Monero}
Приватными ключами Monero являются две скалярные величины \texttt{edward25519}: первая — это приватный ключ просмотра, а вторая — приватный ключ траты. Для обозначения приватных ключей мы используем прописные буквы, а для обозначения публичных ключей — заглавные:
$$X = xG$$
где $G$ является генератором группы $\GG$. Мы обозначаем
\begin{enumerate}[label=(\roman*)]
    \item приватный ключ $k^v$ как полный приватный ключ просмотра;
    \item $K^v$ как полный публичный ключ просмотра;
    \item $k^v_a$ как часть приватного ключа просмотра, принадлежащую Элис, и $k^v_b$ как часть, принадлежащую Бобу;
    \item приватный ключ $k^s$ как полный приватный ключ траты;
    \item $K^s$ как полный публичный ключ траты;
    \item и $k^s_a$ как часть  приватного ключа траты, принадлежащую Элис, и $k^s_b$ как часть, принадлежащую Бобу.
\end{enumerate}

\subsubsection{Частичные ключи.}
Мы обозначаем части приватного ключа $k^s_a$ и $k^s_b$ как
$$k^s_a + k^s_b \equiv k^s \pmod l$$

А затем
\begin{equation}
\begin{split}
    k^s_aG &= K^s_a \\
    k^s_bG &= K^s_b \\
    K^s_a + K^s_b = (k^s_a + k^s_b)G = k^sG &= K^s
\end{split}
\end{equation}

То же касается  $k^v$ с $k^v_a$ и $k^v_b$.

\subsection{Доказательства с нулевым разглашением}
\label{eqDiscreteLog}
Доказательства с нулевым разглашением необходимы изначально, чтобы протокол не требовал доверия. Протокол использует одноразовую подпись VES, чтобы раскрыть части приватного ключа, но мы не можем проверить равенство дискретного логарифма для части публичного ключа Monero и публичного ключа расшифровки Bitcoin другого участника, пока он не попадёт в блокчейн. Следовательно, нам необходимо доказательство того, что дискретный логарифм одинаков для двух групп $\GG$ и $\HH$.

\subsubsection{Равенство дискретного логарифма в группах.}
Элис и Боб должны доказать друг другу, используя
\begin{equation}
\begin{split}
    k^s_i &\leftarrow \text{скалярные величины \texttt{edward25519} и \texttt{secp256k1} с эквивалентным двоичным представлением} \\
    K^s_i &= k^s_iG \in \GG \\
    B^s_i &= k^s_iH \in \HH \\
\end{split}
\end{equation}

для $i \in \{a, b\}$, при $K^s_i$ и $B^s_i$
\begin{equation}
\begin{split}
    \exists k^s_i \mid K^s_i = k^s_iG \land B^s_i = k^s_iH \land k^s_i < \textsf{min}(l,n)
\end{split}
\end{equation}

\subsection{Временные параметры}
На этапе инициализации задаются две временные блокировки: $t_0, t_1$. $t_0$ определяет временное окно, в рамках которого может быть совершён безопасный обмен. По истечении $t_0$ может быть запущен процесс возврата, что сделает обмен небезопасным, поскольку создаётся условие для конкуренции (несмотря на то, что это довольно сложно реализовать в реальности). $t_1$ определяет время ответа, в течение которого Боб должен отреагировать, раскрыть свою часть приватного ключа Monero и получить свой Bitcoin обратно, что также позволит Элис вернуть её Monero (если Monero были заблокированы). По истечении $t_1$ Элис сможет забрать Bitcoin в одностороннем порядке.

\subsection{Скрипты Bitcoin}
Со стороны Bitcoin необходимо два скрипта: первый используется для завершения свопа или запуска процесса возврата (известен как \texttt{SWAPLOCK}), второй — для завершения процесса возврата (известен как \texttt{REFUND}). При успешном проведении свопа второй скрипт не передаётся в блокчейн и не используется. Каждый скрипт определяет два возможных пути, и мы последовательно разъясним все четыре возможных пути (\textit{покупка}, \textit{возврат}, \textit{трата} и \textit{получение}) траты двух \texttt{UTXOs}.

\subsubsection{\texttt{SWAPLOCK}}
является скриптом, используемым для блокировки средств, и определяет два базовых пути выполнения: (1) выполнение свопа (успешный путь) и (2) возврат (неуспешный путь). Мы определяем скрипт \texttt{SWAPLOCK} следующим образом:

\begin{minted}[escapeinside=||,mathescape=true]{text}
OP_IF
    OP_SHA256 <|$h_s$|> OP_EQUALVERIFY
    2 <|$B_a$|> <|$B_b$|> 2 OP_CHECKMULTISIG
OP_ELSE
    <|$t_0$|> OP_CHECKSEQUENCEVERIFY OP_DROP
    2 <|$B^r_a$|> <|$B^r_b$|> 2 OP_CHECKMULTISIG
OP_ENDIF
\end{minted}

\subsubsection{\texttt{SWAPLOCK} покупки.}
Элис получает контроль над Bitcoin и раскрывает свою долю ключа Monero Бобу, используя $\sigma_1$ (одноразовую подпись VES, раскрывающую $k^s_a$), что даёт Бобу контроль над Monero. $\BTX_\textit{buy}$ выполняет \texttt{SWAPLOCK} при помощи:

\begin{minted}[escapeinside=||,mathescape=true]{text}
OP_0 <|$\sigma_1$|> <|$\sigma_2$|> <|$s$|> OP_TRUE <|\texttt{SWAPLOCK} script|>
\end{minted}

\subsubsection{\texttt{SWAPLOCK} возврата.}
SWAPLOCK, подписанный обоими участниками, возвращается, и средства перемещаются в скрипт \texttt{REFUND}. $\BTX_\textit{refund}$ выполняет \texttt{SWAPLOCK} при помощи:

\begin{minted}[escapeinside=||,mathescape=true]{text}
OP_0 <|$\sigma_r'$|> <|$\sigma_r''$|> OP_FALSE <|\texttt{SWAPLOCK} script|>
\end{minted}

\subsubsection{\texttt{REFUND.}}
\texttt{REFUND} является скриптом, используемым в том случае, если своп уже происходит в блокчейне, но прерывается. Данный скрипт возврата используется для перемещения средств из скрипта \texttt{SWAPLOCK} при помощи мультиподписи, построенной по схеме «2 из 2», с временной блокировкой. Мы определяем скрипт \texttt{REFUND} следующим образом:

\begin{minted}[escapeinside=||,mathescape=true]{text}
OP_IF
    2 <|$B^r_a$|> <|$B^r_b$|> 2 OP_CHECKMULTISIG
OP_ELSE
    <|$t_1$|> OP_CHECKSEQUENCEVERIFY OP_DROP
    <|$B_a$|> OP_CHECKSIG
OP_ENDIF
\end{minted}

\subsubsection{\texttt{REFUND} траты.}
Боб прерывает своп и раскрывает свою часть приватного ключа Monero, используя $\sigma_1'$ (одноразовую подпись VES, раскрывающую $k^s_b$), что возвращает Элис контроль над её Monero. $\BTX_\textit{spend}$ выполняет \texttt{REFUND} следующим образом:

\begin{minted}[escapeinside=||,mathescape=true]{text}
OP_0 <|$\sigma_1'$|> <|$\sigma_2'$|> OP_TRUE <|\texttt{REFUND} script|>
\end{minted}

\subsubsection{\texttt{REFUND} получения.}
Элис получает контроль над Bitcoin по истечении обеих временных блокировок, не раскрывая своей части приватного ключа Monero. В результате Боб теряет деньги, так как не следует протоколу. $\BTX_\textit{claim}$ выполняет \texttt{REFUND} следующим образом:

\begin{minted}[escapeinside=||,mathescape=true]{text}
<|$sig_a$|> OP_FALSE <|\texttt{REFUND} script|>
\end{minted}

\subsection{Транзакции}
Ниже мы описываем и называем транзакции Bitcoin и Monero, необходимые для выполнения всего протокола.

\subsubsection{$\BTX_\textit{lock}$,}
транзакция Bitcoin, содержащая $\geq 1$ входов от Боба и первый выход (vout: 0) для скрипта \texttt{SWAPLOCK} и возможных выходов сдачи.

\subsubsection{$\BTX_\textit{buy}$,}
транзакция Bitcoin, содержащая 1 вход и использующая скрипт \texttt{SWAPLOCK} ($\BTX_\textit{lock}$, vout: 0) с мультиподписью, построенной по схеме «2 из 2», в соответствии с протоколом частичного отсутствия скриптов и $\geq 1$ выходов.

\subsubsection{$\BTX_\textit{refund}$,}
транзакция Bitcoin, содержащая 1 вход и использующая скрипт \texttt{SWAPLOCK} script ($\BTX_\textit{lock}$, vout: 0) с мультиподписью, построенной по схеме «2 из 2», с временной блокировкой и ровно одним выходом для скрипта \texttt{REFUND}.

\subsubsection{$\BTX_\textit{spend}$,}
транзакция Bitcoin, содержащая 1 вход и использующая скрипт \texttt{REFUND} ($\BTX_\textit{refund}$, vout: 0) с мультиподписью, построенной по схеме «2 из 2», в соответствии с протоколом частичного отсутствия скриптов и $\geq 1$ выходов.

\subsubsection{$\BTX_\textit{claim}$,}
транзакция Bitcoin, содержащая 1 вход и использующая скрипт \texttt{REFUND} ($\BTX_\textit{refund}$, vout: 0) с подписью Элис и $\geq 1$ выходов.

\subsubsection{$\XTX_\textit{lock}$,}
транзакция Monero, в которой средства переводятся на определённый адрес $(K^v,K^s)$.

\subsubsection{$\XTX_\textit{buy}$,}
транзакция Monero, в которой тратятся средства, находящиеся по адресу $(K^v,K^s)$.

\subsection{Полная последовательность выполнения протокола}
Ниже мы описываем полную последовательность выполнения протокола, позволяющую успешно завершить своп с вычислением и взаимным использованием всей необходимой информации в случае, если в какой-то момент один из участников перестанет отвечать или же  запустит процесс возврата.

Во время первого раунда обмена данными, поскольку обе стороны используют общие параметры, необходимые для запуска протокола, благодаря применению равного дискретного логарифма в доказательстве знания с нулевым разглашением мы сможем избежать таких схем, как схема обязательства с раскрытием, даже с $K^s = K^s_a + K^s_b$. Никто не сможет произвольным образом выбрать $K^s$ и вычислить действительное доказательство $z_i$. Тем не менее, чтобы при каждом выполнении гарантировано выбирался случайный ключ просмотра, необходимо добавление схемы обязательства с раскрытием по $k^v_i$. Таким образом, не добавляя ещё один раунд обмена данными, мы также можем добавить схему обязательства с раскрытием по $k^s_i$.

Мы определяем некоторые вспомогательные алгоритмы, позволяющие инициализировать, подписать и верифицировать транзакции Bitcoin и Monero.

\begin{itemize}
    \item $\InitTx()$: Общий и детерминированный алгоритм, который (при наличии ряда вводных параметров) создаёт действительную инициализированную транзакцию.
    \item $\Sign()$: Общий и вероятностный алгоритм для подписания транзакции, который (при наличии приватного ключа и инициализированной транзакции) выдаёт действительную подпись транзакции.
    \item $\VrfyTx()$: Общий и детерминированный алгоритм, который (при наличии ряда транзакций и параметров) выдаёт 1, если и только если транзакции являются действительными в соответствии с правилами протокола и алгоритмом консенсуса блокчейна.
    \item $\Verify()$: Общий и детерминированный алгоритм, который (при наличии публичного ключа, транзакций и подписи) выдаёт 1, если и только если подпись является действительной транзакций, соответствующей публичному ключу.
    \item $\PubTx()$: Общий алгоритм для публикации транзакций в сети.
    \item $\WatchTx()$: Общий алгоритм ожидания подтверждения транзакций.
    \item $\RecSig()$: Общий алгоритм выделения подписей транзакций.
\end{itemize}

\newpage

\begin{figure}[H]
    \begin{table}[H]
        \centering
      {\renewcommand{\arraystretch}{1.1}%
      \begin{tabular}{ | l c l | }
        \hline
          \multicolumn{1}{|c}{Элис (XMR$\rightarrow$BTC)} &  & \multicolumn{1}{c|}{Боб (BTC$\rightarrow$XMR)} \\
          $k^v_a, k^s_a \xleftarrow{R} [1, l-1]$ & & $k^v_b, k^s_b \xleftarrow{R} [1, l-1]$ \\
          %$K^s_a \leftarrow k^s_aG$ & & $K^s_b \leftarrow k^s_bG$ \\
          %$B^s_a \leftarrow k^s_aH$ & & $B^s_b \leftarrow k^s_bH$ \\
          $b_a,b^r_a \xleftarrow{R} [1, n-1]$ & & $b_b,b^r_b \xleftarrow{R} [1, n-1]$ \\
          $B_a \leftarrow b_aH$ & & $B_b \leftarrow b_bH$ \\
          $B^r_a \leftarrow b^r_aH$ & & $B^r_b \leftarrow b^r_bH$ \\
          $(z_a, K^s_a, B^s_a) \leftarrow \DLProve(k^s_a)$ & & $(z_b, K^s_b, B^s_b) \leftarrow \DLProve(k^s_b)$ \\
          & & $s \xleftarrow{R} [0, 2^{256}]$ \\
          & & $h_s \gets \texttt{SHA256}(s)$ \\
           & & \\

          \multicolumn{3}{|c|}{$\xlongleftrightarrow{\langle k^v_i, K^s_i, B_i, B^s_i, B^r_i, z_i, h_s \rangle \  \forall i \in \{a, b\}}$} \\

          & $k^v \equiv k^v_a + k^v_b \pmod l$ & \\
          & $K^v = k^vG$, \ $K^s = K^s_a + K^s_b$ & \\

          \DLVrfy$(K^s_b, B^s_b, z_b) \stackrel{?}{=} 1$ & & \DLVrfy$(K^s_a, B^s_a, z_a) \stackrel{?}{=} 1$ \\
          & & $(\BTX_\textit{lock}$, $\BTX_\textit{refund}) \gets$ \InitTx$(B_a, B_b, B^r_a, B^r_b)$ \\
          & & $\sigma_r' \gets$ \Sign$(b^r_b, \BTX_\textit{refund})$ \\

          \multicolumn{3}{|c|}{$\xleftarrow{\langle \BTX_\textit{lock}, \BTX_\textit{refund}, \BTX_\textit{spend}, \sigma_r' \rangle}$} \\

          \VrfyTx$(\BTX_\textit{lock}$, $\BTX_\textit{refund}, B_a, B_b, B^r_a, B^r_b, h_s) \stackrel{?}{=} 1$ & & \\
          \Verify$(B^r_b, \BTX_\textit{refund}, \sigma_r') \stackrel{?}{=} 1$ & & \\
          $\hatsigma_1' \gets \EncSign(b^r_a, B^s_b, \BTX_\textit{spend})$ & & \\
          $\delta' \gets \RecKey(B^s_b, \hatsigma_1')$ & & \\
          $\sigma_r'' \gets$ \Sign$(b^r_a, \BTX_\textit{refund})$ & & \\

          \multicolumn{3}{|c|}{$\xrightarrow{\langle \sigma_r'', \hatsigma_1' \rangle}$} \\

          & & $\EncVer(B^r_a, B^s_b, \BTX_\textit{spend}, \hatsigma_1') \stackrel{?}{=} 1$ \\
          & & \Verify$(B^r_a, \BTX_\textit{refund}, \sigma_r'') \stackrel{?}{=} 1$ \\
          %& & \Verify$(B^r_a, \BTX_\textit{spend}, \sigma_2') \stackrel{?}{=} 1$ \\
          & & $\BTX_\textit{buy} \gets$ \InitTx$(\BTX_\textit{lock})$ \\
          & & $\hatsigma_1 \gets \EncSign(b_b, B^s_a, \BTX_\textit{buy})$ \\
          & & $\delta \gets \RecKey(B^s_a, \hatsigma_1)$ \\
          & & \PubTx$(\BTX_\textit{lock})$ \\

          \multicolumn{3}{|c|}{$\xleftarrow{\langle \BTX_\textit{buy}, \hatsigma_1 \rangle}$} \\

          $\EncVer(B_b, B^s_a, \BTX_\textit{buy}, \hatsigma_1) \stackrel{?}{=} 1$ & & \\
          \WatchTx$(\BTX_\textit{lock}) \stackrel{?}{=} 1$ & & \\
          \multicolumn{3}{|c|}{$\dots$} \\

          $\XTX_\textit{lock} \gets$ \InitTx$(K^v, K^s)$ & & \\
          \PubTx$(\XTX_\textit{lock})$ & & \\

          \multicolumn{3}{|c|}{$\dots$} \\
          & & \WatchTx$(K^v, K^s)$ w/ $(k^v, K^s) \stackrel{?}{=} 1$ \\

          \multicolumn{3}{|c|}{$\xleftarrow{\langle s \rangle}$} \\

          $\sigma_1 \gets \DecSig(k^s_a, \hatsigma_1)$ & & \\
          $\sigma_2 \gets \Sign(b_a, \BTX_\textit{buy})$ & & \\
          $\sigma := (\sigma_1, \sigma_2)$ & & \\
          \PubTx$(\BTX_\textit{buy}, \sigma, s)$ & & \\

          & & \WatchTx$(\BTX_\textit{buy}) \stackrel{?}{=} 1$ \\
          \multicolumn{3}{|c|}{$\dots$} \\

          & & $(\sigma_1, \sigma_2) \gets \RecSig(\BTX_\textit{buy})$ \\
          & & $k^s_a \gets \Rec(\sigma_1, \delta)$ \\
          & & $k^s \equiv k^s_a + k^s_b \pmod l$ \\
          & & $\langle k^v, k^s \rangle$ \\
        \hline
      \end{tabular}}
    \end{table}
  \caption{Выполнение протокола при успешном выполнении свопа между Бобом и Элис}
  \label{fig:protocol}
\end{figure}

Точками показано время синхронизации, за которое один или несколько участников должны дождаться подтверждения транзакций перед тем, как продолжится выполнение протокола. Уровень безопасности (то есть количество подтверждений, необходимое каждому участнику) является локальным параметром, но должен устанавливаться в соответствии с параметрами синхронизации (которые являются глобальными для обоих участников) во избежание ситуации, когда время синхронизации будет меньшим или равным параметру безопасности.

\section{Дальнейшие исследования}
Настоящий протокол может быть реализован с существующими версиями Bitcoin и Monero, но для использования возможностей алгоритма \texttt{Schnorr} и упрощения в целях выработки более эффективных вариантов протокола с меньшей опорой на блокчейн требуются дополнительные исследования. Это позволит повысить анонимность атомных свопов в плане анализа блокчейна.

Как уже говорилось, данный протокол может быть адаптирован для применения с другими криптовалютами. Некоторые из них, возможно, пока не предполагают возможности проведения атомных свопов, и расширение протокола для других пар может способствовать децентрализации. Такое расширение только для криптовалют, ориентированных на обеспечение анонимности (таких как Monero с  Mimblewimble), является следующей задачей с точки зрения развития атомных свопов.

Интеграция протокола в сервисы или децентрализованные биржи будет также способствовать демократизации торговли за счёт отсутствия необходимости в привлечении доверенных сторон и может повысить ликвидность рынка. Так как предлагаемое решение является асимметричным, построение соответствующих сервисов будет не простым.

\subsection{Известные ограничения}
Чтобы доказать жизнеспособность (если по крайней мере один участник по-прежнему находится онлайн), мы рассматриваем наихудший сценарий, при котором участник может потерять средства (будучи неспособным забрать средства из другого блокчейна). Это может произойти в случае, если участники не будут следовать протоколу, например, оставаться онлайн во время ожидания завершения свопа или при своевременном получении средств. Обоснование решения приводится в подпункте \ref{worstCaseRationale}.

Комиссии в разных блокчейнах будут отличаться из-за внутренних параметров этих блокчейнов и сложности проводимых транзакций, а также из-за внешних факторов, таких как требование к занимаемому блоками месту. Следует отметить, что в рамках настоящего протокола блокчейн Bitcoin используется как механизм принятия решений, когда мы используем возможности скриптов (несмотря на то что мы пытаемся реализовать максимум логических решений вне блокчейна), что является причиной увеличения размера транзакций со стороны Bitcoin. В совокупности эти два фактора делают транзакции Bitcoin в целом более затратными, чем транзакции в блокчейне Monero.

Трудно достичь немедленной реакции пользователей при совершении атомных свопов между блокчейнами. Низкая скорость работы блокчейна и количество подтверждений, необходимых для завершения транзакций, определяют скорость выполнения протокола, в некоторых случаях приводя к опережению. Тем не менее во избежание подобных ситуаций протокол также может быть расширен определённым образом. Стоит отметить, что один участник не может вызвать опережения выполнения другим участником, что делает возможным наихудший сценарий с потерей комиссий за проведение транзакций в соответствующих блокчейнах участников.

\section{Благодарность}
Мы выражаем благодарность Исследовательской лаборатории Monero и Сарангу Ноезеру за их полезные комментарии, внесённые при окончательной редакции данной работы. Эти исследования поддерживались и частично финансировались Сообществом Monero, и мы отдельно благодарим тех, кто вносил свои пожертвования. Наконец мы благодарим сотрудников TrueLevel SA за начальное финансирование, их вклад и комментарии.

%
% ---- Bibliography ----
%
\printbibliography

\end{document}
