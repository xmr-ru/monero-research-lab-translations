\documentclass{llncs}
\pagestyle{headings}

\usepackage{enumerate}
\usepackage{amsmath,amssymb}
\usepackage[utf8]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english,russian]{babel}
\renewcommand\definitionname{Определение}
\renewcommand\remarkname{Примечание}
\renewcommand\theoremname{Теорема}
\renewcommand\lemmaname{Лемма}
\renewcommand\corollaryname{Следствие}

\newcommand{\A}{\texttt{A}}
\newcommand{\B}{\texttt{B}}
\newcommand{\F}{\texttt{F}_p}
\newcommand{\G}{\texttt{G}}
\newcommand{\Hp}{\mathcal{H}^p}
\newcommand{\Hs}{\mathcal{H}^s}
\newcommand{\prob}{\mathbb{P}}

\title{Краткие связываемые кольцевые подписи и фальсификация по ключам злоумышленника}
\institute{Исследовательская лаборатория Monero (Monero Research Lab), \email{\{surae,sarang\}@getmonero.org} \and Независимый исследователь, \email{randomrun@protonmail.com}}
\author{Брэндон Гуделл (Brandon Goodell)\inst{1}, Саранг Ноезер (Sarang Noether)\inst{1} и Артур Блю (Arthur Blue)\inst{2}}

\begin{document}
\maketitle

\begin{abstract}
Мы демонстрируем, что наша версия защиты от оговора (выдача себя за другого пользователя) является естественным определением невозможности подделки связываемых кольцевых подписей. Нами предлагается схема построения связываемой кольцевой подписи с использованием кратких подписей и многомерных ключей, являющуюся связно анонимной при наличии сложного варианта решения задачи Диффи-Хеллмана со случайными оракулами, связываемой, если агрегация ключей является односторонней функцией, а также защищающей от оговора, если ещё одна версия задачи дискретного логарифмирования также является сложной. Нами приводятся некоторые варианты применения схемы в моделях конфиденциальных транзакций, скрывающих подписанта и не требующих доверенных настроек.
\end{abstract}


\section{Введение}

Будучи впервые представленной в работе \cite{rivest} в настройках RSA и в работе \cite{liu2004linkable} в рамках дискретного логарифма, схема построения кольцевой подписи позволяет подписывать сообщения при помощи набора публичных ключей, а не одного единственного публичного ключа. Кольцевые подписи можно применять в самых различных целях, начиная с лёгкой анонимной аутентификации, описанной в работе \cite{yang2015lightweight}, и заканчивая протоколами проведения транзакций, такими как Monero \cite{noether2016ring} и CryptoNote \cite{van2013cryptonote}. Верификатор получает уверенность в том, что подписавшей стороне известен приватный ключ, по крайней мере, к одному из этих публичных ключей, которые называются участниками кольца. Кольцевые подписи являются анонимными или скрывают подписанта в том смысле, что верификатор не может узнать на основе подписи информацию о том, какой из ключей принадлежит подписанту. Мы подчёркиваем, что методы практического анализа, подобные методам, описанным в работах \cite{moser2018empirical,quesnelle2017linkability}, могут использовать метаданные при использовании протоколов анонимной аутентификации в реальных условиях для снижения уровня анонимности.

Схемы групповой подписи, предшествующие представленным в работах \cite{rivest,liu2004linkable}, требуют некоторой интерактивности, фиксированного набора участников, наличия доверенного администратора группы или других доверенных настроек, или применения допусков сложности, не основанных на решении задачи дискретного логарифмирования. После публикации работы \cite{rivest}, кольцевые подписи множество раз улучшались, становились предметом всевозможных расширений и модификаций. Например, кольцевые подписи, которые строятся на основе билинейного спаривания, описаны в работе \cite{zhang2002id}, структуры ключей обобщаются в работе \cite{abe20021}, определения безопасности были улучшены в работе \cite{bender2006ring}, возможность сокращения размера подписей была рассмотрена в работах \cite{fujisaki2011sub,gu2018constant}, а возможность отслеживания стала темой работы \cite{fujisaki2007traceable}.

Схемы связываемой кольцевой подписи (LRS) были впервые представлены в работе \cite{liu2004linkable}; в контексте протоколов проведения транзакций связываемые кольцевые подписи являются основой аутентификации анонимной транзакции. Связываемые кольцевые подписи гарантируют, что две подписи с одним и тем же кольцом в произвольных сообщениях могут быть публично связаны, если они были подписаны с использованием одного и того же ключа. В основе одного из вариантов реализации, предложенного в работе \cite{liu2004linkable}, лежит задача дискретного логарифмирования; данный вариант работает так же, как и подписи Шнорра, описанные в работе \cite{schnorr1991efficient}.

Связующие теги подписи, о которых говорится в работе \cite{liu2004linkable}, не подходят для применения в тех случаях, когда подписи должны быть связаны соответствующими ключами, а не кольцами (например, при использовании защиты от «двойного подписания», когда пользователи генерируют новые ключи с течением времени и выбирают \textit{подходящих} для этого участников кольца). Защита от двойного подписания обеспечивается с помощью связующих тегов, описанных в работе \cite{van2013cryptonote} (где авторы называют их образами ключей). В более поздней работе \cite{noether2016ring} подход, представленный в работе \cite{liu2004linkable}, расширяется до анонимной модели проведения конфиденциальных транзакций с особым \textit{подбором} участников кольца. В работе \cite{noether2016ring} суммы транзакций заменяются обязательствами Педерсена по суммам и доказательствами диапазона. Подписи строятся на основе векторов ключей, а также разницы обязательств по сумме, используемой в качестве одного из ключей. Тем не менее доказательства, описанные в работе \cite{noether2016ring}, являются неформальными и не базируются на строгих моделях безопасности.

Альтернативные кольцевым подписям решения, такие как более общие системы доказательства с нулевым разглашением, как правило, требуют наличия доверенной стороны, которая бы честно выполняла процесс настройки (как в работах \cite{groth,ben2014succinct,groth2018updatable}), или предполагают отсутствие практической эффективности при использовании больших схем (как в работе \cite{bulletproofs}), а это означает, что такие системы не подходят для применения в случае с распределённым реестром. Однако более поздние подходы, подобные описанному в работе \cite{hoffmann2019efficient}, демонстрируют улучшения как с точки зрения необходимости в доверии, так и в плане повышения эффективности.

Определения экзистенциальной невозможности подделки схем кольцевой подписи, приводимые в работе \cite{bender2006ring}, как правило, неприменимы к LRS. Эти определения гарантируют, что подделки можно будет вычислить на основе неповреждённых ключей запросов при ограничении выбора участников анонимной группы и запросов оракула. При наличии связываемости мы можем предложить лучший вариант.

Идея экзистенциальной невозможности подделки обычных цифровых подписей заключается в том, чтобы поставить перед алгоритмом такую задачу, чтобы он выводил любую действительную, не связанную с использованием оракулов подпись для любого сообщения, и чтобы она была подписана неповреждённым ключом запроса. В случае со схемами LRS аналогичным образом перед алгоритмом ставится задача, в результате выполнения которой мы бы получали любую действительную, не связанную с использованием оракула подпись для любого сообщения, и при этом связи подписи с подписью запроса должны вычисляться на основе неповреждённого ключа запроса. Сравните это с определением невозможности подделки обычных кольцевых подписей в плане внутреннего повреждения, о котором говорится в работе \cite{bender2006ring}, где действительная подпись $\sigma$ с анонимной группой $Q$ не считается поделкой, если какой-либо ключ в $Q$ повреждён или не является ключом запроса, или же подписывающий оракул был запрошен той же анонимной группой $Q$ и сообщением. В результате возникают две проблемы.

Первая проблема связана с признанием недействительной предполагаемой подделки, если в анонимной группе присутствуют какие-либо выбранные злоумышленником ключи или повреждённые ключи запроса. Такая подпись, связанная с неповреждённым ключом запроса, не считается подделкой. В схемах построения кольцевой подписи, не обладающих свойством связываемости, данное ограничение необходимо, чтобы подпись гарантировано была подписана неповреждённым ключом запроса. В случае применения, например, с протоколами транзакций с сокрытием подписанта, использующими \textit{специально выбираемые} анонимные группы, предполагается, что участники анонимной могут быть созданы злоумышленником. Это следует учитывать при формулировке определений невозможности подделки.

Вторая проблема связана с ограничением применения подписывающего оракула в рамках этого определения. Злоумышленник может сгенерировать действительную подпись, не связанную с использованием оракула, повторно используя те же сообщение и анонимную группу, что и некоторая подпись запроса, сгенерированная оракулом. Верификатор, обнаруживший более одной действительной подписи, не связанной с использованием оракула, в одном и том же сообщении с одной и той же анонимной группой, согласно этому определению, может только прийти к выводу, что, по крайней мере, один из членов анонимной группы поставил хотя бы одну из подписей. Это позволяет очевидному злоумышленнику собрать исходящие честные подписи из некоторых честных сообщений и попытаться создать клоны таких честных сообщений. Отправитель, который затем попытается заявить о том, что является автором подписи, может оказаться в опасности, так как не сможет восстановить подпись, отправленную какому-либо получателю.

Эти проблемы противоречат духу концепции экзистенциальной невозможности подделки с возможностью внутреннего повреждения, описанной в работе \cite{bender2006ring}: подпись является действительной, не создаётся оракулом, вычисляется на основе неповреждённого ключа запроса и всё же не считается подделкой.


\subsection{Наш вклад}

Мы смягчаем понятие успешной подделки, подразумевая, что для этого требуется только определение связи с неповреждёнными ключами запроса, и получаем таким образом понятие невозможности подделки связываемых кольцевых подписей, которое эквивалентно определению защиты от оговора, представленному в работе \cite{au2006short}. Защита от оговора допускает возможность наличия злоумышленников, способных сделать запрос подписывающего оракула с любой анонимной группой, и даже выбираемой такими злоумышленниками анонимной группой. Это позволяет смоделировать чрезвычайно убедительного злоумышленника, который сможет сделать так, что пользователи будут подписывать сообщения с помощью выбранных им анонимных групп. Мы демонстрируем, что защита от оговора предполагает невозможность подделки в плане внутреннего повреждения, о котором говорится в работе \cite{bender2006ring}.

Нами также предлагается схема связываемой кольцевой подписи, подобная схеме подписи Шнорра, которую мы называем $d$-CLSAG и которая использует методы агрегирования ключей с целью увеличения размера подписи. Мы описываем способ применения схемы $d$-CLSAG в рамках протоколов кольцевых конфиденциальных транзакций, позволяющий создавать транзакции, состоящие из одновременно $d-1$ различных объектов. Мы доказываем, что $d$-CLSAG является связываемой, что предполагает отсутствие конфликтов при агрегации ключей и связываемую анонимность при условии сложности решения алгоритма Диффи-Хеллмана. Напомним, что схемы подписи, подобные схеме Шнорра, не сводятся чисто к допуску дискретного логарифмирования (\textit{см. работу}\ \cite{paillier2005discrete}) и, как правило, безопасны только при наличии (относительно ненадёжных) дополнительных допусков сложности решения, а методы доказательства, как правило, используют программируемые случайные оракулы и леммы разветвления, что приводит к ослаблению связей. Нами используется общая лемма разветвления, позволяющая доказать, что $d$-CLSAG обеспечивает защиту от оговора при условии наличия $\kappa$-дополнительного варианта решения задачи дискретного логарифмирования, что само по себе является сложным.


\section{Предварительные условия}

Допустим, $\lambda$ является параметром безопасности, а $1 \leq q, \eta, \kappa \in poly(\lambda)$. Допустим, $\G = \langle G \rangle$ обозначает группу над полем $\F$ для некоторых главных $p$, с генератором $G$. Допустим, $\Hs:\left\{0,1\right\}^* \to \F$ и $\Hp:\left\{0,1\right\}^* \to \G$ являются двумя независимыми криптографическими хеш-функциями, смоделированными в качестве случайных оракулов.

Если существует функция $f$, являющаяся незначительной по некоторому параметру $\lambda$, и существуют такие зависимые от $\lambda$ события $A, B$, что $\left|\prob\left[A\right] - \prob\left[B\right]\right| \leq f(\lambda)$, мы обозначаем это как $\prob\left[A\right] \approx \prob\left[B\right]$. Событие $A$ является таким, что $\prob\left[A\right] \approx 0$ считается незначительным в $\lambda$ (или может произойти с минимальной вероятностью в $\lambda$). Дополнение события $A$ обозначается как $\overline{A}$. Для поля $\F$ обозначим ненулевые элементы $\F^* := \F\setminus \left\{0\right\}$. Для конечного множества $S$ определяем $S^*$, интерпретируя $S$ как список символов, образующих свободный моноид $S^*$. Например, $\left\{0,1\right\}^*$ состоит из строк битов конечной длины.

Для набора $S$ определяем $\mathcal{P}(S)$ как степенное множество $S$, то есть, множество всех подмножеств $S$.

Обозначаем векторы жирным шрифтом, то есть для последовательности $x_i \in \F$ при $i = 0, \ldots, n-1$ обозначаем кортеж $(x_0, \ldots, x_{n-1})$ как $\textbf{x}$. Обозначаем произведение Адамара между векторами как $\textbf{x} \circ \textbf{y} = (x_i y_i)_i$. Во избежание какой-либо двусмысленности начинаем все индексы с $0$. Мы используем обозначение $[n]$ для набора $\{0,\ldots,n-1\}$.


\section{Определения}

\subsection{Допуски сложности решения}\label{sec:hardness}

Начнём с того, что если $\left\{\mu_i: \F^d \to \F\right\}_{i=0}^{d-1}$ являются функциями, выбираемыми равномерно и случайным образом, то сложная функция $\mu: \F^d \to \F$, определяемая равномерным распределением $\textbf{x} \mapsto \sum_i \mu_i(\textbf{x}) x_i$, имеет равномерно распределяемый выход и устойчива к возникновению конфликтов и использованию предварительно созданных образов. Мы используем это свойство далее при рассмотрении возможности обеспечения связываемости и связываемой анонимности.

Следующее решение задачи эквивалентно\footnote{Обычный алгоритм решения $\kappa$-дополнительной задачи дискретного логарифмирования может преуспеть в решении задачи в соответствии с Определением \ref{def:komdl} с той же вероятностью и в течение некоторого дополнительного времени путём простого суммирования решений. Алгоритм, решающий задачу в соответствии с Определением \ref{def:komdl}, может использовать знание дискретного логарифма, чтобы найти другой неповреждённый ключ запроса с той же вероятностью и в течение некоторого дополнительного времени.} обычному решению $\kappa$-допол- \linebreak нительной задачи дискретного логарифмирования согласно модели случайного оракула.

\begin{definition}[Решение $\kappa$-дополнительной задачи дискретного логарифмирования в линейных комбинациях]\label{def:komdl}

Допустим, $\kappa \geq 1$. Мы утверждаем, что любой PPT-алгоритм $\A$, который может успешно решить следующую задачу самое большее за время $t$ и с вероятностью такого успешного решения по крайней мере $\epsilon$, является $(t, \epsilon, q)$-алгоритмом решения $\kappa$-дополнительной задачи дискретного логарифмирования в линейных комбинациях в $\G$ (где $k < q$).
\begin{enumerate}
\item Запросчик случайным образом выбирает $\left\{sk_i\right\}_{i=0}^{q-1} \subseteq \F$, вычисляет $pk_i := sk_i \cdot G$ и отправляет $S := \left\{pk_i\right\}_{i=0}^{q-1}$ $\A$.

\item $\A$ получает доступ к повреждённому оракулу $\texttt{CO}$, который берёт в качестве входа публичный ключ $pk_i \in S$, а в качестве выхода выдаёт соответствующий приватный ключ $sk_i$. Повреждённые ключи записываются в таблицу $C$.

\item $\A$ выдаёт некоторое $w \in \F^*$, последовательность элементов поля \linebreak $\left\{h_j\right\}_{j=0}^{\kappa} \subseteq \F \setminus \left\{0\right\}$ и подмножество ключей запроса $\left\{pk^*_j\right\}_{j=0}^{\kappa} \subseteq \left\{pk_i\right\}_{i=0}^{q-1}$, успешно решая таким образом задачу, если и только если $w \cdot G = \sum_{j=0}^{\kappa} h_j \cdot pk^*_j$ и $\A$ запросили $\texttt{CO}$ не более $\kappa$ раз.

\end{enumerate}
Мы утверждаем, что задача дискретного логарифмирования в линейных комбинациях сложна для решения в $\G$, если какой-либо $(t, \epsilon, q)$-алгоритм решения этой задачи имеет преимущество, которое является $\epsilon$ незначительным в $q$.
\end{definition}

В случае с алгоритмом $\A$, который в качестве входа берёт случайный ряд $\rho$, последовательность запросов случайного оракула $\textbf{h}$ и некоторый вход $inp$ и выдаёт $(out, idx) \leftarrow \A(\rho, \textbf{h}, inp)$ в качестве выхода, общий алгоритм разветвления работает следующим образом.

\begin{enumerate}[(1)]
\item  Выбираем случайный ряд $\rho$ для $\A$ и две последовательности запросов случайного оракула $\textbf{h} = \left\{h_0, h_1, \ldots\right\}$ и $\textbf{h}^\prime = \left\{h_0^\prime, h_1^\prime, \ldots\right\}$.

\item Выполняем $(out, idx) \leftarrow \A(\rho, \textbf{h}, inp)$.

\item Задаём значение $j := idx$ и связываем запросы оракула $\textbf{h}$, $\textbf{h}^\prime$ вместе \[\textbf{h}^* = \left\{h_0, h_1, \ldots, h_{idx - 1}, h_{idx}^\prime, h_{idx+1}^\prime, \ldots, \right\}.\]

\item Выполняем $(out^*, idx^*) \leftarrow \A(\rho, \textbf{h}^*, inp)$.

\item Если $idx \neq idx^*$ или же $h_{idx} = h_{idx}^\prime$, выводится $\bot$ и происходит завершение процесса. В ином случае выводится $(out, out^\prime, idx)$.
\end{enumerate}

Данный алгоритм является алгоритмом $\mathcal{F}^{\A}$, используемым в следующей лемме.

\begin{lemma}[Общая лемма разветвления]\label{lem:fork}
Допустим, $1 \leq \eta \in \text{poly}(\lambda)$. Допустим, $\A$ является любым PPT-алгоритмом, который берёт в качестве входа некоторый кортеж $x_\A = (x, \textbf{h})$, где $\textbf{h} = (h_0, h_1, \ldots, h_{q-1})$ является последовательностью ответов на запросы оракула (строками из $\eta$-бит), и выдаёт в качестве выхода $y_{\A}$ либо выделенный символ сбоя $\bot$, либо пару $(\textit{idx}, y)$, где $\text{idx} \in [q]^2$ и $y$ являются каким-то выходом. Допустим, $\epsilon_{\A}$ обозначает вероятность того, что $\A$ не выдаёт $\bot_{\A}$ (при этом такая вероятность относится ко всем случайным монетам $\A$, распределению $x$, и всем вариантам $\textbf{h}$). Допустим, $\mathcal{F} = \mathcal{F}^{\A}$ является алгоритмом разветвления для $\A$. Допустимая вероятность приемлемости $\mathcal{F}$ соответствует $\epsilon_{\mathcal{F}} \geq \epsilon_{\A} \left(\frac{\epsilon_{\A}}{q} - \frac{1}{2^\eta}\right)$.
\end{lemma}

Мы используем вариант решения задачи, чтобы связать классический допуск сложности решения Диффи-Хеллмана со схемой использования случайного оракула, которая пригодится далее при введении определения связываемой анонимности. Свойства конструкции такого типа, связанные с псевдослучайностью и обратимостью, более подробно рассматриваются в работе \cite{omniring}.

\begin{definition}[Решение задачи Диффи-Хеллмана с использованием случайного оракула]\label{def:rom-ddh}
Мы утверждаем, что любой PPT-алгоритм $\A$, который может успешно решить следующую задачу самое большее за время $t$ и с вероятностью такого успешного решения, по крайней мере, $\epsilon > 0$, является $(t,\epsilon,q)$-алгоритмом решения задачи Диффи-Хеллмана с использованием случайного оракула.
\begin{itemize}
\item Запросчик случайным образом выбирает $b \in \{0,1\}$.
\item Если $b = 0$, запросчик случайным образом и единообразно выбирает $\{r_i\}_{i=0}^{q-1}$ из $\F$ и задаёт $$S := \{(R_i,R_i',R_i'')\}_{i=0}^{q-1} = \{(r_iG,\Hp(r_iG),r_i\Hp(r_iG))\}_{i=0}^{q-1},$$ и  отправляет $S$ алгоритму $\A$.
\item Если же $b = 1$, запросчик случайным образом и единообразно выбирает $\{(r_i,r_i'')\}_{i=0}^{q-1}$ из $\F^2$ и задаёт $$S := \{(R_i,R_i',R_i'')\}_{i=0}^{q-1} = \{(r_iG,\Hp(r_iG),r_i''G)\}_{i=0}^{q-1},$$ и отправляет $S$ алгоритму $\A$.
\item $\A$ предоставляется доступ к случайному оракулу $\Hp$.
\item $\A$ выдаёт бит $b' \in \{0,1\}$; считается, что $\A$ успешно решает задачу, если и только если $b' = b$.
\end{itemize}
Мы утверждаем, что нахождение групповых элементов в соответствии с алгоритмом Диффи-Хеллмана с использованием случайного оракула является сложным в $\G$, если какой-либо $(t,\epsilon,q)$-алгоритм решения имеет преимущество $\epsilon$.
\end{definition}

\begin{remark}
Мы допускаем, что если решение классической задачи в соответствии с алгоритмом Диффи-Хеллмана (DDH) в $\G$ является сложным, то и решение задачи RO-DDH тоже. Следует помнить о том, что DDH просит злоумышленника отличить распределения кортежей в форме $(rG,r'G,rr'G)$ и $(rG,r'G,r''G)$. Если решение DDH представляется сложным в $\G$, то распределение кортежей в таких формах отличить невозможно. Поскольку $\Hp$ является случайным оракулом, выход которого не зависит от входа, распределение кортежей в форме $(rG,\Hp(rG),r''G)$ и $(rG,r'G,r''G)$ будет идентичным. Подобным образом, и распределение кортежей в форме $(rG,\Hp(rG),r\Hp(rG))$ и $(rG,\Hp(rG),r''G)$ так же будет идентичным. Наконец, случайное свойство самовосстановления классического алгоритма DDH означает, что решение одной версии задачи будет не менее сложным, чем решение последовательности случайных версий задачи.
\end{remark}


\subsection{Связываемые кольцевые подписи}

\begin{definition}\label{def:lrs} Схема связываемой кольцевой подписи (LRS) $\Pi_{LRS}$ представляет собой набор алгоритмов $(\texttt{SETUP}, \texttt{KEYGEN}, \texttt{SIGN}, \texttt{VERIFY}, \texttt{LINK})$, соответствующих следующим ограничениям:
\begin{itemize}
\item $\texttt{SETUP}$ берёт в качестве входа параметр безопасности $\lambda$ и выдаёт некоторые общедоступные параметры настройки $\rho$ в качестве выхода.

\item $\texttt{KEYGEN}$ является случайным алгоритмом и берёт в качестве входа $(\lambda, \rho)$, и выдаёт пару, состоящую из приватного и публичного ключа $(sk, pk)$.

\item $\texttt{SIGN}$ является случайным алгоритмом и берёт в качестве входа $(\lambda, \rho)$ и три значения $(m, Q, sk)$, и выдаёт подпись $\sigma$ или символ сбоя $\bot$. Здесь $m$ обозначает сообщение, $Q$ - анонимный набор публичных ключей $Q = \left\{pk_0, pk_1, ..., pk_{n-1}\right\}$, а $sk$ обозначает приватный ключ.

\item $\texttt{VERIFY}$ берёт в качестве входа $(\lambda, \rho)$ и тройное значение $(m, Q, \sigma)$ и выдаёт бит $b$. Здесь $m$ обозначает сообщение, $Q$ — анонимный набор публичных ключей $Q = \left\{pk_0, pk_1, ..., pk_{n-1}\right\}$, а $\sigma$ является подписью.

\item $\texttt{LINK}$ берёт в качестве входа $(\lambda, \rho)$, пару тройных значений $(m, Q, \sigma)$, $(m^*, Q^*, \sigma^*)$ и выдаёт бит $b$. В данном случае $m, m^*$ обозначают сообщения, $Q, Q^*$ — анонимные наборы публичных ключей, $\sigma, \sigma^*$ являются подписями.
\end{itemize}
Мы называем тройку значений в форме $(m, Q, \sigma)$ (то есть тройного значения, подходящего для использования в качестве входа для $\texttt{VERIFY}$ и $\texttt{LINK}$) \textit{тройным значением подписи}. Мы говорим, что $\Pi_{LRS}$ является $d$-LRS, если размер приватного и публичного ключей составляет $d \geq 1$, а анонимные группы можно описать как матрицы $d\times n$.
\end{definition}

В целях дальнейшей конкретизации, мы допускаем, что $\rho$ включает (неявно или явно) описания пространства приватных ключей $\mathcal{SK}$, пространства публичных ключей $\mathcal{PK}$, пространства подписи $\mathcal{SIG}$, преобразования $\phi: \mathcal{SK} \to \mathcal{PK}$ и семейства хеш-функций (смоделированных в качестве случайных оракулов) $\mathcal{H}$, из которых мы можем построить $\Hs$ и $\Hp$. Например, в случае с группой эллиптической кривой $\G$ в поле $\F$ для двух хеш-функций $H^s:\left\{0,1\right\}^* \to \F$ и $H^p:\left\{0,1\right\}^* \to \G$ схема кольцевой подписи, подобная схеме Шнорра, как в работе \cite{liu2004linkable}, будет упакована в описания $\rho$, $\mathcal{SK} = \F^*$, $\mathcal{PK} = \G$, $\mathcal{SIG} = \F^n$ и генератор $G \in \G$ (которого достаточно, чтобы указать преобразование $\phi: \F^* \to \G$, определяемое $x \mapsto xG$). Следует отметить, что каждый алгоритм в схеме LRS берёт $(\lambda, \rho)$ в качестве входа; впоследствии мы  исключаем их из обозначений схем LRS, поскольку их использование подразумевается изначально.

Также обратите внимание, что мы не допускаем, что схема LRS является правильной, если она позволяет использовать анонимные мультимножества $Q$.

\begin{definition}\label{def:lrs-correct}
Допустим, $b\in \left\{0,1\right\}$, $sk, sk^* \in \mathcal{SK}$, $Q$, $Q^* \subset \mathcal{PK}$ будут множествами, а $m, m^*, m^\prime$ будут сообщениями; допустим, $\sigma, \sigma^*, \sigma^\prime \in \mathcal{SIG}$ будут какими-то предполагаемыми подписями. Определим следующие события.
\begin{itemize}
\item $E_1(sk, pk)$ является таким событием, что некоторые $(sk, pk) \leftarrow \texttt{KEYGEN}$.

\item $E_2(sk, Q)$ является таким событием, что $\phi(sk) \in Q$.

\item $E_3(m, Q, \sigma)$ является таким событием, что $\texttt{VERIFY}(m, Q, \sigma) = 1$.

\item $E_4(b, m, m^*, m^\prime, Q, Q^*, Q^\prime, \sigma, \sigma^*, \sigma^\prime)$ является таким событием, что \[b = \texttt{LINK}((m, Q, \sigma), (m^*, Q^*, \sigma^*)) = \texttt{LINK}((m^*, Q^*, \sigma^*), (m^\prime, Q^\prime, \sigma^\prime)).\]

\item $E_5(m, m^*, Q, Q^*, \sigma, \sigma^*, sk)$ является таким событием, что \[\phi(sk) \in Q \cap Q^*\text{, }\sigma \leftarrow \texttt{SIGN}(m, Q, sk)\text{, и }\sigma^* \leftarrow \texttt{SIGN}(m^*, Q^*, sk).\]

\item $E_6(m, m^*, Q, Q^*, \sigma, \sigma^*, sk, sk^*)$ является таким событием, что  \[\sigma \leftarrow \texttt{SIGN}(m, Q, sk)\text{, }\sigma^* \leftarrow \texttt{SIGN}(m^*, Q^*, sk^*)\text{, и }sk \neq sk^*.\]
\end{itemize}
Мы говорим, что схема $\Pi_{LRS}$ является верной, если наблюдается соответствие всем следующим свойствам, где эти вероятности вычисляются для всех случайных монет и всех вариантов хеш-функций.

\begin{enumerate}[(i)]
\item Действительные ключи распределяются надлежащим образом: $$\prob\left[ \phi(sk) = pk \mid E_1(sk, pk) \right] \approx 1$$

\item Подписание ключом, который отсутствовал в кольце, не состоялось: $$\prob\left[ \texttt{SIGN}(m, Q, sk) = \bot \mid \overline{E_2}(sk, Q)  \right] \approx 1$$

\item Верификация с использованием действительной подписи прошла успешно: $$\prob\left[ \texttt{VERIFY}(m, Q, \texttt{SIGN}(m, Q, sk)) = 1 \mid E_2(sk, Q) \right] \approx 1$$

\item Действительная подпись связывается сама с собой: $$\prob\left[\texttt{LINK}((m, Q, \sigma), (m, Q, \sigma)) = 1 \mid E_3(m, Q, \sigma)\right] \approx 1$$

\item Связывание является коммутационным: $${\small \prob\left[\texttt{LINK}((m, Q, \sigma), (m^*, Q^*, \sigma^*)) = \texttt{LINK}((m^*, Q^*, \sigma^*), (m, Q, \sigma))\right] \approx 1}$$

\item Связывание является транзитивным: $${\small \prob\left[b = \texttt{LINK}((m, Q, \sigma), (m^\prime, Q^\prime, \sigma^\prime)) \mid E_4(b, m, m^*, m^\prime, Q, Q^*, Q^\prime, \sigma, \sigma^*, \sigma^\prime)\right] \approx 1}$$

\item Повторное использование подписывающего ключа является связующим: $$\prob\left[ \texttt{LINK}((m, Q, \sigma), (m^*, Q^*, \sigma^*)) = 1 \mid E_5(m, m^*, Q, Q^*, \sigma, \sigma^*, sk) \right] \approx 1$$

\item Использование отдельного подписывающего ключа подразумевает отсутствие связывания: $${\small \prob\left[ \texttt{LINK}((m, Q, \sigma), (m^*, Q^*, \sigma^*)) = 0 \mid E_6(m, m^*, Q, Q^*, \sigma, \sigma^*, sk, sk^*) \right] \approx 1}$$
\end{enumerate}
\end{definition}


\subsection{Связываемость}

Мы используем два отдельных, но связанных между собой определения связываемости. Первым определением является Определение 5, взятое из работы \cite{au2006short}, где мы используем термин \textit{связываемость ACST} (по инициалам автора). Данное определение допускает использование запросов подписывающего оракула с любыми анонимными группами $Q$, состоящими по крайней мере из одного ключа запроса (который может быть смоделирован путём внесения обратных правок). Это определение также позволяет запросчику успешно решить задачу связываемости, используя тройные значения подписи $(m, Q, \sigma)$, $(m^*, Q^*, \sigma^*)$, в которых присутствуют «полуповреждённые» анонимные группы $Q, Q^*$ (при условии, что ключи в $Q \cup Q^*$. Вторым определением является Определение 8, взятое из работы \cite{backes2019ring}, в отношении которого мы используем термин \textit{связываемости по голубиным отверстиям} в соответствии с известным принципом голубиных отверстий. Это определение допускает наличие у злоумышленника полного контроля над выбором ключей, когда считается, что злоумышленник добился успеха, если ему удалось создать больше несвязываемых кольцевых подписей, чем составляет общее количество участников кольца. Такому злоумышленнику не требуется генерировать ключи, повреждать их или обладать доступом к подписывающему оракулу.

\begin{definition}[Связываемость ACST с использованием ключа \linebreak злоумышленника]\label{def:acst-link-adv}
Мы утверждаем, что любой PPT-алгоритм $\A$, который может успешно решить эту задачу самое большее за время $t$ и с вероятностью успешного выполнения по крайней мере $\epsilon$, является $(t, \epsilon, q)$-алгоритмом решения задачи связываемости ACST.

\begin{enumerate}
\item Запросчик выводит $\left\{(sk_i, pk_i)\right\}_{i=0}^{q-1}$ из $\texttt{KEYGEN}$ и отправляет публичные ключи запроса $S = \left\{pk_i\right\}_{i=0}^{q-1}$ алгоритму $\A$.

\item Алгоритм $\A$ получает доступ к \texttt{SO} и \texttt{CO}.
    \begin{itemize}
    \item \texttt{CO} берёт в качестве входа публичный ключ $pk$. Если $pk \in S$, $\texttt{CO}$ выдаёт соответствующий приватный ключ $sk$. В противном случае $\texttt{CO}$ выдаёт символ отказа, $\bot$. Повреждённые ключи отслеживаются через таблицу $C$.

    \item \texttt{SO} выполняется следующим образом:
        \begin{enumerate}[(i)]
        \item В качестве входа берётся сообщение $m$, анонимная группа $Q = \left\{pk^\prime_i\right\}_{i=0}^{n-1}$ и индекс $l$ (обратите внимание, что мы специально не запрашиваем $Q \subset S$).

        \item Если $0 > l$ или $l \geq n$, или же если $pk^\prime_l \notin S$, \texttt{SO} выдаёт символ отказа $\bot$.

        \item В ином случае существует такое значение $i$, что \linebreak $pk^\prime_l = pk_i \in S$. \texttt{SO} выбирает приватный ключ $sk_i$ и выводит такое действительное тройное значение подписи $(m, Q, \sigma)$, что $\sigma \leftarrow \texttt{SIGN}(m, Q, sk_i)$.
        \end{enumerate}
    \end{itemize}

\item $\A$ выдаёт пару тройных значений подписи $(m, Q, \sigma)$, $(m^*, Q^*, \sigma^*)$ и решение является успешным, если и только если соблюдены все следующие условия (следует отметить, что в данном случае мы не ставим чёткого требования, чтобы $Q \subset S$ или $Q^* \subset S$).
    \begin{enumerate}[(i)]
        \item $\texttt{VERIFY}(m, Q, \sigma) = \texttt{VERIFY}(m^*, Q^*, \sigma^*) = 1$
        \item $\texttt{LINK}((m, Q, \sigma), (m^*, Q^*, \sigma^*)) = 0$
        \item $\sigma, \sigma^*$ не выводятся в результате запроса $\texttt{SO}$.
        \item $\left|(Q \cup Q^* ) \cap (C \cup \overline{S})\right| \leq 1$
    \end{enumerate}
\end{enumerate}
Мы говорим, что схема является \textit{связываемой по ACST}, если каждый PPT-алгоритм $\A$, являющийся $(t, \epsilon, q)$-алгоритмом решения задачи связываемости ACST, имеет ничтожную вероятность приемлемости $\epsilon$.
\end{definition}

\begin{definition}[Связываемость по $q$ голубиных отверстий]\label{def:pig-link}
Мы \linebreak утверждаем, что любой PPT-алгоритм $\A$, который может успешно выдать $q$ публичных ключей $\left\{pk_i\right\}_{i=0}^{q-1}$ и $q + 1$ действительных, несвязанных тройных значений подписи $\left\{(m_j, Q_j, \sigma_j)\right\}_{j=0}^{q}$ так, чтобы $\cup_j Q_j \subseteq \left\{pk_i\right\}_{i=0}^{q-1}$, самое большее за время $t$ и с вероятностью, по крайней мере, $\epsilon$, является $(t, \epsilon, q)$-алгоритмом решения задачи связываемости по $q$ голубиных отверстий. Мы говорим, что схема является связываемой по $q$-\textit{классам}, если каждый PPT-алгоритм $\A$, являющийся $(t, \epsilon, q)$-алгоритмом решения задачи связываемости по $q$-классам имеет ничтожную вероятность приемлемости $\epsilon$. (Следует отметить, что в данном случае злоумышленник не имеет доступа к подписывающему или повреждённому оракулу.)
\end{definition}

Эти определения существуют по отдельности. Связываемость по голубиным отверстиям совсем не обязательно предполагает наличие связываемости ACST. На самом деле алгоритм, который успешно решит задачу в соответствии с Определением \ref{def:acst-link-adv}, может сделать это только при наличии достаточно больших колец, и в таком случае это может быть успешно сделано уже с использованием Определения \ref{def:pig-link} с достаточно большим значения $q$. Подобным образом связываемость ACST может и не предполагать связываемости по голубиным отверстиям. Алгоритм решения задачи, в соответствии с Определением \ref{def:pig-link}, требующий знания множества приватных ключей, может потребовать большого количества повреждений, чтобы успешно решить задачу в соответствии с Определением \ref{def:acst-link-adv}.

В случае со схемой связываемости по голубиным отверстиям, в Определении \ref{def:pig-link} не сказано ничего о злоумышленнике, способном подписываться множество раз, используя один и тот же ключ, чтобы строить новые несвязанные подписи до тех пор, пока будут использоваться различные анонимные группы.

В случае со схемой связываемости ACST пользователь, предоставляющий честные подписи злоумышленнику, действует в качестве подписывающего оракула, поэтому злоумышленник может попытаться построить плохую/клонированную подпись, которая будет связана с честной подписью (возможно, с выбранными злоумышленником участниками кольца), и всегда выдавать только одну подпись. В Определении \ref{def:acst-link-adv} ничего не сказано о возможности подобной атаки. Такой злоумышленник может находиться между Элис и Бобом и выдавать Бобу клонированные подписи, как бы созданные Элис, тем самым обманывая его. Когда в конечном счёте Элис свяжется с Бобом и между ними уже не будет никакого злоумышленника, она не сможет доказать свою невиновность в связи с клонированными подписями. Боб придёт к выводу, что $\sigma^*$ и $\sigma$ были подписаны одним и тем же приватным ключом, несмотря на то, что злоумышленнику не был известен приватный ключ, при помощи которого была сгенерирована $\sigma$.

Тем не менее, Определение \ref{def:pig-link} предполагает возможность решения по Определению \ref{def:acst-link-adv} при определённых обстоятельствах. Вот один пример (из множества): если существует $(t, \epsilon, 1)$-алгоритм решения задачи, в соответствии с Определением \ref{def:acst-link-adv}, который выдаёт такие два тройных значения подписи $(m, Q, \sigma)$, $(m^\prime, Q^\prime, \sigma^\prime)$, $Q = Q^\prime$, что $\left|Q\right| = 1$, значит, $\A$ может успешно решить задачу в соответствии с Определением \ref{def:pig-link}.

Данная работа не предполагает более подробного рассмотрения отношений между определениями связываемости. Поскольку ни одно из определений само по себе не является достаточным в нашем случае, а также, поскольку эти определения в целом являются самостоятельными, мы используем оба.


\subsection{Невозможность подделки и защита от оговора}

Идея экзистенциальной невозможности подделки обычных цифровых подписей состоит в том, чтобы алгоритм выдавал любую действительную не использующую оракул подпись для любого сообщения и чтобы такая подпись создавалась с использованием неповреждённого ключа запроса. Очевидным аналогом схем LRS является задача, согласно которой алгоритм должен выдавать любую действительную не использующую оракул подпись для любого сообщения, и чтобы такая подпись была связана с подписью запроса, вычисленной на основе неповреждённого ключа запроса. Фактически вариант реализации, предлагаемый в Разделе \ref{sec:implementation}, предполагает сравнение связующих тегов, как если бы они были ключами верификации; в этом контексте перед злоумышленником, создающим поделку, стоит задач по созданию действительной подписи с использованием некоторых ключей верификации, приватный ключ к которым ему не известен. Мы считаем такую подделку хрестоматийной, и поэтому учитываем такую вероятность в рамках нашего определения. В отличие от определений невозможности подделки, приводимых в работах \cite{au2006short} и \cite{backes2019ring}, мы однозначно учитываем свойство связываемости, а также то, что злоумышленник может использовать повреждённые ключи. Далее мы связываем данное определение с определением защиты от оговора.

\begin{definition}[Обеспечение экзистенциальной невозможности \linebreak подделки связываемых кольцевых подписей при наличии выбираемых злоумышленником ключей и внутреннего повреждения]\label{def:ex-unf}
Мы утверждаем, что любой PPT-алгоритм $\A$, который может успешно решить данную задачу самое большее за время $t$ и с вероятностью по крайней мере $\epsilon$, является $(t, \epsilon, q)$-алгоритмом подделки.
\begin{enumerate}

\item Запросчик выводит $\left\{(sk_i, pk_i)\right\}_{i=0}^{q-1}$ из \texttt{KEYGEN} и задаёт значение $S := \left\{pk_i\right\}_{i=0}^{q-1}$. Для каждого $0 \leq i < q$ запросчик единообразно выбирает секрет $\emptyset \neq \widetilde{Q}_i \in \mathcal{P}\left(S\right)$, определяет $Q_i := \widetilde{Q}_i \cup \left\{pk_i\right\}$, выбирает такой индекс $l_i$, что $pk_{i} \in Q_i \cap S$ имеет индекс $l_i$ в $Q_i$, выбирает случайные секретные сообщения $\left\{m_i\right\}_{i=0}^{q-1}$ и вычисляет секретные подписи запроса $\sigma_i \leftarrow \texttt{SIGN}(m_i, Q_i, sk_i)$. Запросчик отправляет $S$ алгоритму $\A$.
\item Запросчик даёт \texttt{SO} и \texttt{CO} доступ к \A:
    \begin{itemize}
    \item В качестве входа \texttt{CO} берёт публичный ключ запроса $pk_i \in S$, а в качестве выхода выдаёт соответствующий приватный ключ $sk_i$, сохраняя список всех повреждённых публичных ключей во внутренней таблице $C$.

    \item \texttt{SO} выполняется следующим образом:
        \begin{enumerate}[(i)]
        \item В качестве входа берётся сообщение $m$, анонимная группа $Q$ и индекс $l$.

        \item Если ключ с индексом $l$ в $Q$ не является публичным ключом вызова $S$, \texttt{SO} выдаёт символ отказа $\bot$.

        \item В ином случае \texttt{SO} выбирает такой индекс $i$, что $pk_{i} \in Q \cap S$ имеет индекс $l$ в $Q$ и выбирает соответствующий приватный ключ $sk_{i}$, и выводит подпись $\sigma \leftarrow \texttt{SIGN}(m, Q, sk_{i})$.
        \end{enumerate}
    \end{itemize}

\item $\A$ выдаёт сообщение $m$, кольцо $Q$, подпись $\sigma$, и решение является успешным, если и только если:
    \begin{enumerate}[(i)]
    \item $\texttt{VERIFY}(m, Q, \sigma) = 1$,

    \item Не существует никакого запроса, полученного $\texttt{SO}$, выходом которого является $\sigma$,

    \item Существует такое $i \in [0,q)$ что ${\small \texttt{LINK}((m, Q, \sigma), (m_i, Q_i, \sigma_i)) = 1}$, а $pk_i \in S \cap Q \setminus C$.
    \end{enumerate}
\end{enumerate}
Более того, мы говорим, что схему связываемой кольцевой подписи \textit{невозможно подделать}, если каждый $(t, \epsilon, q)$-алгоритм решения данной задачи имеет ничтожную вероятность приемлемости $\epsilon$.
\end{definition}

\begin{remark}
Доступ к повреждённому оракулу в соответстви с данным определением невозможности подделки является одной из причин (небольшого) ослабления безопасности до решения задачи $\kappa$-дополнительного дискретного логарифма, а не обычной задачи дискретного логарифмирования: алгоритм, реализующий алгоритм подделки в чёрном ящике, не может смоделировать повреждённый оракул для осуществления подделки без получения доступа к повреждённому оракулу или без использования общей групповой модели.
\end{remark}

\begin{remark}
Если $\A$ является алгоритмом, создающим подписи в соответствии со схемой LRS, соответствующей Определению \ref{def:ex-unf}, значит, (за исключением незначительной вероятности) эти подписи не являются подделками, и, таким образом, некоторое свойство 3(i)-3(iii) должно быть нарушено. Если подпись является действительной и не была получена в результате запроса оракула, значит, свойство 3(iii) было нарушено. В частности, в случае со схемой LRS, соответствующей Определению \ref{def:ex-unf}, если алгоритм выдаёт действительное полученное без использования оракула тройное значение $(m, Q, \sigma)$, связанное с ключом запроса в $Q$, значит, такой ключ запроса был повреждён.
\end{remark}

Схема защиты от оговора была представлена в работе \cite{tsang2004separable}. Это определение обновлялось дважды в работе \cite{au2006short}, допуская, что $\A$ может успешно решить задачу всякий раз, когда публикует любую подпись, связанную с любой подписью из запроса $\A$, сделанного $\texttt{SO}$, за исключением определённых условий. Мы изменяем определение, приведённое в работе \cite{au2006short}, допуская наличие запросов подписывающего оракула с анонимными группами, содержащими выбранных злоумышленников участников.

\begin{definition}[Защита от оговора выбранной цели при наличии выбираемых злоумышленником ключей и внутренних повреждений]\label{def:acst-nonsl}
Мы утверждаем, что любой PPT-алгоритм $\A$, который может успешно решить следующую задачу самое большее за время $t$ и с вероятностью по крайней мере $\epsilon$, является $(t, \epsilon, q)$-алгоритмом решения задачи защиты от оговора при наличии выбранных злоумышленником ключей.
\begin{enumerate}
\item Запросчик выводит $\left\{(sk_i, pk_i)\right\}_{i=0}^{q-1}$ из $\texttt{KEYGEN}$ и отправляет публичные ключи запроса $S = \left\{pk_i\right\}_{i=0}^{q-1}$ \A.

\item A получает доступ к \texttt{SO} и \texttt{CO} точно так же, как в случае с Определением \ref{def:ex-unf}.

\item A выдаёт тройное значение $(m, Q, \sigma)$, и решение является успешным, если и только если:
    \begin{enumerate}[(i)]
    \item $\texttt{VERIFY}(m, Q, \sigma) = 1$, и

    \item не существует никакого запроса, полученного $\texttt{SO}$, выходом которого является $\sigma$, и

    \item существует такой запрос, отправленный $\texttt{SO}$, допустим, $\sigma^* \leftarrow \texttt{SO}(m^*, Q^*, l^*)$, что
        \begin{enumerate}[(a)]
        \item $\texttt{LINK}((m, Q, \sigma), (m^*, Q^*, \sigma^*)) = 1$, и

        \item $pk^*_{l^*} \in S \cap Q^* \cap Q \setminus C$.
        \end{enumerate}
    \end{enumerate}
\end{enumerate}
Более того, мы говорим, что схема связываемой кольцевой подписи \textit{защищена от оговора}, если каждый $(t, \epsilon, q)$-алгоритм решения данной задачи имеет ничтожную вероятность приемлемости $\epsilon$.
\end{definition}

\begin{theorem}[Защита от оговора равноценна невозможности подделки]\label{thm:nonsl-implies-unf}
Правильную схему LRS невозможно подделать согласно Определению \ref{def:ex-unf}, если и только если она защищена от оговора в соответствии с Определением \ref{def:acst-nonsl}.
\end{theorem}

\begin{proof}
    Допустим, $\A$ является $(t,\epsilon,q)$-алгоритмом решения задачи в соответствии с Определением \ref{def:ex-unf}. Мы демонстрируем, как построить алгоритм $\B$, который будет выполнять $\A$ в чёрном ящике и будет успешно решать задачу защиты от оговора в соответствии с Определением \ref{def:acst-nonsl}. Отметим, что подписывающий и повреждённый оракул идентичны в обоих определениях, поэтому такие запросы могут бесшовным способом передаваться между участниками, как это описано ниже. Формально $\B$ работает следующим образом:
    \begin{itemize}
        \item Алгоритм $\B$ получает от своего запросчика набор публичных ключей $S = \{pk_i\}_{i=0}^{q-1}$. Он выбирает сообщения и кольца (так же как это делается в соответствии с Определением \ref{def:ex-unf}) и генерирует набор кортежей $\{(m_i,Q_i,\sigma_i)\}_{i=0}^{q-1}$ при помощи запросов в форме $\texttt{SO}(m_i,Q_i,l_i) \to \sigma_i$, где каждая $l_i$ является индексом $pk_i$ в $Q_i$. Затем алгоритм передаёт набор публичных ключей $S$ алгоритму $\A$
        \item Алгоритм $\B$ принимает запросы оракула $\texttt{SO}$ и $\texttt{CO}$ от алгоритма $\A$, передаёт их запросчику и возвращает полученный результат $\A$.
        \item Алгоритм $\A$ возвращает кортеж $(m,Q,\sigma)$, соответствующий условиям Определения \ref{def:ex-unf}.
        \item Алгоритм $\B$ выводит $(m,Q,\sigma)$.
    \end{itemize}
    Поскольку алгоритм $\A$ является алгоритмом решения задачи невозможности подделки, то при наличии преимущества $\epsilon$ существует такой индекс $i \in [0,q)$, что $$\texttt{LINK}((m,Q,\sigma),(m_i,Q_i,\sigma_i)) = 1$$ и $pk_i \in S \cap Q \setminus C$. Кроме того, алгоритм $\B$ при помощи запроса оракула $\texttt{SO}(m_i,Q_i,l_i)$ получает $\sigma_i$, поэтому по схеме также $pk_i \in Q_i$. Так как алгоритм $\B$ использует дополнительное время $t'$ для своих начальных $q$ запросов подписывающего оракула и просмотров транскриптов, а также имеет то же преимущество $\epsilon$, что и алгоритм $\A$, можно утверждать, что нами построен $(t+t',\epsilon,q)$-алгоритм решения задачи защиты от оговора, соответствующий Определению \ref{def:acst-nonsl}.

    Теперь мы приводим обратную формулировку, согласно которой предполагаем, что $\A$ является $(t,\epsilon,q)$-алгоритмом решения задачи защиты от оговора в соответствии с Определением \ref{def:acst-nonsl}. Мы строим алгоритм $\B$, который выполняет алгоритм $\A$ в чёрном ящике и является алгоритмом решения задачи невозможности подделки в соответствии с Определением \ref{def:ex-unf}.
    \begin{itemize}
        \item Алгоритм $\B$ получает от своего запросчика набор публичных ключей $S = \{pk_i\}_{i=0}^{q-1}$. Он передаёт набор публичных ключей $S$ алгоритму $\A$
        \item Алгоритм $\B$ принимает запросы оракула $\texttt{SO}$ и $\texttt{CO}$ от алгоритма $\A$, передаёт их запросчику и возвращает полученный результат $\A$.
        \item Алгоритм $\A$ возвращает кортеж $(m,Q,\sigma)$ , соответствующий условиям Определения \ref{def:acst-nonsl}.
        \item Алгоритм $\B$ выводит $(m,Q,\sigma)$.
    \end{itemize}
    Поскольку алгоритм $\A$ является алгоритмом решения задачи защиты от оговора, то при наличии преимущества $\epsilon$ существует такой запрос подписывающего оракула $\texttt{SO}(m^*,Q^*,l^*) \to \sigma^*$, что $$\texttt{LINK}((m,Q,\sigma),(m^*,Q^*,\sigma^*)) = 1$$ и $pk_{l^*}^* \in S \cap Q^* \cap Q \setminus C$. Но так как $pk_{l^*}^* = pk_i \in S$ для некоторого индекса $i \in [0,q)$, запросчик решения задачи невозможности подделки создаёт действительную подпись $\sigma_i$ для некоторого сообщения $m_i$ и кольца $Q_i$, где $pk_i \in Q_i$. Таким образом, это должно выглядеть как $$\texttt{LINK}((m^*,Q^*,\sigma^*),(m_i,Q_i,\sigma_i)) = 1$$ и в силу свойства транзитивности мы также получаем $$\texttt{LINK}((m,Q,\sigma),(m_i,Q_i,\sigma_i)) = 1$$ Таким образом, мы продемонстрировали, что $\B$ является $(t,\epsilon,q)$-алгоритмом решения задачи невозможности подделки, что делает наше доказательство полным.
\end{proof}

\subsection{Связываемая анонимность}

Нами используется модифицированный вариант определения связываемой анонимности из работы \cite{backes2019ring}. Определение, представленное нами в данной работе, отличается от  того, что предлагается в работе \cite{backes2019ring}, поскольку не предполагает наличия у злоумышленника доступа к поднабору повреждённых ключей до того, как он получит доступ к подписывающему оракулу; это необходимо для того, чтобы позднее свести всё к сложности решения задачи в соответствии с Определением \ref{def:rom-ddh}.

\begin{definition}[Обеспечение связываемой анонимности выбранной цели при наличии выбранных злоумышленником ключей]\label{linkable-anonymity-game}
Мы утверждаем, что любой PPT-алгоритм $\A$, который может успешно решить следующую задачу самое большее за время $t$ и с вероятностью по крайней мере $\epsilon$, является $(t, \epsilon, q)$-алгоритмом решения задачи обеспечения связываемой анонимности.
\begin{enumerate}
\item Запросчик выбирает секретный случайный бит $b \in \left\{0,1\right\}$, выводит $\left\{(sk_i, pk_i)\right\}_{i=0}^{q-1}$ из $\texttt{KEYGEN}$ и отправляет публичные ключи запроса $S := \left\{pk_i\right\}_{i=0}^{q-1}$ алгоритму $\A$.

\item Алгоритм $\A$ выдаёт пару индексов $0 \leq i_0, i_1 < q$, что $pk_{i_0}, pk_{i_1} \in S$, указывая ключи цели.

\item Алгоритм $\A$ получает доступ к подписывающему оракулу $\texttt{SO}$ (который заметно отличается от подписывающего оракула, который использовался в предыдущих определениях):
    \begin{enumerate}[(i)]
    \item В качестве входа берётся сообщение $m$, анонимная группа $Q$ и публичный ключ $pk \in Q$.

    \item Если $\left\{pk_{i_0}, pk_{i_1}\right\} \not\subseteq Q$ или $pk \notin \left\{pk_{i_0}, pk_{i_1}\right\}$, $\texttt{SO}$ выдаёт действительную подпись $\sigma$, связанную с $pk$.

    \item В ином случае $pk = pk_{i_c}$ для бита $c$. Вычисляется бит $c^\prime = (1-c)b + c(1-b)$ и оракул $\sigma \leftarrow \texttt{Sign}(m, Q, sk_{i_{c^\prime}})$ (то есть $c' = c \oplus b$).
    \end{enumerate}

\item Алгоритм $\A$ выдаёт бит $b^\prime$, и задача считается успешно решённой, если $b^\prime = b$.
\end{enumerate}
Более того, мы говорим, что схема является \textit{связываемо анонимной}, если каждый $(t, \epsilon, q)$-алгоритм решения задачи связываемой анонимности имеет преимущество с ничтожной вероятностью приемлемости $\epsilon$ более $1/2$.
\end{definition}


\section{Структура}\label{sec:implementation}

В этом разделе нами описывается $d$, наш вариант реализации сжатой схемы $d$-LRS.

\begin{definition}[$d$-CLSAG]\label{def:clsag}
Схемой подписи $d$-LRS является следующий кортеж $(\texttt{Setup}, \texttt{KeyGen}, \texttt{Sign}, \texttt{Verify}, \allowbreak \texttt{Link})$.

\begin{itemize}
\item $\texttt{Setup} \to \textit{par}$. $\texttt{Setup}$ выбирает простое число $p$, группу $\G$ порядка простого числа $p$, равномерно случайным образом выбирает генератор $G \in \G$, выбирает $d$ криптографических хеш-функций $\Hs_0, \ldots, \Hs_{d-1}$ (смоделированы как случайные оракулы) с кодоменом $\F$, выбирает криптографическую хеш-функцию $\Hp$ с кодоменом $\G$. $\texttt{Setup}$ выдаёт кортеж параметров группы и хеш-функции, $\textit{par} := \left(p,\G, d, G, \left\{\Hs_j\right\}_{j=0}^{d-1}, \Hp\right)$.\footnote{Следует отметить, что в данном случае разделение доменов может использоваться для того, чтобы разделить хеш-функцию $\Hs$ и построить каждую $\Hs_j$, определив $\Hs_j(x) := \Hs(j \mid\mid x)$.}

\item $\texttt{KeyGen} \to (\textbf{sk}, \textbf{pk})$. При наличии запроса нового ключа $\texttt{KeyGen}$ выбирает свежий секретный ключ и вычисляет соответствующий ему публичный ключ:
\begin{align*}
\textbf{sk} =& (z_0, z_1, \ldots, z_{d-1}) \leftarrow (\F^*)^d\\
\textbf{pk} :=& \textbf{sk} \circ \textbf{G} = (Z_0, Z_1, \ldots, Z_{d-1}) \in \G^d
\end{align*} где $\textbf{G} = (G, \ldots, G) \in \G^d$. $\texttt{KeyGen}$ выдаёт $(\textbf{sk}, \textbf{pk})$. Мы называем $z_0$ \textit{связующим ключом}, остальные ключи $\left\{z_j\right\}_{j=1}^{d-1}$ \textit{вспомогательными ключами} и обозначаем связующий ключ как $x$.

\item $\texttt{Sign}\left(m, Q, \textbf{sk}\right) \to \left\{\bot_{\texttt{Sign}}, \sigma\right\}$. В качестве входа $\texttt{Sign}$ берёт сообщение $m \in \left\{0,1\right\}^*$, кольцо  $Q = (\textbf{pk}_0, \ldots, \textbf{pk}_{n-1})$ для участников кольца $\textbf{pk}_i = (X_i, Z_{i,1}, \ldots, Z_{i,d-1}) \in \G^d$ и секретный ключ $\textbf{sk} = (x,z_1, \ldots, z_{d-1}) \in (\F^*)^d$. $\texttt{Sign}$ выполняет следующее:

\begin{enumerate}
\item Если $Q \not\subseteq \G^{d\times n}$ для некоторого $n$, $\texttt{Sign}$ выводит $\bot_{\texttt{Sign}}$ и завершает процесс.

\item В ином случае $\texttt{Sign}$ разбирает\footnote{Следует отметить, что такой разбор всегда происходит успешно, если $\texttt{Sign}$ проходит предыдущий этап без ошибок.} $Q$, чтобы получить каждый $\textbf{pk}_i$. Если публичный ключ, связанный со входом $\textbf{sk}$, не является участником кольца $Q$, $\texttt{Sign}$ выводит $\bot_{\texttt{Sign}}$ и завершает процесс.

\item В ином случае $\texttt{Sign}$ находит такой подписывающий индекс $\ell$ чтобы $\textbf{pk}_\ell = \textbf{sk} \circ (G, \ldots, G)$. $\texttt{Sign}$ единнобразно случайным образом выбирает $\alpha \in \F$, выбирает $\left\{s_i\right\}_{i \neq \ell} \in (\F)^{n-1}$ и вычисляет точки $H_i = \Hp(X_i)$ для каждого $i$. $\texttt{Sign}$ вычисляет \textit{коэффициенты агрегирования} $\mu_X$ и $\{\mu_j\}_{j=1}^{d-1}$, связующий тег $\mathfrak{T}$, вспомогательные элементы группы $\{\mathfrak{D}_j\}_{j=1}^{d-1}$ и агрегированные публичные ключи:
\begin{align*}
\mathfrak{T} :=& x H_\ell & \{\mathfrak{D}_j\} :=&  \{z_j H_\ell\} \\
\mu_X :=& \Hs_0(Q \mid \mid \mathfrak{T} \mid \mid \{\mathfrak{D}_j\}_{j=1}^{d-1})
 & \mu_j :=& \Hs_j(Q \mid \mid \mathfrak{T} \mid \mid \{\mathfrak{D}_j\}_{j=1}^{d-1}) \\
 W_i :=& \mu_X X_i + \sum_{j=1}^{d-1} \mu_j Z_{i,j} & \mathfrak{W} :=& \mu_X \mathfrak{T} + \sum_{j=1}^{d-1} \mu_j \mathfrak{D}_j
 \end{align*} а также агрегированный секретный ключ $w_\ell :=  \mu_X x + \sum_{j=1}^{d-1} \mu_j z_j$. Для $i = \ell, \ell+1, \ldots, \ell-1$ (по модулю $n$) $\texttt{Sign}$ вычисляет
\begin{align*}
L_\ell =& \alpha G & R_\ell =& \alpha H_\ell & c_{\ell+1} =& \Hs_0(Q \mid \mid m \mid \mid L_\ell \mid \mid R_\ell) \\
L_i =& s_i G + c_i W_i & R_i =& s_i H_i + c_i \mathfrak{W}
 & c_{i+1} =& \Hs_0(Q \mid \mid m \mid \mid L_i \mid \mid R_i)
\end{align*} и наконец вычисляет $s_\ell = \alpha - c_\ell w_\ell$.

\item $\texttt{Sign}$ выдаёт подпись $\sigma = (c_0, s_0, s_1, \ldots, s_{n-1}, \mathfrak{T}, \{\mathfrak{D}_j\}_{j=1}^{d-1})$.
\end{enumerate}

\item $\texttt{Verify}\left(m, Q, \sigma\right) \to \left\{0,1\right\}$. $\texttt{Verify}$ берёт в качестве входа сообщение $m$, матрицу $Q = (\textbf{pk}_0, \ldots, \textbf{pk}_{n-1})$ и подпись $\sigma$.
\begin{enumerate}
\item Если $Q \not\subseteq \G^{d \times n}$ для некоторого $n$ или если $\sigma \notin \F^{n^\prime+1} \times \G^d$ для некоторого $n^\prime$, $\texttt{Verify}$ выводит $0$ и завершает процесс. В ином случае, если $n^\prime \neq n$, $\texttt{Verify}$ выводит $0$ и завершает процесс.

\item $\texttt{Verify}$ разбивает\footnote{Разбор всегда происходит успешно, если на предыдущем этапе выполнение $\texttt{Verify}$ не завершается.} $(\textbf{pk}_0, \ldots, \textbf{pk}_{n-1}) \leftarrow Q$ для ключей $\textbf{pk}_i \in \G^d$ в $i \in [0,n-1]$ и разбивает каждый публичный ключ $(X_i, Z_{i, 1}, \ldots, Z_{i, d-1}) \leftarrow \textbf{pk}_i$.  $\texttt{Verify}$ также разбивает $(c_0, s_0, \ldots, s_{n-1}, \mathfrak{T}, \mathfrak{D}_1, \ldots, \mathfrak{D}_{d - 1}) \leftarrow \sigma$. $\texttt{Verify}$ вычисляет каждый $H_i = \Hp(X_i)$, вычисляет коэффициенты агрегирования и вычисляет агрегированные публичные ключи:
\begin{align*}
\mu_X := & \Hs_0(Q \mid \mid \mathfrak{T} \mid \mid \{\mathfrak{D}_j\}_{j=1}^{d-1}) & \mu_j := & \Hs_j(Q \mid \mid \mathfrak{T} \mid \mid \{\mathfrak{D}_j\}_{j=1}^{d-1})\\
W_i :=& \mu_X X_i + \sum_{j=1}^{d-1} \mu_j Z_{i,j} & \mathfrak{W} :=& \mu_X \mathfrak{T} + \sum_{j=1}^{d-1} \mu_j \mathfrak{D}_j
\end{align*}

\item $\texttt{Verify}$ задаёт $c_0^\prime := c_0$ и для $i=1, 2, \ldots, n-1$, вычисляет следующее:
\begin{align*}
L_i :=& s_i G + c_i^\prime W_i, &
R_i :=& s_i H_i + c_i^\prime\mathfrak{W}, &
c_{i+1}^\prime :=& \Hs_0\left(Q \mid \mid m \mid \mid L_i \mid \mid R_i\right)
\end{align*}
\item Если $c_{n}^\prime = c_0$, $\texttt{Verify}$ выводит $1$, в ином случае выводит $0$.
\end{enumerate}

\item $\texttt{Link}\left((m, Q, \sigma), (m^\prime, Q^\prime, \sigma^\prime)\right) \to \left\{0,1\right\}$. В качестве входа $\texttt{Link}$ берёт два тройных значения сообщения-кольца-подписи.
\begin{enumerate}
\item Если $\texttt{Verify}(m, Q, \sigma) = 0$ или $\texttt{Verify}(m^\prime, Q^\prime, \sigma^\prime) = 0$, $\texttt{Link}$ выводит $0$ и завершает процесс.

\item В ином случае $\texttt{Link}$ разбирает\footnote{Как и ранее в случае с $\texttt{Verify}$, такой разбор всегда будет успешным, если на предыдущем этапе выполнен $\texttt{Link}$.} подписи, чтобы получить отдельные связующие теги $(\mathfrak{T}, \left\{\mathfrak{D}_j\right\}_j), (\mathfrak{T}^\prime, \left\{\mathfrak{D}^\prime_j\right\}_j) \leftarrow \sigma, \sigma^\prime$. $\texttt{Link}$ выводит $1$, если $\mathfrak{W} = \mathfrak{W}^\prime$, и $0$ в противном случае.
\end{enumerate}
\end{itemize}
\end{definition}

Данный вариант реализации предполагает наличие связываемости с \textit{полным ключом} с использованием связующих тегов $\mathfrak{W}$: две подписи будут связаны не только в том случае, если они будут подписаны при помощи одних и тех же связующих и вспомогательных ключей, но также и с использованием одного и того же кольца. Мы можем заменить алгоритм $\texttt{Link}$ связываемостью с \textit{использованием одного ключа}:
\begin{itemize}

\item $\texttt{Link}\left((m, Q, \sigma), (m^\prime, Q^\prime, \sigma^\prime)\right) \to \left\{0,1\right\}$. В качестве входа $\texttt{Link}$ берёт два тройных значения сообщения-кольца-подписи.
\begin{enumerate}
\item Если $\texttt{Verify}(m, Q, \sigma) = 0$ или $\texttt{Verify}(m^\prime, Q^\prime, \sigma^\prime) = 0$, $\texttt{Link}$ выводит $0$ и завершает процесс.

\item В ином случае $\texttt{Link}$ разбирает\footnote{Как и ранее в случае с  $\texttt{Verify}$, такой разбор всегда будет успешным, если на предыдущем этапе выполнение $\texttt{Link}$ не завершается.} подписи, чтобы получить отдельные связующие теги $(\mathfrak{T}, \left\{\mathfrak{D}_j\right\}_j), (\mathfrak{T}^\prime, \left\{\mathfrak{D}^\prime_j\right\}_j) \leftarrow \sigma, \sigma^\prime$. $\texttt{Link}$ выводит $1$, если $\mathfrak{T} = \mathfrak{T}^\prime$, и $0$ в противном случае.
\end{enumerate}
\end{itemize}


\section{Доказательства безопасности}

Следующая лемма вытекает непосредственно из модели случайного оракула, которую мы использовали для $\Hs$.

\begin{lemma}
Для любого $Q \subseteq \mathcal{PK}$, для любого приватного ключа \linebreak $sk = (x, \left\{z_j\right\}_j) \in Q$, преобразование $sk \mapsto \mu_X x + \sum_j \mu_j z_j$, где $\mu_X$, $\mu_j$, вычисляются так же, как в Определении \ref{def:clsag}, и является устойчивым к конфликтам функцией.
\end{lemma}

В Теореме \ref{thm:nonsl} мы доказываем, что схему $d$-CLSAG нельзя подделать, демонстрируя, что если какой-либо PPT-алгоритм выдаёт некоторое действительное не использующее оракул тройное значение $(m, Q, \sigma)$, связанное с участником анонимной группы в $Q$ (злоумышленником или другим), алгоритм может быть выполнен заново с целью вычисления дискретного логарифма такого участника анонимной группы. Эта теорема является стандартной для подписей, подобных подписям Шнорра, в рамках программируемой модели случайного оракула.

\begin{theorem}[Сложность задач дискретного логарифмирования в линейных комбинациях подразумевает невозможность подделки] \label{thm:nonsl}
Если существует $(t, \epsilon, q)$-алгоритм решения задачи невозможности подделки для схемы, соответствующей Определению \ref{def:clsag}, создающая запросы повреждённого оракула $\kappa^\prime$, то существует и $(2(t+t_0) + t_1, \epsilon\left(\frac{\epsilon}{q} - \frac{1}{2^\eta}\right) - \mu, \lfloor \frac{q}{d}\rfloor)$-алгоритм решения задачи $2d\kappa^\prime$-дополнительного дискретного логарифма в линейных комбинациях в $\G$ для некоторого незначительного $\mu$ и некоторых $t_0, t_1$.
\end{theorem}

\begin{proof}
Допустим, $\A$ является $(t, \epsilon, q)$-алгоритмом решения задачи защиты от оговора в соответствии с Определением \ref{def:acst-nonsl}. Мы заворачиваем алгоритм $\A$ в алгоритм $\B$. Алгоритм $\B$ выполняет $\A$ в чёрном ящике, обрабатывая запросы оракула для $\A$. Затем алгоритм $\B$ выдаёт результат выполнения $\A$ с индексом $idx$. Таким образом, $\B$ подходит для применения в рамках леммы разветвления. Мы заворачиваем $\mathcal{F}^{\B}$ в главный алгоритм $\texttt{M}$, то есть $(2(t+t_0) + t_1, \epsilon\left(\frac{\epsilon}{q} - \frac{1}{2^\eta}\right) - \mu, \lfloor \frac{q}{d}\rfloor)$-алгоритм решения задачи $\kappa$-дополнительного дискретного логарифма в линейных комбинациях в $\G$, где $\eta$ определяется так же, как в Лемме \ref{lem:fork}.

Если $\A$ создаёт удачную подделку, каждый запрос верификации в форме $c_{\ell+1} = \Hs(m \mid \mid Q \mid \mid R_\ell \mid \mid L_\ell)$ происходит в транскрипте между $\A$ и случайным оракулом $\Hs$. На самом деле тройное значение подписи, создаваемое $\A$, проходит верификацию, поэтому каждый запрос $c_{\ell+1}$, независимо от того, сделан он вместе с запросами оракула в транскрипте или нет, должен быть сопоставлен с запросами случайного оракула, которые делает верификатор. Доказывающая сторона не может угадать результат такого запроса, пока не сделает его, за минимально вероятным исключением. Следовательно, если $\A$ выдаёт действительную подпись, все запросы верификации вычисляются фактическим запросом оракула. Формальное доказательство этого факта изложено в работе \cite{liu2004linkable}. Поскольку все запросы верификации находятся посредством оригинальных запросов оракула, которые правильно упорядочены, существует первый запрос $\Hs$, сделанный $\A$ для вычисления запросов верификации, скажем, $c = \Hs(m \mid \mid Q \mid \mid R^* \mid \mid L^*)$. Это совсем не обязательно первый запрос, который делается $\Hs$ в целом. Допустим, это запрос $k^{th}$. Несмотря на то, что индекс кольца может быть не определён на момент первой выдачи этого запроса $\A$, к концу транскрипта этот индекс будет определён.

Мы строим $\B$ следующим образом. Мы даём $\B$ доступ к тем же оракулам, что и $\A$. Любые запросы оракула, которые делаются $\A$, пропускаются $\B$ к оракулам. Ответы записываются, а затем передаются обратно $\A$. Алгоритм $\B$ работает путем нахождения двух индексов для увеличения выхода $\A$. Во-первых, $\B$ находит индекс $k$ запроса $\Hs$, соответствующий первому запросу верификации, вычисленному $\A$, используемому для верификации предполагаемой подделки. Во-вторых, $\B$ проверяет транскрипт $\A$, чтобы в транскрипте такой индекс соответствовал анонимной группе $\ell$, чтобы $c = c_{\ell+1}$, $R^* = R_\ell$ и $L^* = L_\ell$. Теперь $\B$ выводит $idx = (k, \ell)$ вместе с тем, что выдаст $\A$. Очевидно, $\B$ делает то же количество запросов повреждённого оракула, что и $\A$.

Следует отметить, что $\B$ выполняется успешно всякий раз, когда выполняется $\A$, за время, составляющее самое большее $t$, как и в случае $\A$, за исключением некоторого дополнительного времени $t_0$, необходимого для поиска транскрипта для $idx$. Поскольку $\B$ подходит для использования в рамках леммы разветвления, мы можем использовать $\mathcal{F}^{\B}$ для построения $\texttt{M}$.

Алгоритм $\mathcal{F}^{\B}$ получает доступ к тем же оракулам, что и $\B$, за исключением $\Hs$ и $\texttt{SO}$. Алгоритм $\mathcal{F}^{\B}$ моделирует запросы $\texttt{SO}$, которые делаются $\B$ путём внесения простых обратных поправок в $\Hs$, и моделирует другие запросы $\Hs$, сделанные $\B$ с использованием случайных последовательностей $\textbf{h}, \textbf{h}^*$, как было сказано в подпункте \ref{sec:hardness}. Все другие запросы оракула, сделанные $\B$, передаются вместе с $\mathcal{F}^{\B}$ фактическим оракулам, а затем отправляются обратно $\B$.

Следует отметить, что $\mathcal{F}^{\B}$ выполняется за время $2(t+t_0)$ и (с вероятностью, равной по крайней мере $\epsilon\left(\frac{\epsilon}{q} - \frac{1}{2^\eta}\right)$) выдаёт пару действительных тройных значений $(m, Q, \sigma)$, $(m^\prime, Q^\prime, \sigma^\prime)$. Сообщения и анонимные группы выбираются до момента разветвления в транскриптах, поэтому $m=m^\prime$ и $Q=Q^\prime$. Кроме того, $\mathcal{F}^{\B}$ делает самое большее $2\kappa^\prime$ повреждённых запросов. Запросы в двух транскриптах являются самостоятельными, поскольку алгоритм разветвления выдаёт символ отказа $\bot$ и завершает процесс, если запросы $c_{\ell + 1}$ одинаковы в обоих транскриптах.
\[c_{\ell + 1} \leftarrow \Hs_0(m \mid \mid Q \mid \mid R_\ell \mid \mid L_\ell) \rightarrow c_{\ell+1}^\prime.\]

Мы заворачиваем $\mathcal{F}^{\B}$ в алгоритм $\texttt{M}$, который решает задачу $\kappa$-допол-\linebreakнительного дискретного логарифма в соответствии с Определением \ref{def:komdl} для $\kappa = 2\cdot d \cdot \kappa^\prime$. Алгоритм $\texttt{M}$ имеет доступ к повреждённому оракулу и выполняет $\mathcal{F}^{\B}$ в чёрном ящике, пропуская запросы повреждённого оракула вместе с $\mathcal{F}^{\B}$. Алгоритм $\texttt{M}$ находит следующую систему уравнений в транскриптах, проверяя запросы верификации.
\[R_\ell = s_\ell G + c_\ell X_\ell = s_\ell^\prime G + c_\ell^\prime X_\ell,\]
\[L_\ell = s_\ell H_\ell + c_\ell \mathfrak{W} = s_\ell^\prime H_\ell + c_\ell^\prime \mathfrak{W}.\] Данный алгоритм $\texttt{M}$ имеет достаточно информации для вычисления
\[ W_\ell = \frac{s_\ell - s_\ell^\prime}{c_\ell^\prime - c_\ell} G,  \mathfrak{W} = \frac{s_\ell - s_\ell^\prime}{c_\ell^\prime - c_\ell} H_\ell.\]
а следовательно, и приватный ключ $w = \frac{s_{\ell} - s_\ell^\prime}{c_\ell^\prime - c_\ell}$. Формально $\texttt{M}$ выполняется следующим образом.

\begin{enumerate}[(1)]
\item $\texttt{M}$ вводит набор публичных ключей запроса дискретного логарифма $S = \left\{\widetilde{pk}_i\right\}_{i=0}^{q-1}$.

\item $\texttt{M}$ разделяет ключи запроса на списки из $d$ ключей
\begin{align*}
pk_0 =&  (X_0, Z_{0, 1}, \ldots, Z_{0, d-1}) := (\widetilde{pk}_0, \ldots, \widetilde{pk}_{d-1}) \\
pk_1 =& (X_1, Z_{1, 1}, \ldots, Z_{1, d-1}) := (\widetilde{pk}_d, \ldots, \widetilde{pk}_{2d-1}) \\
\vdots
\end{align*} что позволяет получить $S := \left\{pk_i\right\}_{i=0}^{\left\lfloor \frac{q}{d}\right\rfloor}$.

\item $\texttt{M}$ выбирает две случайные последовательности $\textbf{h}, \textbf{h}^\prime$, чтобы смоделировать ответы на запросы оракула для $\mathcal{F}^{\B}$.

\item $\texttt{M}$ выполняет $\mathcal{F}^{\B}$ в чёрном ящике, используя $S$ в качестве входа. По получении повреждённого запроса от $\mathcal{F}^{\B}$ по некоторому $pk_i$ $\texttt{M}$ делает запрос $\texttt{CO}$ по $X_i$ и каждому $Z_{j,i}$, пропуская $sk_i$ обратно $\mathcal{F}^{\B}$. Каждый повреждённый запрос, сделанный $\mathcal{F}^{\B}$, состоит из $d$ повреждённых запросов, сделанных $\texttt{CO}$ алгоритмом $\texttt{M}$.

\item Если выполнение $\mathcal{F}^{\B}$ проходит неудачно или же выполнение $\mathcal{F}^{\B}$ успешно со всеми нулевыми коэффициентами $\mu_X$ и $\mu_j$, $\texttt{M}$ выбирает случайный $w \in \F$, выбирает случайный поднабор ключей запроса $\left\{pk^*_j\right\}_j \subseteq S$, выбирает случайные коэффициенты $\left\{h_j\right\}_j$, выводит $w, \left\{pk^*_j\right\}_j, \left\{h_j\right\}_j$ и завершает процесс.

\item В ином случае $\texttt{M}$ получает два тройных значения с одним и тем же сообщением и кольцом, $(m, Q, \sigma), (m, Q, \sigma^\prime)$, по крайней мере, с одним ненулевым коэффициентом агрегирования. $\texttt{M}$ вычисляет дискретный логарифм запроса $w = (c_\ell^\prime - c_\ell)^{-1}(s_\ell - s_\ell^\prime)$. $\texttt{M}$ выводит $w, \left\{\mu_X, \left\{\mu_j\right\}_j\right\}$ и $\left\{X_\ell, \left\{Z_{\ell, j}\right\}_j\right\}$.
\end{enumerate}

Обозначим как $t_1$ время, необходимое $\mathcal{M}$, чтобы проверить транскрипт, выполнить операции с полем и обработать запросы для $\mathcal{F}^{\B}$. Затем алгоритм $\texttt{M}$ выполняется за время, составляющее самое большее $2(t+t_0) + t_1$.

Чтобы закончить доказательство, рассмотрим общую вероятность успеха и время выполнения $\texttt{M}$. Поскольку $\A$ является $(t, \epsilon, q)$-алгоритмом решения задачи невозможности подделки  и это успешные подписи, должен быть по крайней мере один запрос, сделанный $\texttt{SO}$, соответствующий неповреждённому ключу запроса, связанному с этими подписями. В частности, $w \cdot G = W_\ell = \mu_X X_\ell + \sum_j \mu_j Z_{\ell,j}$ для некоторого $(X_\ell, \left\{Z_{\ell, j}\right\}_j) \in Q$. Алгоритм $\texttt{M}$ успешно решает задачу дискретного логарифмирования в линейных комбинациях всякий раз, когда $\mathcal{F}^{\B}$ успешно выполняет разветвление $\B$, и, по крайней мере, один коэффициент $\mu_X$ и $\mu_j$ является не нулём; мы обозначаем вероятность получения любого нулевого коэффициента как $\mu$. Следует отметить, что вероятность получения $\mu$ в рамках модели случайного оракула является незначительной. Таким образом, $\texttt{M}$ выполняется в течение времени, составляющего самое большее $2(t+t_0) + t_1$ и с вероятностью успешного выполнения выше $\epsilon\left(\frac{\epsilon}{q} - \frac{1}{2^\eta}\right) - \mu$.
\end{proof}

Доказательство Теоремы \ref{thm:nonsl} демонстрирует, что действительность тройного значения подразумевает, что агрегированный приватный ключ $w$ является дискретным логарифмом агрегированного связующего тега $\mathfrak{W}$ относительно $H_\ell$, а также дискретным логарифмом агрегированного ключа $W_\ell$ относительно $G$. Таким образом, связующий тег действительной подписи должен быть связующим тегом, соответствующим по крайней мере одному участнику кольца за исключением ничтожной вероятности.

\begin{corollary}[Отсутствие чужих связующих тегов]\label{cor:no-aliens}
Если существует PPT-алгоритм $\A$, выдающий тройное значение действительной подписи $(m, Q, \sigma)$ в рамках схемы, соответствующей Определению \ref{def:clsag}, значит, существует участник кольца в $Q$, чей агрегированный ключ $W_\ell$ имеет тот же дискретный логарифм $w$ относительно $G$, что $\mathfrak{W}$ имеет относительно $H_\ell$, и этот $w$ известен $\A$ (за исключением минимально возможной вероятности).
\end{corollary}

\begin{theorem}\label{thm:linkabilty}
Схема, представленная в Определении \ref{def:clsag}, является связываемой в соответствии с Определением \ref{def:acst-link-adv} и Определением \ref{def:pig-link}.
\end{theorem}

\begin{proof}
Мы демонстрируем, что тройное значение действительной не использующей оракула подписи, соответствующей Определению \ref{def:clsag} и условиям задачи повреждённого ключа из Определения \ref{def:acst-link-adv}, всегда связывается. Следовательно, любой алгоритм не сможет решить эту задачу, за исключением незначительной вероятности.

Предположим, что $\A$, решая задачу связываемости ACST из Определения \ref{def:acst-link-adv}, выдаёт такую пару тройных значений действительной, не использующей оракула подписи $(m, Q, \sigma)$, $(m^*, Q^*, \sigma^*)$, что по крайней мере один ключ в $Q \cup Q^*$ является повреждённым или находится за пределами $S$. Этот алгоритм может быть разветвлён  и выполнен заново, как описано выше, чтобы вычислить агрегированный приватный ключ, используемый при вычислении каждой подписи, скажем, $w, w^*$. Самое большее один ключ в $Q \cup Q^*$ является повреждённым или находится за пределами $S$. Поскольку $\A$ известен $w$, $w$ является повреждённым или находится за пределами $S$, и подобным образом $w^*$ также является повреждённым или находится за пределами $S$. Поскольку самое большее один ключ в $Q \cup Q^*$ может быть поврежденным или находиться за пределами $S$, мы делаем вывод, что $w = w^*$.

Поскольку агрегация ключей устойчива к конфликтам, а $wG$ является агрегированным публичным ключом для некоторого публичного ключа $(X_\ell, \left\{Z_{\ell, j}\right\}_j) \in Q \cap Q^*$, $w$ должен быть агрегирован из приватного ключа $(x_\ell, \left\{z_{\ell, j}\right\}_j)$ посредством устойчивой к конфликтам функции агрегирования. В обоих случаях связываемости, предполагающей использование одного ключа, и связываемости, предполагающей использование полного ключа, связующие теги являются совершено одинаковыми. Следовательно, с вероятностью, равной $1$, пара тройных значений $(m, Q, \sigma)$, $(m^*, Q^*, \sigma^*)$ являются связанными, и $\A$ не может решить задачу связываемости ACST, за исключением незначительной вероятности.

Подобным образом алгоритм, выдающий $q+1$ несвязанных подписей, может быть перезапущен для вычисления $2(q+1)$ подписей, на основе которых можно вычислить $q+1$ агрегированных ключей. Более того, если эти подписи являются несвязанными, значит, $q+1$ агрегированных ключей является раздельным, что нарушает схему связываемости по $q$ голубиных отверстий.
\end{proof}

\begin{theorem}
Если существует $(t,\epsilon,q)$-алгоритм решения задачи связываемой анонимности в соответствии с Определением \ref{linkable-anonymity-game} и конструкцией по Определению \ref{def:clsag}, то существует и $(t+t',\epsilon/2,q)$-алгоритм решения задачи RO-DDH в соответствии с Определением \ref{def:rom-ddh} для некоторого $t'$.
\end{theorem}

\begin{proof}
Допустим, $\A$ является таким алгоритмом решения задачи связываемой анонимности. Мы строим алгоритм $\B$, который будет выполнять алгоритм $\A$ в чёрном ящике и будет алгоритмом решения задачи RO-DDH, являясь при этом запросчиком для $\A$; алгоритм передаёт запросы случайного оракула $\Hp$ собственному запросчику, выбирает между запросами случайного оракула $\Hs_0$ и $\{\Hs_j\}$ и моделирует запросы подписывающего оракула путём обратной правки. Мы допускаем, что алгоритм $\B$ ведёт внутренние таблицы с целью обеспечения соответствия между запросами случайного оракула, необходимыми для моделирования запросов подписывающего оракула.

Алгоритм $\B$ выполняется следующим образом:
\begin{itemize}
\item Алгоритм $\B$ получает набор кортежей $\{(R_i,R_i',R_i'')\}_{i=0}^{q-1}$ от своего запросчика и единообразно случайным образом выбирает бит $b' \in \{0,1\}$. Следует отметить, что алгоритму $\B$ не известно, являются ли кортежи тройными значениями RO-DDH или нет, так как его запросчик, чтобы определить это, выбирает секретный бит $b \in \{0,1\}$ единообразно и случайным образом.
\item Для всех $i \in [0,q)$ $\B$ определяет $X_i := R_i$ и записывает распределение оракула $\Hp$ как $\Hp(X_i) = R_i'$. Алгоритм единообразно случайным образом выбирает $\{z_{i,j}\}_{j=1}^{d-1}$ из $\F$ и строит набор публичных ключей $S := \{(X_i, z_{i,1}G, \ldots, z_{i,d-1}G)\}_{i=0}^{q-1}$. $\B$ передаёт набор $S$ алгоритму $\A$.
\item Алгоритм $\A$ возвращает индексы $0 \leq i_0,i_1 < q$ алгоритму $\B$.
\item Алгоритм $\B$ получает запросы подписывающего оракула в форме \linebreak $\texttt{SO}(m,Q,pk)$, где $0 \leq \ell < q$ является индексом $pk \in Q$, $pk \in S$, а $|Q| = n$. Есть два случая, в которых алгоритм $\B$ моделирует ответ оракула, выбирая между запросами оракула $\Hs_0$ и $\{\Hs_j\}$:
\begin{itemize}
\item В том случае, если $\{pk_{i_0},pk_{i_1}\} \not\subset Q$ или $pk \not\in \{pk_{i_0},pk_{i_1}\}$, алгоритм $\B$ моделирует подписывающий оракул при помощи ключа $pk$.
\item В ином случае существует такой бит $c \in \{0,1\}$, что $pk = pk_{i_c}$. В этом случае $\B$ задаёт значение $c' := c \oplus b'$ и моделирует подписывающий оракул, используя ключ $pk_{i_{c'}}$. То есть, если $b' = 0$, алгоритм $\B$ моделирует подпись при помощи запрошенного ключа из набора индексов, предоставленных участником. Если же $b' = 1$, $\B$ моделирует подпись при помощи другого ключа.
\end{itemize}
В любом из случаев $\B$ разбирает набор публичных ключей $Q$, предоставленный алгоритмом $\A$. Для любого ключа $pk_i := (X_i',Z_{i,1}',\ldots,Z_{i,d-1}') \in Q \setminus S$ он передаёт запросы оракула своему запросчику, чтобы получить $\Hp(X_i')$. Затем $\B$ моделирует подпись:
\begin{itemize}
\item Определяет распределение $\pi: [0,n) \to [0,q) \cup \{\bot\}$ для индексов элементов $Q$ по соответствующим элементам $S$ (или возвращает выделенный символ сбоя $\bot$ для индексов, не распределённых по элементам $S$), делает $0 \leq \ell < n$ индексом $pk \in Q$.
\item Единообразно случайным образом выбирает $c_{\ell}, \{s_i\}_{i=0}^{n-1} \in \F$.
\item Поскольку в соответствии с конструкцией $pk \in S$, $\pi(\ell) \neq \bot$. Алгоритм задаёт такие значения $\mathfrak{T} := R_{\pi(\ell)}''$ и $\{\mathfrak{D}_j\}_{j=1}^{d-1}$, что каждый $\mathfrak{D}_j := z_{\pi(\ell),j}\Hp(X_{\pi(\ell)})$.
\item Определяет следующее:
\begin{align*}
\mu_X &\leftarrow \Hs_0(Q,\mathfrak{T},\{\mathfrak{D}_j\}) \\
\mu_j &\leftarrow \Hs_j(Q,\mathfrak{T},\{\mathfrak{D}_j\}) \text{ for } j \in (0,d) \\
\mathfrak{W}_i &:= \begin{cases} \mu_XX_{\pi(i)} + \sum_j \mu_jZ_{\pi(i),j} & (\pi(i) \neq \bot) \\ \mu_XX_i' + \sum_j \mu_jZ_{i,j}' & (\pi(i) = \bot) \end{cases} \\
W &:= \mu_X\mathfrak{T} + \sum_j \mu_j\mathfrak{D}_j
\end{align*}
\item Для каждого $i = \ell,\ell+1,\ldots,n-1,0,\ldots,\ell-1$ (то есть индекса по модулю $n$) определяет следующее:
\begin{align*}
L_i &:= s_iG + c_i\mathfrak{W}_i \\
R_i &:= \begin{cases} s_i\Hp(X_{\pi(i)}) + c_iW & (\pi(i) \neq \bot) \\ s_i\Hp(X_i') + c_iW & (\pi(i) = \bot) \end{cases} \\
c_{i+1} &\leftarrow \Hs_0(Q,m,L_i,R_i)
\end{align*}
\item Алгоритм $\B$ возвращает алгоритму $\A$ кортеж $(c_0,\{s_i\},\mathfrak{T},\{\mathfrak{D}_j\})$.
\end{itemize}
\item Алгоритм $\A$ возвращает алгоритму $\B$ бит $b^*$.
\item Если $b^* = b'$, $\B$ возвращает своему запросчику $0$. В ином случае возвращает $1$.
\end{itemize}

В этом случае алгоритм $\B$ точно решает задачу RO-DDH, когда он правильно угадывает бит $b$, выбранный его запросчиком. Следовательно, \linebreak $\prob[\B \text{ wins}] = \frac{1}{2}\prob[\B \to 0 | b = 0] + \frac{1}{2}\prob[\B \to 1 | b = 1]$.

Если $b = 1$, значит, запросчик RO-DDH предоставил случайные точки $\{R_i''\}$, которые $\B$ использовал в своих смоделированных подписях, и, таким образом, алгоритму $\A$ не остаётся ничего, кроме как случайно определить $b'$. Так как однозначно $\B \to 1$, если $\A$ не решает задачи анонимной связываемости, то мы получаем $\prob[\B \to 1 | b = 1] = \frac{1}{2}$.

С другой стороны, если $b = 0$, значит, запросчик RO-DDH предоставил структурированные кортежи, которые $\B$ использовал в своих смоделированных подписях, а алгоритм $\A$ успешно решил задачу связываемой анонимности с совсем не ничтожным преимуществом $\epsilon$ по случайному оракулу. Если однозначно $\B \to 0$, когда $\A$ решает задачу анонимной связываемости, мы получаем $\prob[\B \to 0 | b = 0] = \frac{1}{2} + \epsilon$.

Это означает, что алгоритм $\B$ решает задачу RO-DDH с вероятностью $\prob[\B \text{ wins}] = \frac{1}{2} + \frac{\epsilon}{2}$ и имеет совсем не ничтожное преимущество $\frac{\epsilon}{2}$. Далее, алгоритм $\B$ завершает выполнение за дополнительное время $t'$, необходимое для моделирования запросов оракула и выполнения поиска. Следовательно, алгоритм $\B$ является $(t+t',\epsilon/2,q)$-алгоритмом решения задачи RO-DDH.
\end{proof}


\section{Эффективность}\label{sec:efficiency}
Рассмотрим эффективность по необходимому пространству и времени в соответствии с Определением \ref{def:clsag}. Мы не учитываем какую-либо дополнительную информацию, которая обычно передаётся вместе с подписью, такую как представление участников кольца.

Подпись $d$-CLSAG с размером кольца, равным $n$, содержит $n+1$ поле элементов и $d$ элементов группы. Размером подписи является $k_s(n+1) + k_p d$, где $k_s$ описывает размер элементов поля, а $k_p$ описывает размер элементов группы.

Чтобы проверить сложность по времени верификации, допустим, что $t_s$ и $t_p$ обозначают временную сложность оценки функций хеширования до скалярных величин $\Hs$ и оценки функции хеширования до точки $\Hp$, соответственно. Допустим, $t^{(i)}$ является временной сложностью оценки линейной комбинации $i$ членов; при использовании специальных алгоритмов для мультискалярного умножения \cite{straus1964addition,pippenger1980evaluation} такая линейная комбинация может быть оценена гораздо быстрее, чем путём простого почленного вычисления. Следует отметить, что также можно кешировать множество групповых элементов, которые будут использоваться повторно при верификации, для более быстрой оценки линейной комбинации, но мы не выделяем эту возможность в данной работе. В итоге сложность верификации $d$-CLSAG составляет $(n+d)t_s + nt_p + 2nt^{(d+1)}$.

Чтобы провести сравнение с эффективностью варианта реализации \linebreak MLSAG, предложенного в работе \cite{noether2016ring}, отметим, что $2$-CLSAG  обладает той же функциональностью, что и  подпись MLSAG (которая является $2$-LRS). Подпись MLSAG, используемая таким образом, создаёт $2n+1$ элементов поля и $1$ элемент группы.

Нами был написан тест на C++ с использованием подгруппы \texttt{ed25519} порядка, равного простому числу, который мы использовали для оценки процесса подписания и верификации MLSAG и 2-CLSAG на 2,1 ГГц процессоре Opteron. В Таблице \ref{table:timing} приводятся результаты тестирования при различном размере кольца. В частности, следует отметить, что при меньшем размере анонимной группы $2$-CLSAG работала быстрее, чем MLSAG. Тем не менее при очень больших размерах колец MLSAG была быстрее из-за дополнительных вычислений, необходимых для вычисления коэффициентов агрегирования и добавления ключей. Несмотря на конечную неэффективность, хотелось бы отметить, что требования к линейному пространству в целом исключают возможность использования на практике колец большого размера, что делает схему $2$-CLSAG эффективным усовершенствованием MLSAG как с точки зрения пространства, так и с точки зрения времени.

\begin{table}[htp]
\begin{center}
\begin{tabular}{r|ll|ll}
& \multicolumn{2}{c|}{Верификация} & \multicolumn{2}{c}{Подписание} \\
\hline
Анонимная группа & MLSAG & CLSAG & MLSAG & CLSAG \\
\hline
2 & 2.4 & 2.0 & 2.3 & 2.7 \\
4 & 4.7 & 4.0 & 4.6 & 4.6 \\
8 & 9.5 & 7.8 & 9.4 & 8.5 \\
16 & 18.9 & 15.9 & 18.9 & 16.5 \\
32 & 37.8 & 32.3 & 37.8 & 33.0 \\
64 & 75.4 & 67.5 & 75.9 & 68.3 \\
128 & 150 & 147 & 151 & 148 \\
256 & 301 & 344 & 303 & 346
\end{tabular}
\end{center}
\caption{Время подписания и верификации (мсек) при использовании схем MLSAG и $2$-CLSAG}
\label{table:timing}
\end{table}

\bibliographystyle{splncs04}
\bibliography{bibliography}

\end{document}