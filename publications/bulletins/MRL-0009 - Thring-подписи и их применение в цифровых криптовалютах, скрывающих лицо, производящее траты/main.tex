\documentclass{mrl}
\usepackage[utf8x]{inputenc}
\usepackage[T2A]{fontenc}
\usepackage[english, russian]{babel}
\usepackage{amsmath}
\usepackage{enumerate}
\usepackage{todonotes}
\usepackage{comment}
\theoremstyle{definition}
\newtheorem{theorem}{Теорема}
\numberwithin{theorem}{subsection}
\newtheorem{lemma}[theorem]{Лемма}
\newtheorem{cor}[theorem]{Следствие}
\newtheorem{defn}[theorem]{Определение}
\newtheorem{disc}[theorem]{Примечание}
\newtheorem{ex}[theorem]{Пример}
\newcommand{\adversary}{\mathcal{A}}
\newcommand{\scalarField}{\mathbb{Z}_{\mathfrak{p}}}
\newcommand{\bbz}{\mathbb{Z}}
\newcommand{\bbn}{\mathbb{N}}
\newcommand{\group}{\mathbb{G}}
\newcommand{\p}{\mathfrak{p}}
\newcommand{\m}{\mathfrak{m}}
\newcommand{\reduxChain}{\adversary \leadsto \adversary^\prime \leadsto \texttt{fork}^{\adversary^\prime} \leadsto \adversary^{\prime \prime} \leadsto \texttt{fork}^{\adversary^{\prime \prime}} \leadsto \mathcal{B}}
\renewcommand{\thefootnote}{\arabic{footnote}}
%\usepackage{algpseudocode}
\usepackage[boxed]{algorithm2e}
\usepackage{graphicx}
\graphicspath{ {images/} }
\usepackage{caption}
\usepackage{subcaption}
\usepackage{enumitem}
\usepackage{amssymb}
\usepackage{xypic}
\usepackage{url}

\usepackage[boxed]{algorithm2e}
\usepackage{graphicx}
\graphicspath{ {images/} }
\usepackage{caption}
\usepackage{subcaption}
\usepackage{enumitem}
\usepackage{amssymb}
\usepackage{xypic}
\usepackage{url}

\title{Thring-подписи и их применение в цифровых криптовалютах, скрывающих лицо, производящее траты}
\authors{Брэндон Гуделл (Brandon Goodell)\footnote{\texttt{surae.noether@protonmail.com}}, Саранг Ноезер (Sarang Noether)\footnote{\texttt{sarang.noether@protonmail.com}}}
\affiliations{Исследовательская лаборатория Monero (Monero Research Lab)}
\date{1 ноября 2018}

\type{ИССЛЕДОВАТЕЛЬСКИЙ БЮЛЛЕТЕНЬ}
\ident{MRL-0009}

\begin{document}

\begin{center}
{\bfАннотация}
\end{center}

В этой работе нами предлагаются пороговые кольцевые подписи (thring-подписи) для совместного вычисления кольцевых подписей, а также рассматривается возможность и осуществимость подделки thring-подписей и их применение в цифровых валютах, в частности, атомные свопы между блокчейнами с сокрытием лица, осуществляющего трату, с обеспечением конфиденциальности сумм без доверенных настроек. Также в работе нами представлен вариант реализации thring-подписей, называемый нами связываемыми спонтанными пороговыми анонимными групповыми подписями, а также приводится доказательство того, что такие подписи экзистенциально невозможно подделать.

\section{Введение}

Криптовалюты и схемы реализации электронных денег в значительной степени опираются на цифровые подписи, исключающие возможность подделки, и существует множество вариантов использования пороговых подписей при таких настройках, начиная с многофакторной аутентификации при утверждении транзакций и заканчивая атомными свопами между блокчейнами. Идея проста: группа взаимодействующих пользователей принимает решение относительно порогового значения, и некоторые из членов группы могут совместно вычислить подписи, но только при условии, что согласится такое количество членов группы, которое будет превышать установленный порог. Изначально для создания подписей Bitcoin использовал алгоритм ECDSA на базе secp256k1, но этот способ не является единственным вариантом для разработчиков криптовалют. Позже популярными стали подписи Шнорра \cite{schnorr1991efficient}, функциональность которых была выше, включая использование пороговых мультиподписей, представленных в работе \cite{maxwell2018simple}. Также исследовалась возможность использования подписей Окамото \cite{okamoto1992provably} в мультиподписях в криптовалютах \cite{drijvers2018okamoto}. Также существуют другие варианты, такие как кольцевые подписи \cite{liu2004linkable} или аккумуляторы типа Zerocoin \cite{miers2013zerocoin} , предполагающие аутентификацию сообщений с сокрытием отправляющей стороны, когда верификаторы могут проверить, было ли сообщение аутентифицировано членом анонимной группы. При этом сохраняется незначительное преимущество в определении того, какой именно из членов сделал это.

В случае с криптовалютами аутентификация сообщений с сокрытием лица, \textit{являющегося отправителем}, необходима для обеспечения неопределённости лица, являющегося отправителем. Мы интерпретируем такую неопределённость как свойство, касающееся правдоподобного отрицания в истории транзакций: финансовые системы, использующие эти опции, позволяют поддерживать публично верифицируемые реестры, и при этом пользователи могут по крайней мере правдоподобно отрицать своё участие в какой-либо транзакции (или в их небольшой группе). Поэтому вполне естественно было бы исследовать пороговое расширение таким схемам аутентификации сообщений с сокрытием отправителя, как кольцевые подписи. Эти кольцевые подписи также могут быть использованы для построения кольцевых конфиденциальных транзакций в контексте цифровой валюты. Функциональность мультиподписей применительно к цифровой валюте также позволяет, например, производить атомные свопы между блокчейнами. Следовательно, схема пороговой кольцевой подписи позволяет проводить атомные свопы между блокчейнами с сокрытием лица, совершающего трату, для обеспечения конфиденциальности сумм без доверенных настроек.

Мы называем пороговые кольцевые подписи \textit{thring-подписями}. Предыдущие предложенные варианты реализации thring-подписей (как, например, в работах \cite{bresson2002threshold}, \cite{liu2003separable}, \cite{tsang2004separable}) предполагали утечку информации (вскрывались свойства подписывающей группы, такие как количество подписантов, или даже публиковался список публичных ключей, использованных для подписи, с самими подписями) или же вычисление ключей, подобно тому как это показано в работе \cite{bellare2006multi}, что делало такие схемы уязвимыми для атак, направленных на кражу ключей. Поэтому мы считаем, что такие предложенные варианты не подходят для использования в случае цифровыми валютами, ориентированными на обеспечение анонимности.

Нами был разработан свой вариант реализации thring-подписи, использующий подход, подобный Musig, применительно к связываемым спонтанным групповым (LSAG) подписям, о которых говорится в работе \cite{liu2004linkable}, с учётом изменений, представленных в работах \cite{backLSAG} и \cite{noether2016ring} и предназначенных для применения в цифровых валютах. Подход Musig, описанный в работе \cite{maxwell2018simple}, предполагает накопление ключей в совокупности с применением подхода, который впервые был предложен в работе \cite{qian2010non} и который является устойчивым к атакам, направленным на кражу ключей. Как обычно, в случае со схемами мультиподписей, мы заменяем произвольные данные, используемые для подписания, суммами данных, выбранных участниками, которые раскрываются на этапе совершения и раскрытия. И наконец, как и в случае с Musig, мы включаем ключи подписания в задачу вычисления подписи, что не даёт запросам оракула в доказательстве экзистенциальной невозможности подделки происходить в неверном порядке.

\subsection{Наш вклад}

Нами предлагается схема LSTAG-подписи, напоминающая мультиподписи Musig, описанные в работе \cite{maxwell2018simple}, и являющаяся версией LSAG-подписей с заданным порогом. Нами даётся определение экзистенциальной невозможности подделки в параметрах кольцевых подписей и приводится доказательство того, что схема безопасна при таком определении. Нами также отмечается разница между нашей схемой и фиктивными вариантами применения с криптовалютами.

Предлагаемая нами схема имеет структуру $n$ из $n$, но мы можем расширить её до структуры пороговых схем $m$ из $n$, воспользовавшись стандартными методами, и даже до многоуровневой схемы для использования в кольцевых конфиденциальных транзакциях. Схема предполагает накопление ключей в том смысле, что верификация подписи не требует знания порогового значения подписания. Размер подписей не зависит от количества участвующих подписантов. Доказательство безопасности соответствует простой модели публичных ключей. Нами используется тот же самый процесс Musig, включающий в себя три этапа, а верификация подписей происходит идентично тому, как это происходит в случае с подписями LSAG.

В Разделе \ref{notation} мы разъясняем наши понятия, допуски и прочие необходимые условия. В Разделе \ref{motivation} мы в общих чертах рассказываем о том, как подписи LSAG в настоящее время работают в Monero, как применить к ним эвристический подход к определению порогового значения Musig, чтобы получить LSTAG, а также как использовать подписи LSTAG в кольцевых конфиденциальных транзакциях. В Разделе \ref{schemeAndImp} нами даётся определение подписей LSTAG и приводится пример их реализации. В Разделе \ref{security} мы рассказываем о защите LSTAG-подписей от подделки, приводим доказательства безопасности варианта реализации из Раздела \ref{schemeAndImp} при таком определении. Нами также рассматривается связываемость, оправданность, неопределённость подписанта, а также неразличимость накапливаемых ключей.


\subsection{Связанные работы и задачи}

Впервые LSAG-подписи были описаны в работе \cite{liu2004linkable}; изменения были предложены в работе \cite{backLSAG}.
Конфиденциальные транзакции применительно к цифровым валютам были впервые описаны в работе \cite{maxwell2015confidential}, а в работе \cite{noether2016ring} были в первый раз описаны расширения кольцевых подписей конфиденциальных транзакций, использующие расширения по вектору ключей LSAG-подписей, называемые многоуровневыми связываемыми спонтанными анонимными групповыми (MLSAG) подписями. Для вычисления мультиподписей мы обычно используем подход, описанный в работе \cite{bellare2006multi}, применяя при этом схему накопления ключей в стиле Musig, описанную в работе \cite{qian2010non}, а также подход, предполагающий обязательство с последующим раскрытием (commit-reveal), из работы \cite{maxwell2018simple}. Наше доказательство невозможности подделки, подобное описанному в работе \cite{maxwell2018simple}, использует двойное применение метода реализации форка «обратной перемоткой» по успешному транскрипту (rewind-on-success forking) (впервые чётко был представлен в работе \cite{liu2004linkable}).

Доступны и другие технологии использования мультиподписей, особенно в случае с попарным соединением и обучением с ошибками. Возьмём, например, работу \cite{bonehthreshold}, где описан новый и довольно общий гомоморфный метод настройки порогового значения, при котором используется только один сеанс связи в среде обучения с ошибками, позволяющий создавать полностью гомоморфные пороговые подписи и шифрование. Совсем недавно в работе \cite{bonehcompact} было описано применение настроек на базе попарного соединения, позволяющих создавать компактные мультиподписи с крайне полезными свойствами.

Следует отметить, что эвристический подход к определению порогового значения, описанный в работе \cite{bellare2006multi}, предлагает реализацию общей схемы мультиподписей в рамках простой модели публичных ключей. Также в этой работе был подробно рассмотрен допуск знания секретного ключа (KOSK). Стоит отметить проблемы, возникшие с практичностью и безопасностью реализации схем, безопасность которых была доказана при настройках KOSK с использованием доказательств владения секретными ключами при отсутствии специальных мер предосторожности (см., например, работу \cite{ristenpart2007power}). Поэтому мы избегаем допуска KOSK, несмотря на то, что доказательства безопасности для таких схем, как наша, гораздо проще настроек KOSK с доказательствами владения, заменяющими сертифицирующий орган. В работе \cite{qian2010non} представлен не использующий KOSK метод агрегации совместно используемого публичного ключа мультиподписи, который мы используем в данной работе. Такой метод устойчив к атакам, направленным на кражу ключей (хотя он и использует настройки, основанные на попарном объединении). Ранняя версия Musig подразумевала один сеанс связи, который был позднее заменён на этап обязательства и раскрытия для подписания. Безусловно, в работе \cite{drijvers2018okamoto} было продемонстрировано, что возможность доказательства безопасности схемы подписи подобной Musig за один сеанс связи маловероятна при допуске сложности дискретного логарифма.

Чтобы данные thring-подписи можно было использовать с цифровыми валютами в кольцевых конфиденциальных транзакциях, они должны быть расширены. Например, применительно к цифровым валютам, использующим (некоторый вариант) протокола CryptoNote, таким как Monero, реализация должна учитывать векторы пар ключей, включая ключ просмотра в дополнение к ключу траты/подписания, а также должна учитывать вычисления одноразового ключа. Доказательство безопасности нашей схемы при условии такого расширения находится вне области применения данного документа. Более подробно кольцевые конфиденциальные транзакции и кольцевые пороговые подписи формализованы, например, в работе \cite{ruffct2}.

\subsection{Особая благодарность}

Нам хотелось бы выразить особую благодарность членам сообщества Monero, которые воспользовались Системой общественного финансирования на \texttt{GetMonero.org}, чтобы поддержать Исследовательскую лабораторию Monero. Читатель также может рассматривать это как заявление конфликта интересов, так как наше финансирование осуществляется в Monero напрямую членами сообщества через Систему общественного финансирования. Нам также, в частности, хотелось бы поблагодарить Эндрю Поэлстра (Andrew Poelstra) и Яника Сюрина (Yannick Seurin), а также многих других за крайне полезные комментарии.

\section{Обозначения и допуски}\label{notation}

%For any set $S$, we denote with $S^*$ the set of all finite sequences of letters from $S$ (the free monoid generated by $S$ over $\mathbb{N}$).
В основном, мы используем каллиграфический шрифт для обозначения алгоритмов PPT и оракулов: $\adversary, \adversary^\prime, \adversary^{\prime \prime}, \mathcal{B}$ являются алгоритмами PPT, $\mathcal{H}$ является случайным оракулом, а $\mathcal{SO}$ является оракулом подписания. Мы часто даём оракулу алгоритмический доступ, что обозначается верхним индексом: $\mathcal{A}^{\mathcal{SO}}$ означает, что у $\mathcal{A}$ есть доступ оракула к $\mathcal{SO}$. Мы часто оставляем верхние индексы скрытыми для ясности, за исключением случаев, когда это может ввести в заблуждение. Мы используем \texttt{шрифт teletype} чтобы описать входные и выходные данные алгоритмов или же названия специальных алгоритмов криптографической схемы: $\texttt{inp}_\adversary$ обозначает входные данные $\adversary$, $\texttt{out}_\adversary$ обозначает выходные данные, $\texttt{Sign}$ является алгоритмом подписания в нашем варианте реализации и так далее. Алгоритмы часто сопровождаются символом отрицательного результата (или набором из таких символов), что обозначается нами как $\bot$: $\bot_\adversary$ является символом отрицательного результата для $\adversary$, $\bot_{\texttt{Sign}}$ является символом отрицательного результата для $\texttt{Sign}$ и так далее.

Мы используем строчные английские и греческие буквы для обозначения целых чисел: $n, r, q, \ell, i, j, k, \linebreak \alpha, \eta$ - все принадлежат $\bbn$. Для любого $r \in \bbn = \left\{1, 2, \ldots\right\}$мы указываем ряд элементов $r$ $\left\{1, 2, \ldots, r\right\}$ как $\left[r\right]$. Мы используем подчёркивание, чтобы обозначить векторы, упорядоченные списки, последовательности, а также множества, проиндексированные вполне упорядоченными индексирующими множествами. Например, в случае с неупорядоченным списком независимых случайных оракулов $\underline{H}$, проиндексированным некоторым произвольным конечным множеством $\Lambda$ где $n = \left|\Lambda\right|$ элементов, мы можем безопасно переиндексировать и допустить, что $\Lambda = [n]$, и записать $\underline{\mathcal{H}} = \left\{\mathcal{H}_i\right\}_{i \in [n]}$.

Для любого $n > 1$ мы обозначаем $\bbz/n\bbz$ как $\bbz_n$. Мы допускаем, что перед началом этап настройки производится с безопасным параметром $\eta > 1$, и в результате получается некоторое $(\p, \group, G, \underline{\mathcal{H}}, \phi, \Phi)$, а именно циклическая группа $\group$ порядка $\p$ с генератором $G$, где элементы $\bbz_\p$ и $\mathbb{G}$ допускают $\eta$-битные представления, последовательность $\underline{\mathcal{H}}$ криптографических хеш-функций, а также две функции агрегирования ключей $\phi, \Phi$. Мы называем элемент $\group$ \textit{публичным ключом} и применяем это обозначение во всём документе, используя заглавные английские буквы. Например, $A, B, C, T, P, X$ являются публичными ключами, а $\underline{P} = \left\{P_\ell \right\}_{\ell \in [r]}$ обозначает последовательность из $r$ публичных ключей. Мы называем такую последовательность \textit{кольцом}, если она будет использоваться в качестве входа в кольцевой подписи. Для вычисления кольцевых подписей с членами кольца $r \in \bbn, r > 1$ мы допускаем «обёртывание» индексов из $[r]$путём идентификации индекса кольца $r+1$ индексом кольца $1$. Мы используем такое правило только для индексов членов кольца, но не для каких-либо других индексов.

Мы называем членов $\scalarField$ \textit{приватными ключами}. Так как это классы эквивалентности целых чисел, мы также используем прописные английские буквы для обозначения этих приватных ключей, но не тех, которые использовались для целых чисел: $a$, $b$, $t$, $p$ и $x$ являются приватными ключами $\scalarField$. Мы называем некоторый $X \in \group$ публичным ключом, \textit{связанным} с некоторым приватным ключом $x \in \scalarField$ если $X = xG$ для генератора $G$, указанного выше, и мы подбираем соответствующие буквы: публичный ключ, связанный с приватным ключом $a$, обозначается как $A = aG$, публичный ключ, связанный с приватным ключом $b$ обозначается как $B = bG$, и так далее. В случае со списком приватных ключей, скажем, $\underline{x} = (x_1, \ldots, x_n)$, мы записываем список соответствующих публичных ключей как $\underline{X} = (X_1, \ldots, X_n)$, где каждый $X_i = x_i G$. Мы обозначаем это как $\underline{X} = \underline{x}G$ с риском неправильного использования обозначения.

Мы используем правило, согласно которому $\phi(x, \left\{X\right\}) = x$ и $\Phi(\left\{X\right\}) = X$. В данном случае $\Phi$ в качестве входа берёт непустое мультимножество публичных ключей $\underline{X} = (X_1, \ldots, X_n)$ и в качестве выхода выдаёт совместно используемый публичный ключ $X_{\text{sh}} \leftarrow \Phi(\underline{X})$, а $\phi$ в качестве входа берёт приватный ключ $x_i$ с непустым мультимножеством публичных ключей $\underline{X}$ (чтобы по крайней мере единожды в $\underline{X}$ было $X_i = x_iG$) и в качестве выхода выдаёт коэффициент $\beta_i = \phi(x_i, \underline{X})$. Пользователи устанавливают свою приватную совместно используемую часть как $x_i^* := \beta_i x_i = \phi(x_i, \underline{X}) x_i$. Мы говорим, что $X_{\text{sh}}$ is \textit{связано} или \textit{является дочерним элементом} ключей в $\underline{X}$ и используем \[\Phi(\underline{X}) := \sum_{i \in [n]} \beta_i X_i = \sum_i x_i^* G = X_{\text{sh}}.\]

Мы указываем $\underline{\mathcal{H}}$, шесть входов произвольной длины, криптографические хеш-функции $\eta$-битного выхода с независимыми выходами
\begin{align*}
\mathcal{H}_{\text{ki}}:& \left\{0,1\right\}^* \to \group & \mathcal{H}_{\text{com}}:& \left\{0,1\right\}^* \to \left\{0,1\right\}^\eta & \mathcal{H}_{\text{agg}}:& \left\{0,1\right\}^* \to \scalarField \\ \mathcal{H}_{\text{sig}}:& \left\{0,1\right\}^* \to \scalarField &
\mathcal{H}_{\text{msg}}:& \left\{0,1\right\}^* \to \scalarField &
\mathcal{H}_{\text{sess}}:& \left\{0,1\right\}^* \to \scalarField
\end{align*} в соответствии с моделью случайного оракула. Мы обозначаем связь битовых строк символом $\mid \mid$. Так как элементы $\scalarField$ могут быть описаны $\eta$ бит, мы также можем взять $\mathcal{H}_{\text{agg}}$, $\mathcal{H}_{\text{sig}}$, $\mathcal{H}_{\text{com}}$, $\mathcal{H}_{\text{msg}}$ и $\mathcal{H}_{\text{sess}}$ для всех пяти в одной и той же кообласти. Таким образом, в целях реализации эти хеш-функции могут быть реализованы одной хеш-функцией $\mathcal{H}_{\text{sc}}:\left\{0,1\right\}^* \to \scalarField$ с использованием доменного разделения:

\begin{align*}
\mathcal{H}_{\text{com}}(x) :=& \mathcal{H}_{\text{sc}}(000 \mid \mid x)\\
\mathcal{H}_{\text{agg}}(x) :=& \mathcal{H}_{\text{sc}}(001 \mid \mid x) \\
\mathcal{H}_{\text{sig}}(x) :=& \mathcal{H}_{\text{sc}}(010\mid \mid x) \\
\mathcal{H}_{\text{msg}}(x) :=& \mathcal{H}_{\text{sc}}(011\mid \mid x) \\
\mathcal{H}_{\text{sess}}(x) :=& \mathcal{H}_{\text{sc}}(111\mid \mid x)
\end{align*} Это позволяет использовать для реализации только две хеш-функции, $\mathcal{H}_{\text{ki}}$ и $\mathcal{H}_{\text{sc}}$. Также в первом примере мы используем только $\mathcal{H}_{\text{sess}}$; наш вариант реализации позволяет использовать только первые четыре варианта $\mathcal{H}_{sc}$ и требует только двух битов префиксов. Следует отметить, что несмотря на то, что у каждой из этих функции будут $\eta$--битные выходы, эффективность их энтропии фактически будет ниже из-за этого доменного разделения. %\footnote{NOTE: I don't think it's a full 3 bits lower, though...}.

Безусловно, если $\mathcal{H}_{\text{ki}}$ можно разбить на некоторые $\mathcal{H}_{\text{ki}} = \mu_G \cdot \mathcal{H}_{\text{ki}}^*$ для некоторых $\mathcal{H}_{\text{ki}}^*:\left\{0,1\right\}^* \to \scalarField$ (где $\mu_G: \scalarField \to \group$ является каноническим необратимым гомоморфизмом, определяемым соответствием $x \mapsto xG$), то любой, кто узнает об этом разбиении $\mathcal{H}_{\text{ki}}$, сможет вычислить дискретный логарифм выходов $\mathcal{H}_{\text{ki}}$, что является крайне нежелательным свойством. Мы допускаем, что такое разбиение вычислить непросто.

%We take the message space to be the free monoid generated by the set $\left\{0,1\right\}$ with the operation of string concatenation, which we denote $\left\{0,1\right\}^*$. Instead of signing an arbitrary message $\m \in \left\{0,1\right\}^*$, which lives in a space much bigger than $\group$, we instead produce a signature on a $\scalarField$ element $M = \mathcal{H}(\m)$ for some collision resistant hash function $\mathcal{H}:\left\{0,1\right\}^* \to \scalarField$. As before, we implement this $\mathcal{H}$ using domain separation by defining $\mathcal{H}(\m) := \mathcal{H}_{\text{sc}}(11 \mid \mid \m)$, but since we never use $\m$ directly, we never actually make use of this fact. In the sequel, we forget about $\m$ and deal merely wtih $M$, assuming messages $M$ are elements from $\scalarField$.

\section{Обоснование схемы}\label{motivation}

В этом разделе мы обоснуем нашу схему пороговой кольцевой подписи. Мы начнём с общего описания, как вычисляются традиционные LSAG-подписи при помощи пространств ключей типа CryptoNote. Затем мы опишем эвристические принципы определения порогов для построения нашего варианта реализации, а после этого кратко прокомментируем применение этих подписей в Monero. %In future sections, we define our approach formally and demonstrate the unforgeability of these signatures.

\subsection{Традиционные LSAG-подписи}\label{lsagFirst}

В этом разделе мы кратко рассмотрим, как подписи работают в цифровых валютах на базе протокола CryptoNote, таких как Monero. В подписях, описанных в работе \cite{liu2004linkable}, используются образы ключей, зависящие от кольца подписантов, что делает их неподходящими с точки зрения связываемости в нашем контексте. В работе \cite{backLSAG} была представлена модификация, которую мы кратко описываем в этой работе. Наше описание использует четыре криптографические хеш-функции, смоделированные как случайные оракулы $\mathcal{H}_{\text{sess}}$, $\mathcal{H}_{\text{sig}}$, $\mathcal{H}_{\text{ki}}$ и $\mathcal{H}_{\text{msg}}$.

Рассмотрим сначала пространства ключей Monero, основанные на протоколе CryptoNote. У пользователей имеются \textit{пары ключей} (включающие в себя \textit{ключ просмотра} и \textit{ключ траты}), а для подписания транзакций они используют \textit{пары ключей подписания} (включающие в себя \textit{ключ транзакции} и \textit{ключ сессии} [или же, как вариант, \textit{одноразовый ключ} или \textit{скрытый ключ}]). Ключи сессии вычисляются на основе пар пользовательских пар ключей и ключей транзакции; кольцевые подписи вычисляются при помощи ключей сессии. Становится доступным характерное пространство ключей, $\mathfrak{K} = \scalarField^2 \times \group^2$, а оба вида пар ключей выводятся на основе $\mathfrak{K}$.

Пользовательская пара ключей обозначается как $((a,b),(A,B)) \in \mathfrak{K}$, где $a$ является \textit{приватным ключом просмотра}, $b$ обозначает \textit{приватный ключ траты}, $A$ является \textit{публичным ключом просмотра}, а $B$ - \textit{публичным ключом траты}. Честные пользователи выбирают свои приватные ключи единообразно и в случайном порядке. Пара ключей подписания обозначается как $((t,p),(T,P)) \in \mathfrak{K}$, где $t$ является \textit{приватным ключом транзакции}, $p$ - \textit{приватным ключом сессии}, $T$ - \textit{публичным ключом транзакции}, а $P$ обозначает \textit{публичный ключ сессии}. Честные пользователи получают публичную часть их ключа транзакции $T$ от отправителя. В случае с Monero мы говорим, что пара публичных ключей подписания $(T,P)$ с индексом $i$ в некоторой транзакции \textit{адресована} паре публичных пользовательских ключей $(A,B)$, если $P = \mathcal{H}_{\text{sess}}(aT, i)G + B$. При известных $T, a, B, i$ или $t, A, B, i$ владение ключом сессии может быть легко проверено следующим образом: просто необходимо убедиться в том, что $P - \mathcal{H}_{\text{sess}}(aT, i) = B$. При известных $T, a, b, i$ или известных $t, A, b, i$ приватный ключ сессии вычисляется как $p = \mathcal{H}_{\text{sess}}(aT, i) + b$. Далее мы «забываем» индекс транзакции $i$ для простоты представления.

Если у Элис есть пользовательский ключ $((a,b),(A,B)) \in \mathfrak{K}$, и она ранее получила сообщение, содержащее некоторые публичные ключи подписания $(T, P)$ адресованные $(A,B)$, и Элис хочет адресовать некоторые ключи Бобу (у которого есть публичный пользовательский ключ $(A^{\prime}, B^{\prime})$), то Элис вычисляет $p$, берёт новый приватный ключ транзакции $t^{\prime} \leftarrow \scalarField$ и вычисляет новый публичный ключ сессии $P^{\prime} := \mathcal{H}_{\text{sess}}(t^{\prime} A^{\prime})G + B^\prime$ для Боба. Затем Элис отправляет $(T^{\prime}, P^{\prime})$ Бобу в сообщении $\m$, а затем создаёт кольцевую подпись $\sigma$ в изменённом сообщении $\m^*$ содержащем $\m$ и некоторое кольцо $\underline{P}$ таким образом, чтобы $P \in \underline{P}$. Элис вычисляет кольцевую подпись следующим образом.

Элис выбирает сообщение $\m \in \left\{0,1\right\}^*$, вычисляет свой образ одноразового ключа $J = p\mathcal{H}_{\text{ki}}(P)$ и выбирает кольцо публичных ключей подписания $\underline{P}=\left\{P_1, \ldots P_r\right\}$ таким образом, чтобы для секретного выделенного индекса $\pi$, выполнялось условие $P_{\pi}=P$. Элис собирает модифицированное сообщение $\m^* = (\m, \underline{P}, J, T^{\prime}, P^{\prime})$ и вычисляет $M = \mathcal{H}(\m^*)$. Для каждого $\ell=1,\ldots,r$ подписант вычисляет точку на эллиптической кривой на основе $\ell^{th}$ члена кольца $H_\ell := \mathcal{H}_{\text{ki}}(P_\ell)$. Подписант выбирает случайную секретную скалярную величину $u \overset{\$}{\leftarrow} \scalarField$ и вычисляет начальную временную пару точек $L_{\pi} := uG$, $R_{\pi} := u\mathcal{H}_{\pi}$. Подписант вычисляет начальное обязательство $c_{\pi+1} := \mathcal{H}_{\text{sig}}(M,L_{\pi}, R_{\pi})$. Позднее мы будем использовать вариант этого обязательства с \textit{префиксом из ключа} $c_{\pi+1} := \mathcal{H}_{\text{sig}}(M,P_\pi, L_{\pi}, R_{\pi})$

Подписант продолжает работу с индексами $\ell=\pi+1, \pi+2, \ldots, r-1, r, 1, 2, \ldots, \pi-1$, выбирая случайную скалярную величину $s_\ell$, вычисляя следующую пару точек $L_\ell := s_\ell G + c_\ell P_\ell$ и $R_\ell := s_\ell H_\ell + c_\ell J$, и вычисляет следующее обязательство $c_{\ell+1}:=\mathcal{H}_{\text{sig}}(M,L_\ell, R_\ell)$ (или вариант с префиксом из ключа $c_{\ell+1}:=\mathcal{H}_{\text{sig}}(M,P_\ell, L_\ell, R_\ell)$). Как только все обязательства $c_\ell$ будут вычислены, подписант приступит к вычислению $s_{\pi} := u - c_{\pi}p$ для следующего выделенного индекса $\pi$. $\sigma=(c_1, \underline{s})$ является подписью в сообщении $\m$. Элис отправляет $(\m^*, \sigma)$ Бобу. Мы называем ряд уравнений \begin{align*}
c_2 =& \mathcal{H}_{\text{sig}}(M, s_1 G + c_1 P_1, s_1 H_1 + c_1 J) = \mathcal{H}_{\text{sig}}(M, L_1, R_1)\\
c_3 =& \mathcal{H}_{\text{sig}}(M, L_2, R_2)\\
& \vdots \\
c_r =& \mathcal{H}_{\text{sig}}(M, L_{r-1}, R_{r-1})\\
c_1 =& \mathcal{H}_{\text{sig}}(M, L_r, R_r)
\end{align*} (или их вариантов с префиксами из ключей) \textit{верификационными уравнениями}.

После получения $(\m^*, \sigma)$ Боб проводит анализ $\m^* = (\m, \underline{P}, J, (T^\prime, P^\prime))$ и проверяет, чтобы $M = \mathcal{H}(\m^*)$. Боб может легко проверить, действительно ли $P^{\prime} - \mathcal{H}_{\text{sess}}(a^\prime T^\prime)G = B^\prime$, чтобы увидеть, является ли он адресатом этих ключей. Боб также может выделить приватный ключ подписания, вычислив $p^\prime = \mathcal{H}_{\text{sess}}(a^\prime T^\prime) + b^\prime$. Таким образом, Боб может провести ту же процедуру, что и Элис выше, чтобы передать новые ключи подписания другим пользователям. Тем не мене Боб не может быть уверен в том, что подпись является подлинной, поэтому он верифицирует подпись следующим образом.

При известном $(\m^*, \sigma)$ верификатор проводит анализ $\sigma = (c_1, \underline{s})$ и вычисляет $M = \mathcal{H}(\m^*)$. Верификатор вычисляет каждого $H_\ell = \mathcal{H}_{\text{ki}}(P_\ell)$. Для каждого $1 \leq \ell \leq r$ верификатор находит $L_{\ell}^{\prime} = s_\ell G + c_\ell P_\ell$, $R_{\ell}^{\prime} = s_\ell H_\ell + c_\ell J$. Верификатор использует это для вычисления $(\ell+1)^{th}$ обязательства $c_{\ell+1} = \mathcal{H}_{\text{sig}}(M, L_{\ell}^{\prime}, R_{\ell}^{\prime})$. После вычисления $\underline{c} = (c_2, c_3, \ldots, c_r, c_{r+1})$ верификатор указывает индекс $r+1$ с индексом $1$ и проверяет, чтобы $c_{r+1} = c_1$. Если это так, то верификатор убеждается в том, что подпись является подлинной. Верификатор может проверить, подписаны или нет две подписи одним и тем же ключом, просто сравнив два образа ключей.

\subsection{Определение порогового значения для обратных LSAG-подписей с накоплением ключей в стиле Musig} \label{naiveImplement}

В данном разделе Элис и Боб хотят общими усилиями построить версию LSAG-подписи с порогом $2$ из $2$, чтобы отправить ключ Шарлин. Подписи верифицируются точно так же, как и раньше, то есть не известно, были ли они созданы группой или единственным пользователем. Мы продолжаем подобно тому, как делали до этого, внося изменения в соответствии со следующими эвристическими процедурами.
\begin{description}
\item [Ключи являются суммами:] Ключи траты заменяются линейными комбинациями долей ключей траты.

\item [Данные подписания являются суммами:] Данные подписания (случайные) заменяются суммами.

\item [Обязательство и раскрытие:] Перед раскрытием данных подписания появляется этап обязательства.

\item [Создание префиксов из ключей:] Добавление члена кольца в каждый вызов подписи.
\end{description}

В Musig функцией накопления ключей является $\phi(b_i, (\underline{A},\underline{B})) := \mathcal{H}_{\text{agg}}(B_i, (\underline{A}, \underline{B}))$. Следует отметить, что вычисление $\phi(b_i, (\underline{A}, \underline{B}))$ не требует секрета $b_i$. Элис берёт новый приватный пользовательский ключ $(a_1, b_1)$, вычисляет публичный ключ $A_1 = a_1 G$, $B_1 = b_1G$ и отправляет $(a_1, B_1)$ Бобу по защищённому стороннему каналу. Боб делает то же самое, выбирая $(a_2, b_2)$ и отправляя $(a_2, B_2)$ Элис. Они вычисляют приватный общий (совместно используемый) ключ просмотра $a_{\text{sh}} = a_1 + a_2$ и публичный общий ключ траты \[B_{\text{sh}} = \mathcal{H}_{\text{agg}}(B_1, (\underline{A}, \underline{B}))B_1 + \mathcal{H}_{\text{agg}}(B_2, (\underline{A}, \underline{B}))B_2 = \beta_1 B_1 + \beta_2 B_2.\] Как вариант, Элис и Боб могли бы вычислить приватный общий ключ просмотра $a_{\text{sh}}$, используя любое количество методов вычисления общего секрета.

Элис и Боб получают сообщение $\m$, содержащее некоторые публичные ключи подписания $(T,P)$, адресованные $(A_{\text{sh}},B_{\text{sh}})$ таким образом, чтобы $P = \mathcal{H}_{\text{sess}}(a_{\text{sh}} T)G + B_{\text{sh}}$. Элис и Боб хотят передать это вместе Шарлин, у которой имеется публичный пользовательский ключ $(A^\prime, B^\prime)$, с некоторым сообщением с кольцевой мультиподписью $\m^\prime$. Элис и Боб решают делать это по стороннему каналу с некоторым кольцом $\underline{P} = (P_1, \ldots, P_r)$ таким образом, чтобы для секретного индекса $\pi$ выполнялось условие $P_\pi = P$. По стороннему каналу Элис и Боб вычисляют образ ключа
\[J = \left(\underbrace{\mathcal{H}_{\text{sess}}(a_{\text{sh}} T)}_{\text{общий вид}} + \underbrace{b_1\mathcal{H}_{\text{agg}}(B_1, (\underline{A}, \underline{B}))}_{\text{первый участник}} + \underbrace{b_2\mathcal{H}_{\text{agg}}(B_2, (\underline{A}, \underline{B}))}_{\text{второй участник}}\right)\mathcal{H}_{\text{ki}}(P).\] Элис и Боб также берут новый приватный ключ транзакции $t^{\prime} \leftarrow \scalarField$ (выбор самостоятельно осуществляется кем-то из членов, или же он каким-либо образом согласуется участниками, как в случае с общим ключом просмотра). Элис и Боб вычисляют для Шарлин новый публичный ключ сессии $P^{\prime} = \mathcal{H}_{\text{sess}}(t^{\prime} A^{\prime})G + B^\prime$. Элис и Боб вычисляют базовую точку для каждого члена кольца, $H_\ell = \mathcal{H}_{\text{ki}}(P_\ell)$. Затем Элис и Боб выполняют алгоритм кольцевого подписания, предполагающий реализацию следующих этапов:

\begin{description}
\item [Обязательство:] Элис выбирает $u_1 \overset{\$}{\leftarrow} \bbz_\p$, а Боб выбирает $u_2 \overset{\$}{\leftarrow} \bbz_\p$. Элис вычисляет временную пару точек $(L_{1, \pi}, R_{1,\pi}) = (u_1 G, u_1 H_\pi)$, а Боб вычисляет временную пару точек $(L_{2, \pi}, R_{2,\pi}) = (u_2 G, u_2 H_\pi)$. Элис выбирает случайные секретные скалярные величины $\underline{s}^{(1)} = \left\{s_{1, \ell}\right\}_{\ell \neq \pi}$, а Боб выбирает случайные секретные скалярные величины $\underline{s}^{(2)} = \left\{s_{2,\ell}\right\}_{\ell \neq \pi}$. Элис вычисляет её частичный образ ключа $J_1 = b_1 \mathcal{H}_{\text{agg}}(B_1, (\underline{A}, \underline{B}))\mathcal{H}_{\text{ki}}(P)$, и Боб вычисляет свой частичный образ ключа $J_2 = b_2 \mathcal{H}_{\text{agg}}(B_2, (\underline{A}, \underline{B}))\mathcal{H}_{\text{ki}}(P)$. Элис вычисляет обязательство $\texttt{com}_1 = \mathcal{H}_{\text{com}}(L_{1,\pi}, R_{1,\pi}, \underline{s}^{(1)})$, и Боб вычисляет обязательство $\texttt{com}_2 = \mathcal{H}_{\text{com}}(L_{2,\pi}, R_{2,\pi}, \underline{s}^{(2)})$. Элис отправляет Бобу $(J_1, \texttt{com}_1)$, а Боб отправляет Элис $(J_2,\texttt{com}_2)$.

\item [Раскрытие:] После получения $(J_2, \texttt{com}_2)$ Элис отправляет $(L_{1,\pi}, R_{1,\pi}, \underline{s}^{(1)})$ Бобу; после получения \linebreak $(J_1, \texttt{com}_1)$ Боб отправляет $(L_{2,\pi}, R_{2,\pi}, \underline{s}^{(2)})$ Элис. После получения $(L_{2,\pi}, R_{2,\pi}, \underline{s}^{(2)})$ Элис проверяет открывается ли обязательство как $\texttt{com}_2 = \mathcal{H}_{\text{com}}(L_{2,\pi}, R_{2,\pi}, \underline{s}^{(2)})$. Если нет, Элис выводит $\bot$ и прекращает транзакцию. После получения $(L_{1,\pi}, R_{1,\pi}, \underline{s}^{(1)})$ Боб проверяет, чтобы $\texttt{com}_1 = \mathcal{H}_{\text{com}}(L_{1,\pi}, R_{1,\pi}, \underline{s}^{(1)})$. Если это не так, Боб выводит $\bot$ и прекращает транзакцию.

\item [Предварительное вычисление подписи:] Элис и Боб вычисляют общий образ ключа $J = J_1 + J_2 + \mathcal{H}_{\text{sess}}(a_{\text{sh}}T)$, собирают изменённое сообщение $\m^* = (\m, \underline{P}, J, (T^{\prime}, P^{\prime}))$, вычисляют $M = \mathcal{H}(\m^*)$, вычисляют суммы $L_\pi = L_{1,\pi} + L_{2,\pi}$, $R_\pi = R_{1,\pi} + R_{2,\pi}$, а также $s_\ell = s_{1,\ell} + s_{2, \ell}$ для каждого $\ell \neq \pi$. Затем Элис и Боб могут вычислить последовательные обязательства $c_{\ell+1} := \mathcal{H}_{\text{sig}}(M,P_\ell, L_{\ell}, R_{\ell})$ и продолжить с индексами $\ell=\pi+1, \pi+2, \ldots, \pi-1$ с $L_\ell = s_\ell G + c_\ell P_\ell$ и $R_\ell = s_\ell H_\ell + c_\ell J$. Частичную подпись $\widehat{\sigma} = (c_1, \left\{s_\ell\right\}_{\ell \in [r] \setminus \pi})$ можно сохранить на потом.

\item [Полная подпись:] Элис вычисляет $s_{1, \pi} = u_1 - c_\pi \beta_1 b_1$. Боб вычисляет $s_{2, \pi} = u_2 - c_\pi \beta_2 b_2$. Элис отправляет $s_{1, \pi}$ Бобу, а Боб отправляет $s_{2, \pi}$ Элис. Оба могут вычислить $s_\pi = s_{1, \pi} + s_{2, \pi}$ и опубликовать полную подпись $\sigma = (c_1, \underline{s})$ с изменённым сообщением $\m^*$.
\end{description} Следует отметить, что при вычислении подписи используется член $P_\ell$ в форме предварительного образа (сравните с разделом \ref{lsagFirst}); в результате, в случае с нашим доказательством безопасности, запросы оракула происходят в безопасном порядке.

\section{Связываемые thring-подписи и их реализация}\label{schemeAndImp}

%In this section, we present a formal definition of LSTAG signatures and an example implementation.%, a definition of an unforgeability game and a description of a signing oracle for use in that game.

\begin{defn}
\textit{Связываемая thring-подпись} является результатом совместного вычисления при помощи четырёх алгоритмов полиномиального времени $(\texttt{KeyGen}, \texttt{Sign}, \texttt{Ver}, \texttt{Link})$. Мы не принимаем во внимание обозначение общего входа $\eta$, параметр безопасности в нашем описании:

\begin{enumerate}

\item $\texttt{KeyGen}$ производит в качестве выхода новое произвольное значение $x \overset{\$}{\leftarrow} \scalarField$, вычисляет $X = xG$ и выдаёт $\texttt{out}_{\texttt{KeyGen}} = (x,X)$.

\item $\texttt{Sign}$ является многосторонним алгоритмом, реализуемым участниками с приватными ключами $\underline{x} = \left\{x_i\right\}_{i=1}^{n}$. Каждый участник использует свой ключ $x_i$ в качестве приватного входа, и все участники используют некоторый общий вход $\texttt{inp}_{\texttt{Sign}} = (\m, \underline{P}, \pi)$, где $\m \in \left\{0,1\right\}^*$, $\underline{P} = \left\{P_i\right\}_{i=1}^{r}$ является кольцом публичных ключей, а $\pi$ является секретным индексом, удовлетворяющим условие $1 \leq \pi \leq r$. $\texttt{Sign}$ выдаёт либо выделенный символ отказа $\texttt{out}_{\texttt{Sign}} = \bot_{\texttt{Sign}}$для каждого участника, либо некоторый $\texttt{out}_{\texttt{Sign}} = (\m^*, \sigma)$ для каждого участника, где $\sigma$ является кольцевой подписью, а $\m^* = (\m, \underline{P}, J, \texttt{aux}_{\texttt{Sign}})$ для тега связываемости $J$ и некоторых вспомогательных данных $\texttt{aux}_{\texttt{Sign}}$.

\item $\text{Ver}$ берёт в качестве входа некоторый $\texttt{inp}_{\texttt{Ver}} = (\m^*, \sigma)$ и выводит бит $\texttt{out}_{\texttt{Ver}} = b \in \left\{0,1\right\}$. %indicating whether $\sigma$ is a valid ring signature on message $M \in \left\{0,1\right\}^*$ with ring of public keys $Q = \left\{Y_1, \ldots, Y_R\right\}$ and linkability tag $J$.

\item $\text{Link}$ берёт в качестве входа некоторый $\texttt{inp}_{\texttt{Link}} = (\m_1^*, \sigma_1)$, $(\m_2^*, \sigma_2)$ и выводит бит $\texttt{out}_{\texttt{Link}} = b \in \left\{0,1\right\}$.

\end{enumerate}
\end{defn} Мы включаем некоторые дополнительные данные в изменённое сообщение, чтобы, например, упаковать ключи получателей в $\m^*$, несмотря на то, что при этом мы не используем $\texttt{aux}$ напрямую.

\begin{defn}[Правильность]
Для любого $\m^* \in \left\{0,1\right\}^*$ и любого $\sigma \in \mathbb{Z}_{\mathfrak{p}}^*$ обозначим событие, где $\texttt{Ver}(\m^*, \sigma) = 1$ как $V(\m^*, \sigma)$. Для любого $((\m, \underline{P}, \pi, \underline{x}), (\m^*, \sigma))$ обозначим событие, где $\texttt{Sign}(\m, \underline{P}, \pi, \underline{x}) = (\m^*, \sigma)$ и $P_\pi = \Phi(\underline{X})$, как $S\left((\m, \underline{P}, \pi, \underline{x}), (\m^*, \sigma)\right)$. Мы говорим, что схема thring-подписи \textit{правильна} если при измерении вероятности по всем входящим монетам и по каждому выбору хеш-функций $\mathbb{P}\left[ V(\m^*, \sigma) \mid S\left((\m, \underline{P}, \pi, \underline{x}), (\m^*, \sigma)\right)\right] = 1$ для любого $(\m, \underline{P}, \pi, \underline{x})$.
\end{defn}

\begin{defn}[Связываемость]
Для любой пары подписей, $(\m^*_1, \sigma_1)$ и $(\m^*_2, \sigma_2)$ обозначим событие, где $\texttt{Link}(\m^*_1, \sigma_1, \m^*_2, \sigma_2) = 1$, как $L(\m^*_1, \sigma_1, \m^*_2, \sigma_2)$. Мы определяем подсобытие $S^{\prime}(\m^*_1, \sigma_1, \m^*_2, \sigma_2) \subseteq V(\m^*_1, \sigma_1) \cap V(\m^*_2, \sigma_2)$ как событие, в котором есть некоторый $\underline{x}$, некоторые сообщения $\m_1$, $\m_2$, некоторые кольца $\underline{P}_1, \underline{P}_2$ и некоторые индексы $\pi_1, \pi_2$ удовлетворяющие условия $\texttt{Sign}(\m_1, \underline{P}_1, \pi_1, \underline{x}) = (\m^*_1, \sigma_1)$ и $\texttt{Sign}(\m_2, \underline{P}_2, \pi_2, \underline{x}) = (\m^*_2, \sigma_2)$. Мы говорим, что схема thring-подписи \textit{связываема}, если для любого $(\m^*_1, \sigma_1, \m^*_2, \sigma_2)$, \[\mathbb{P}\left[L(\m^*_1, \sigma_1, \m^*_2, \sigma_2)\mid S^{\prime}(\m^*_1, \sigma_1, \m^*_2, \sigma_2)\right] = 1,\] где эта вероятность измерена для монет всех участников и по каждому выбору хеш-функций.
\end{defn}

\begin{ex}[LSTAG-подписи]\label{implementation}
Мы представляем схему связываемой thring-подписи, основанную на LSAG-подписях, описанных в работе \cite{liu2004linkable}. Мы называем эту схему \textit{связываемой спонтанной пороговой подписью анонимной группы} или LSTAG-подписью.

Мы агрегируем ключи, используя подход Musig, и задаём $\Phi(\underline{X}) = \sum_{i \in [n]} \beta_i X_i$, где $\beta_i = \phi(x_i, \underline{X}) = \mathcal{H}_{\text{agg}}(X_i, \underline{X})$. Чтобы гарантировать, что каждый участник будет вычислять ключи последовательно, мы допускаем, что у каждого пользователя есть на некоторой фазе настройки согласованный канонический линейный порядок ключей в $\underline{X}$, такой как побитовое лексикографическое упорядочивание, начиная с младшего, $i^{th}$ член имеет часть приватного ключа $x^*_i = \beta_i x_i = \phi(x_i, \underline{X})x_i$. Образ ключа вычисляется так же, как это обычно делается в случае с Monero: для любого приватного ключа $x \in \scalarField$ образом ключа будет $x\mathcal{H}_{\text{ki}}(xG)$, таким образом, образом ключа $X_{\text{sh}}$ точно будет $\sum_i \beta_i x_i \mathcal{H}_{\text{ki}}(X_{\text{sh}})$.

\begin{enumerate}
\item $\texttt{KeyGen}$ случайным образом выбирает некоторый $x \in \scalarField$, вычисляет $X := xG$ и выводит $(x,X)$.

\item $\texttt{Sign}$ запускается по стороннему каналу, после того как группа придёт к соглашению по сообщению $\m$, по кольцу $\underline{P}$ и секретному индексу $\pi$, произведёт предварительное вычисление базовых точек образа ключа для каждого члена кольца $H_\ell := \mathcal{H}_{\text{ki}}(P_\ell)$, вычислит образ ключа $J = \sum_j J_j = \sum_j x^*_j H_\pi$, соберёт изменённое сообщение $\m^* = (\m, \underline{P}, J, \texttt{aux})$ и вычислит $M = \mathcal{H}_{\text{msg}}(\m^*)$. Все остальные действия выполняются совместно:

\begin{description}
\item [Обязательство:] каждый подписант, допустим, с индексом $j$, удовлетворяющим условие $1 \leq j \leq n$, делает следующее:
\begin{enumerate}
\item выбирает случайную скалярную величину $u_j$, вычисляет точки $U_j = u_j G$ и $V_j = u_j H_\pi$ и выбирает случайные скалярные величины $s_{\pi+1, j}, s_{\pi+2, j}, \ldots, s_{\pi-1,j}$;

\item задаёт $\texttt{dat}_{j} := (U_j, V_j, \left\{s_{\ell,j}\right\}_{\ell\neq \pi})$;

\item вычисляет обязательство $\texttt{com}_{j} = \mathcal{H}_{\text{com}}(\texttt{dat}_{j})$;

\item отправляет $\texttt{com}_{j}$ всем остальным подписантам.
\end{enumerate}

\item [Раскрытие:] После получения $\texttt{com}_{j}$ от остальных членов объединения каждый подписант, обладающий тем же индексом, что и раньше, делает следующее:
\begin{enumerate}
\item отправляет $\texttt{dat}_{j}$ всем остальным подписантам;

\item после того, как все $\texttt{dat}_{j^\prime}$ были получены, проверяет, чтобы $\mathcal{H}_{\text{com}}(\texttt{dat}_{j^\prime}) = \texttt{com}_{j^\prime}$ для каждого $j \neq j^\prime$. Если не все обязательства открываются надлежащим образом, выдаёт $\bot_{\texttt{Sign}}$ и завершает процесс.
\end{enumerate}

\item [Предварительная офлайн обработка подписи:] каждый подписант, обладающий тем же индексом, что и раньше, делает следующее:
\begin{enumerate}
\item вычисляет $L_\pi = \sum_j U_j$, $R_\pi = \sum_j V_j$;
\item вычисляет каждое $s_{\ell} = \sum_j s_{\ell,j}$ для каждого $1 \leq \ell \leq r$ так, чтобы $\ell \neq \pi$;
\item для каждого $\ell = \pi, \pi+1, \ldots, \pi - 1$ (где мы переназначаем избыточные индексы, преобразуя $r+1 \mapsto 1$, $r+2 \mapsto 2$ и так далее), вычисляем следующее:
\begin{align*}
c_{\ell+1} =& \mathcal{H}_{\text{sig}}(M, P_\ell, L_\ell, R_\ell) \\
L_{\ell+1} =& s_{\ell+1}G + c_{\ell+1}P_{\ell+1}\\
R_{\ell+1} =& s_{\ell+1}H_{\ell+1} + c_{\ell+1}J
\end{align*}
\item сохраняет предварительно обработанную подпись $(u_j, \m^*, c_1, c_\pi, \left\{s_{\ell}\right\}_{\ell \neq \pi})$ для последующей работы.
\end{enumerate}

\item [Завершение подписи:] чтобы завершить подписание, используя $(u_j, \m^*, c_1, c_\pi, \left\{s_{\ell}\right\}_{\ell \neq \pi})$, каждый подписант, обладающий тем же индексом, что и раньше, делает следующее:
\begin{enumerate}
\item вычисляет $s_{\pi, j} = u_j - c_\pi x^*_j$;
\item отправляет $s_{\pi, j}$ другим подписантам;%\footnote{This value should not be computed before this step.}.
\item после получения всех $\left\{s_{\pi, j^\prime}\right\}_{j \neq j^\prime}$ вычисляет $s_\pi = \sum_j s_{\pi,j}$;
\item выводит $(\m^*, \sigma)$, где $\sigma = (c_1, \underline{s})$, где $\underline{s} = (s_1, s_2, \ldots, s_r)$.
\end{enumerate}
\end{description}

\item $\texttt{Ver}$ берёт в качестве входа некоторый $(\mathfrak{m}^*, \sigma)$.
\begin{enumerate}
\item Разбирает $\mathfrak{m}^* = (\mathfrak{m}, \underline{P}, J, \texttt{aux})$ и $\sigma = (c_1, \underline{s})$;
\item Для $\ell = 1, 2, \ldots, r-1$ вычисляет $L_\ell = s_\ell G + c_\ell P_\ell$, $R_\ell = s_\ell H_\ell + c_\ell J$ и $c_{\ell+1} = \mathcal{H}_{\text{sig}}(M, P_\ell, L_\ell, R_\ell)$;
\item Вычисляет $c_1^\prime = \mathcal{H}_{\text{sig}}(M, P_r, L_r, R_r)$;
\item Выводит $1$, если $c_1^\prime = c_1$, и $0$ в противном случае.
\end{enumerate}

\item $\texttt{Link}$ работает так же, как в случае с «обратной» LSAG-подписью: проверяет соответствие образов ключей $J$.
\end{enumerate}

\end{ex}

%Note that since key aggregation requires queries from $\mathcal{H}_{\text{agg}}$, an algorithm that collaborates with other algorithms to execute $\texttt{Sign}$ simulated inside of a black box reveals the keys in each $L$ used. %The question remains whether Example \ref{} can be expanded to take iterative key aggregation into account. In the sequel, we make use of the following definitions that naturally come up while discussing iterative aggregation of keys using multisets of multisets $\left\{L_{\ell, \lambda}\right\}_{\lambda \in \Lambda_\ell}$ to obtain some $Y_\ell \in Q$.

%\begin{defn} We say the \textit{famgraph} is the following directed multigraph. Nodes are public keys in $\cup_{\ell} \cup_{\lambda \in \Lambda_\ell} L_{\ell,\lambda}$. For each node $Y$, there is some set of nodes $L_{\ell, \lambda}$ in this set; for each occurrence of each key $Y^\prime \in L_{\ell,\lambda}$, we declare a directed edge $Y \to Y^\prime$ (there are as many directed edges $Y \to Y^\prime$ as the number of copies of $Y^\prime$ used to compute $Y$). We say each $Y^\prime \in L$ is a \textit{parent key} of $Y$. Naturally, we say the keys with no parents in a famgraph are the \textit{orphans}, and we say two keys are \textit{related} if there is a path connecting them in the famgraph for one or the other. \end{defn}



%\begin{disc} We consider an expansion of the above scheme to take into account iteratively aggregated keys. Let $A, B, C, D$ be public keys of some participants, who do the following. $A$ and $B$ collaborate to compute a shared key $X$. $A$ and $B$ then cooperate with each other to use $X$ to collaborate with $C$ to obtain another shared key, $Y$ (possibly $Y$ does not k that $X$ is shared between two parties).  $A$, $B$, and $C$ cooperate with each other to use $Y$ again with the key $A$ to obtain a shared key, $Z$, resulting in the following famgraph.
%\[\xymatrix{
% &  & Z \ar[dddll] \ar[dr] &  & \\
% &  &  & Y \ar[dll] \ar[ddr] & \\
% & X \ar[dl] \ar[dr] &  &  & \\
%A &  & B &  & C
%}\]

%There are two paths from $Z$ to $A$ but there is a unique path from $Z$ to $B$ and $Z$ to $C$. Consider how this famgraph may be used to compute a key image. that the key $Z$ can be written as $Z = \alpha A + \beta B + \gamma C$ where $\alpha = H_{\texttt{agg}}(A,\left\{A,B\right\}) + H_{\texttt{agg}}(A, \left\{A,Y\right\})$, $\beta = H(B, \left\{A,B\right\})$, and $\gamma = H(C,\left\{C,X\right\})$; we see that $A$ has two contributions to the key, one for each path. Likewise, an orphan key has as many contributions to the key as there are paths from the ancestor to the orphan. Hence, in the case of iterative key aggregation, key images and random signing data must be computed as sums over paths in the famgraph (this does not impact the commit-and-reveal stage of the process). For example, if orphan $j$ has partial key image $x^*_j H_{\pi}$ and there are $\nu_j$ paths from the ancestor signing key to the orphan, then the total key image is therefore $J = \sum_j \nu_j J_j$. \end{disc}

%\begin{ex}
%We modify $\texttt{Sign}$ to allow the true signer to be a key that has been iteratively aggregated. The modification requires taking the famgraph of the signing key as additional input (and, of course, requiring the participation of the private keys of all orphans in the famgraph).

%\begin{enumerate}\label{implementationAgg}
%\item[2.] $\texttt{Sign}$ is initiated by side channel when the group of orphan keys does the following: they agree upon a message $M$, a ring $Q$, a secret index $\pi$, and a famgraph for their signing key $Y \in Q$, they pre-compute the key image basepoints for each ring member $H_\ell := \mathcal{H}_{\text{ki}}(Y_\ell)$, they enumerate all paths in the famgraph from the ancestor signing key to the $j^{th}$ orphan, say there are $\nu_j$ of these, they compute their partial key images $J_j = x^*_{j} H_\pi$, and they compute the key image $J = \sum_j \nu_j J_j$. The remainder is run by the orphan keys with the following three-step process.
%\begin{description}
%\item [Commit and reveal] This step is identical to Example \ref{}.

%\item [Offline signature pre-processing] Each orphan key computes the points $U = \sum_j \nu_j U_j$, $V = \sum_j \nu_j V_j$, and each $s_{\ell} = \sum_j \nu_j s_{\ell,j}$. Each orphan key computes the verification commitments:
%\begin{align*}
%c_{\pi+1} =& \mathcal{H}_{\text{sig}}(M, U, V)\\
%c_{\pi+2} =& \mathcal{H}_{\text{sig}}(M, s_{\pi+1}G + c_{\pi+1} Y_{\pi+1}, s_{\pi+1}H_{\pi+1} + c_{\pi+1}J)\\
%&\vdots \\
%c_{\pi} =& \mathcal{H}_{\text{sig}}(M, s_{\pi-1}G + c_{\pi-1}Y_{\pi-1}, s_{\pi-1}H_{\pi-1} + c_{\pi-1}J)
%\end{align*}
% the pre-processed signature $c_1, \left\{s_{\ell}\right\}_{\ell \neq \pi}$ can be stored for later.

%\item [Signature completion] Each signer recalls their $u_j$, computes $s_{\pi, j} = u_j - c_\pi \nu_j x^*_j$, and sends $s_{\pi, j}$ to the other signers. Any of them can complete the signature by computing $s_\pi = \sum_j s_{\pi,j}$ and publishing $(\sigma, J)$ where $\sigma = (c_1, s_1, \ldots, s_R)$.
%\end{description}

%\end{enumerate}
%\end{ex}




\section{Невозможность подделки и thring-подписи}\label{unf}

%In this section we define an existential unforgeability game and a signing oracle for that game, and we demonstrate that the thring signature scheme from Example \ref{implementation} is existentially unforgeable as described in Definition \ref{game}. Our proof strategy uses the double forking technique of \cite{maxwell2018simple}.

\subsection{Определение подделки}

Что точно означает слово «поделка», или что значит «сделать подделку»? Подделкой будет некоторое $(\m^*, \sigma)$, где $\sigma$ не будет выходом в записи запросов, отправленных $\adversary$ для $\mathcal{SO}$ и $\texttt{Ver}(\m^*, \sigma)=1$. Тем не менее этого недостаточно. На самом деле, если ни один из ключей не будет агрегирован в $\underline{P}$, поделка нашей подписи сведётся к подделке лежащей в её основе схемы LSAG; без потери общности успешная поделка подразумевает наличие по крайней мере одного агрегированного ключа в $\underline{P}$. Кроме того, если будет агрегирован какой-то ключ, тот, кто занимается подделкой, мог бы просто поместить свой собственный ключ в $\underline{P}$ вместе с агрегированным ключом. Таким образом, если злоумышленнику будет известен дискретный логарифм любого публичного ключа в некотором кольце $\underline{P}$, то он сможет создать только честную подпись, используя $\underline{P}$, которая не может считаться подделкой. Без потери общности все участники кольца должны быть либо честными ключами (то есть задачей на основе дискретного логарифмирования), либо дочерним элементом честного ключа. Если самый мощный злоумышленник повредит все ключи, кроме одного, мы допустим наличие только одного целевого честного ключа $X_h$.

Следовательно, мы изменяем правила обычной игры в невозможность подделки: при наличии ключа $X_h$ и кольца $\underline{P}$ подделка станет успешной только в том случае, если будет сопровождаться свидетельством того, что каждый участник кольца либо является самим ключом $X_h$, либо дочерним элементом $X_h$, а также, что в $\underline{P}$ присутствует по крайней мере один дочерний элемент $X_h$. Злоумышленник может просто создать свидетельство этих отношений, представив агрегируемые наборы $\left\{\underline{X}^{(\ell)}\right\}_{\ell \in [r]}$ таким образом, чтобы $X_h \in \underline{X}^{(\ell)}$ и $P_\ell = \Phi(\underline{X}^{(\ell)})$ для каждого $1 \leq \ell \leq r$. В дальнейшем злоумышленник является PPT алгоритмом $\adversary$, который берёт в качестве входа некоторый ключ $X_h$ и выдаёт в качестве выхода выделенный символ ошибки $\bot_\adversary$ или успешную подделку $\texttt{out}_{\adversary} = \texttt{forg} = (\m^*, \sigma, \left\{\underline{X}^{(\ell)}\right\}_{\ell \in [r]})$.
%In the degenerate case where $P_\ell=X_h$, we write $L_\ell = \left\{X_h\right\}$ and we assume $\Phi$ is the identity function.




%In \cite{maxwell2018simple}, the most powerful forger is modeled by corrupting all keys except a single distinguished honest key. In the ring signature framework, though, requiring every key in $Q$ to either be equal or be aggregated from this sole distinguished honest key seems, superficially, like an artificial constraint. An alternative is to require the forgery challenger to fix a ring size $R = \left|Q\right| > 2$ and identify $R$ distinguished honest keys $X_h \in \left\{X_1, X_2, \ldots, X_R\right\}$ for use by $\adversary$ in computing the ring members of $Q$. As we will see later, the forger selects a specific $X_i$ as a target for breaking the discrete logarithm, and we can freely re-index this to be $X_1$, so this approach is equivalent to the approach in \cite{maxwell2018simple}.


%Let $\adversary^{\mathcal{SO},\underline{\mathcal{H}}}$ be a $(t,\epsilon,q)$-forger with oracle access to $\mathcal{SO}$ and the family of random oracles $\underline{\mathcal{H}}$ that takes as input some set of target honest keys $\left\{X_\ell\right\}_{\ell=1}^R$ and produces as output a successful forgery $(M,Q, \left\{L_{\ell,\lambda}\right\}_{1 \leq \ell \leq R, \lambda \in \Lambda_\ell})$ or a failure symbol $\bot$.

\begin{defn}[Реальная невозможность подделки LSTAG]\label{game}
Мы говорим, что PPT алгоритм $\adversary$ является подделкой $(t, \epsilon, q,n)$, если за время $t$ как самое большее и за $q$ запросов оракула $\adversary$ будет успешно реализован при следующем сценарии с вероятность, составляющей по крайней мере $\epsilon$.
\begin{enumerate}
\item Запросчик берёт пару честных ключей $(x_h,X_h) \leftarrow \texttt{KeyGen}$ и отправляет публичный ключ $X_h$ алгоритму $\adversary.$

\item $\adversary$ может генерировать ключи, может собрать любую группу элементов, используя $X_h$, и получает доступ к подписывающему оракулу $\mathcal{SO}$ и случайным оракулам $\mathcal{H}_{\text{agg}}$, $\mathcal{H}_{\text{sig}}$, $\mathcal{H}_{\text{com}}$, $\mathcal{H}_{\text{msg}}$ и $\mathcal{H}_{\text{ki}}$. $\adversary$ может использовать любой из них в любом порядке, адаптивно отвечая на предыдущие результаты.

\item $\adversary$ выводит некоторое $(\m^*, \sigma, \left\{\underline{X}^{(\ell)}\right\}_{\ell = 1}^r)$.

\item $\adversary$ выигрывает, если все следующие условия будут соблюдены:

\begin{description}
\item [Правильность:] для каждого $\ell$, $P_\ell = \Phi(\underline{X}^{(\ell)})$.
\item [Ограниченность:] для каждого $\ell$, $1 \leq \left|\underline{X}^{(\ell)}\right| \leq n$.
\item [Честный родитель:] для каждого $\ell$, $X_h \in \underline{X}^{(\ell)}$.
\item [Наличие накопленных ключей: ] для некоторого $\ell$, $\left|\underline{X}^{(\ell)}\right| \geq 2$ (накоплен по крайней мере один ключ).
\item [Нетривиальность:] $\sigma$ не является выходом в транскрипте между $\mathcal{A}$ и $\mathcal{SO}$; и, конечно же
\item [Корректность:] $\texttt{Ver}(\m^*, \sigma) = 1$.
\end{description}

\end{enumerate}

\end{defn}

Несмотря на то, что для злоумышленника представляется нереальным предоставление свидетельства подделки, нам бы хотелось отметить, что если подделка будет скрыта в «чёрный ящик» при помощи какого-либо верховного алгоритма, запросы накопления ключей, которые будет делать фальсификатор, должны быть смоделированы или также созданы таким верховным алгоритмом. Следовательно, свидетельство этих отношений может быть выделено из транскрипта, в результате чего будет сделана успешная подделка.

%\begin{disc}
%Note that, given any $Q$ that is not strictly adversarially controlled, given the famgraph of each $Y_i \in Q$, each key $Y_i \in Q$ can be written $\alpha X_1$ or $Y_{\adversary, i} + \alpha X_1$ for some publicly computable $\alpha$, some adversarially controlled point $Y_{\adversary, i}$. Indeed, the aggregated keys in $Q$ are linear combinations of keys (which may, in turn, be linear combinations, and so on, but only a finite number of times). All the terms with $X_h$ can be collected into $\alpha X_h$ and all other keys are collected into $Y_{\adversary, i}$. The coefficient $\alpha$ is computable using the famgraph. We do not assume the adversary knows the discrete logarithm of $Y_{\adversary, i}$, since this brings in the KOSK assumption.
%\end{disc}

%\begin{disc} Compare our definition to the non-threshold ring signature cases of the past. The definition of \textit{unforgeability with respect to insider corruption} described in \cite{bender} provides several honest keys to the adversary and grants the adversary access to a corruption oracle, but only allows the adversary to win if each key in the ring of the purported forgery has not been corrupted. Of course, if multiple honest keys were not made available, then a forged ring signature could only occur with a singleton ring in their model. \end{disc}

%\subsection{Strategy for proving unforgeability}

\subsection{Стратегия доказательства невозможности подделки}\label{strat}

Предположим, что $\mathcal{B}$ является метасокращением $\adversary$, которое выдаёт для некоторого фиксированного сообщения $\mathfrak{m}$ четыре подделанные подписи $\sigma$, $\sigma^\prime$, $\sigma^{\prime \prime}$, $\sigma^{\prime \prime \prime}$ с кольцами $\underline{P}$, $\underline{P}^\prime$, $\underline{P}^{\prime \prime}$, $\underline{P}^{\prime \prime \prime}$ с семейными историями $\underline{X} = \left\{\underline{X}^{(\ell)}\right\}_{\ell \in [r]}$, $\underline{X}^\prime = \left\{(\underline{X}^{ (\ell)})^\prime\right\}_{\ell \in [r^\prime] }$, $\underline{X}^{\prime \prime} = \left\{(\underline{X}^{(\ell)})^{\prime \prime}\right\}_{\ell \in [r^{\prime \prime}]}$, and $\underline{X}^{\prime \prime \prime} = \left\{(\underline{X}^{ (\ell)})^{\prime \prime \prime}\right\}_{\ell \in [r^{\prime \prime\prime}]}$. Кроме того, предположим, что $\mathcal{B}$ может выделить из оракулов, созданных $\adversary$, выделенный индекс $\ell$ таким образом, чтобы \[L_\ell = L_\ell^\prime, \vspace{0.05in} L_\ell^{\prime \prime} = L_\ell^{\prime \prime \prime}, \vspace{0.05in}
P_\ell = P_\ell^\prime, \vspace{0.05in} P_\ell^{\prime \prime} = P_\ell^{\prime \prime \prime}.\] Затем $\mathcal{B}$ может вычислить дискретный логарифм $P_\ell$ как $(c_\ell - c_\ell^\prime)^{-1}(s_\ell^\prime - s_\ell)$ и дискретный логарифм $P_\ell^{\prime \prime}$ как $(c_\ell^{\prime \prime} - c_\ell^{\prime \prime \prime})^{-1}(s_\ell^{\prime \prime \prime} - s_\ell^{\prime \prime})$. Тем не менее ключи $P_\ell = P_\ell^\prime$ агрегируются из $\underline{X}$ и $\underline{X}^{\prime}$, соответственно. Поэтому мы можем записать $P_\ell = P_\ell^\prime = \alpha X_h + Z$ для некоторого $\alpha$ и некоторого $Z$, используя функцию агрегирования $\Phi$. Подобным образом $P_\ell^{\prime \prime} = P_\ell^{\prime \prime \prime}$ может быть записано как $\alpha^\prime X_h + Z^\prime$ для некоторых $\alpha^\prime, Z^\prime$.

Если $\mathcal{B}$ может гарантировать, что $Z = Z^\prime$ и $\alpha \neq \alpha^\prime$, то $P_\ell - P_\ell^{\prime \prime} = (\alpha - \alpha^\prime)X_h$ и $\mathcal{B}$ могут получить дискретный логарифм $X_h$: \[x_h = (\alpha - \alpha^\prime)^{-1}\left(\frac{s_\ell^\prime - s_\ell}{c_\ell - c_\ell^\prime} - \frac{s_\ell^{\prime \prime \prime} - s_\ell^{\prime \prime}}{c_\ell^{\prime \prime} - c_\ell^{\prime \prime \prime}}.\right)\] Следовательно, чтобы продемонстрировать абсурдность существования фальсификатора $\adversary$, достаточно указать на существование метасокращения, которое может произвести четыре транскрипта, из которых затем можно будет извлечь следующее: индекс $1 \leq \ell$, некоторые публичные ключи $(P_\ell, P_\ell^\prime, P_\ell^{\prime \prime}, P_\ell^{\prime \prime \prime}, \linebreak L_\ell, L_\ell^\prime, L_\ell^{\prime \prime}, L_\ell^{\prime \prime \prime}, Z, Z^\prime)$ и некоторые скалярные величины $(s_\ell, s_\ell^\prime, s_\ell^{\prime \prime}, s_\ell^{\prime \prime \prime}, c_\ell, c_\ell^\prime, c_\ell^{\prime \prime}, c_\ell^{\prime \prime \prime}, \alpha, \alpha^\prime)$ так, чтобы:
\begin{align*}
L_\ell = & s_\ell G + c_\ell P_\ell &
L_{\ell}^\prime =& s_\ell^\prime G + c_\ell^\prime P_\ell^\prime\\
L_\ell^{\prime \prime} =& s_\ell^{\prime \prime} G + c_\ell^{\prime \prime} P_\ell^{\prime \prime} &
L_{\ell}^{\prime \prime \prime} =& s_\ell^{\prime\prime \prime} G + c_\ell^{\prime \prime \prime} P_\ell^{\prime \prime\prime}\\
L_\ell =& L_\ell^{\prime} &
L_\ell^{\prime \prime} =& L_\ell^{\prime \prime \prime}\\
P_\ell =& P_\ell^{\prime} &
P_\ell^{\prime \prime} =& P_\ell^{\prime \prime \prime}\\
P_\ell =& \alpha X_h + Z &
P_\ell^{\prime \prime} =& \alpha^\prime X_h + Z^\prime
\end{align*} и так, чтобы $c_\ell^{\prime \prime} \neq c_\ell^{\prime \prime \prime}$, $c_\ell \neq c_\ell^\prime$ и $\alpha \neq \alpha^\prime$. Мы называем это \textit{системой уравнений и неравенств подделки по дискретному логарифму}.

В Приложении \ref{security} мы показываем, как это делается с тщательным построением оракулов и двумя форками: самый первый запрос верификации подписи в форме $\mathcal{H}(M,P_\ell,L_\ell,R_\ell)$, гарантирующий, что $L_\ell = L_\ell^\prime$ и $L_\ell^{\prime \prime} = L_\ell^{\prime \prime \prime}$, и второй — после вычисления коэффициентов накопления ключей, гарантирующий, что $Z_\ell = Z_\ell^\prime = Z$ and $\alpha \neq \alpha^\prime$.


%We fork a second time in a way that guarantees we have transcripts with $c_\ell \neq c_\ell^\prime$ but such that $P_\ell = P_\ell^\prime$

%If $P_\ell$ is aggregated, $P_{\ell}$ can be written $P_\ell = Z_\ell + \alpha X_h$ where $\alpha = \mathcal{H}_{\text{agg}}(X_h, \underline{X}^{(\ell)})$. Likewise, $P_\ell^\prime = Z_\ell^\prime + \alpha^\prime X_h$ where $\alpha^\prime = \mathcal{H}_{\text{agg}}(X_h, (\underline{X}^{(\ell)})^\prime$. If not aggregated, $P_\ell = X_h$ (or $P_\ell^\prime = X_h$) exactly, but this, too, can be written as $Z_\ell + \alpha X_h$ by setting $Z_\ell = 0$ and $\alpha = 1$. Hence the equality extracted from the transcript above provides the following:
%\begin{align*}
%L_\ell = s_\ell G + c_\ell P_\ell =& s^\prime_\ell G + c^\prime_\ell P_\ell^\prime = L_{\ell}^\prime\\
%s_\ell G + c_\ell Z_\ell + c_\ell \alpha X_h =& s_\ell^\prime G + c_\ell^\prime Z_\ell^\prime + c_\ell^\prime \alpha^\prime X_h.
%\end{align*}

%Since $P_\ell, P_\ell^\prime$ are included in the queries $\mathcal{H}_{\text{sig}}(M, P_\ell, L_\ell, R_\ell)$ and $\mathcal{H}_{\text{sig}}(M, P_\ell^\prime, L_\ell^\prime, R_\ell^\prime)$, they must have been aggregated before this signature query (except with negligible probability).

%It is sufficient for $\mathcal{B}$ to learn $z_\ell$ and $z_\ell^\prime$ to compute the discrete logarithm of $X_h$ here.

%$c_\ell Z_\ell = c_\ell^\prime Z_{\ell}^\prime$ and $c_\ell \alpha \neq c_\ell^\prime \alpha^\prime$, then $\mathcal{B}$ can compute the discrete logarithm of $X_h$ without $z_\ell$ or $z_\ell^\prime$ very simply: $x_h = (c_\ell \alpha - c_\ell^\prime \alpha^\prime)^{-1}(s_\ell^\prime - s_\ell)$. Alternatively, ...

%Hence, $\mathcal{B}$ can be used as a discrete logarithm solver, even outside of the KOSK setting (where each $z_\ell$ and $z_\ell^\prime$ is known by $\mathcal{B}$) if these conditions are satisfied. To prove unforgeability of our scheme, then, it is sufficient to prove that a forger $\adversary$ with non-negligible advantage at the existential unforgeability game can be reduced to some $\mathcal{B}$ that produces two forgeries from which, for some $\ell$, the following system of equations can be extracted
%\begin{align}
%P_\ell =& Z_\ell + \alpha X_h\\
%P^\prime_\ell =& Z_\ell^\prime + \alpha^\prime X_h\\
%s_\ell G + c_\ell P_\ell =& s^\prime_\ell G + c^\prime_\ell P_\ell^\prime \\
%c_\ell Z_\ell =& c_\ell^\prime Z_\ell^\prime
%\end{align} subject to the constraint that $c_\ell \alpha \neq c_\ell^\prime \alpha^\prime$. We say this is the \textit{system of forgery-to-discrete-log equations and inequalities}.


\section{Правильное и не правильное использование вариантов применения и реализации}

В этом разделе нами будут рассмотрены некоторые варианты реализации схем thring-подписей, их расширения, а также их применения в кольцевых конфиденциальных транзакциях. %We discuss security properties of our scheme in the appendix. %One primary difference between the LSTAG example of Section \ref{} and the current Monero approach is that we prefix each ring signature challenge with the associated ring member.


\subsection{Опасность не случайного или повторного подписания}

Протокол становится опасным, если данные генерируются не случайным образом при каждой попытке создания подписи, или же если публикуется более одной подписи на ключ. Если одни и те же данные подписи $u_{j,\pi}$ используются стороной-участником дважды, существует риск раскрытия приватных ключей: равенства $s = u - c b^*$ и $s^\prime = u - c^\prime b^*$ могут использоваться для вычисления $b^* = \frac{s-s^\prime}{c^\prime - c}$. Следовательно, никогда не следует использовать какой-либо не случайный метод выбора данных подписи. Подобным образом никогда не следует использовать две подписи с одним и тем же ключом сессии, так как появляется возможность извлечения логарифма подписывающего ключа.

\subsection{Вопросы свойств группы}

Также следует отметить идеальную безопасность использования группы $\mathbb{G}$ \textit{сложного}, а не простого порядка. Тем не менее мы должны ограничить наш выбор публичного ключа подгруппой $\mathbb{G}$ определённого простого порядка. При использовании так называемой кривой Ed25519 (которая также называется «скрученной кривой Эдвардса», описана в работе \cite{bernstein2012high} и бирационально эквивалентна так называемой кривой Curve25519, описанной в работе \cite{bernstein2006curve25519}) существуют некоторые риски, связанные с реализацией при выборе публичного ключа за пределами подгруппы простого порядка.

И в самом деле, подгруппы простого порядка имеют кофактор $8$, что обеспечивает возможность их использования в своих корыстных целях. Чтобы избежать этого, все варианты реализации, использующие эту кривую, требуют проверки, чтобы группа элементов, используемая в качестве публичных ключей, находилась в пределах подгруппы простого порядка. Для этого проверяется их порядок. Определённо, любой приватный ключ $x \in \mathbb{Z}_\p$ будет иметь соответствующий публичный ключ $X = xG$ для этой подгруппы простого порядка, так как $G$ является генератором этой подгруппы. С другой стороны, случайный выбор публичного ключа не гарантирует дискретного логарифмирования предварительного образа относительно $G$. Нам необходимо изменить функцию хеширования в точку $\mathcal{H}_{\text{ki}}$, чтобы получить кообласть, равную подгруппе простого порядка. Это означает умножение публичных ключей без соответствующих приватных ключей на кофактор $8$ при использовании кривой Ed25519 или Curve25519.

\subsection{Расширение ключа просмотра и конфиденциальные thring-транзакции}

Среди прочих причин можно указать на то, что наши thring-подписи нельзя напрямую сравнить с подписями, используемыми в криптовалютах, такими как MLSAG-подписи, которые используются в протоколах подобных CryptoNote. В самом деле, пользовательские ключи CryptoNote идут парами с ключом просмотра и ключом траты, а подписи вычисляются при помощи одноразовых ключей, выводимых из них. Эвристические принципы пороговой обработки, описанные в Разделе \ref{naiveImplement}, естественным образом распространяются на систему с этим расширением одноразовых ключей, но наши доказательства свойств безопасности не применяются непосредственно в отношении этих расширений, если их не доработать. Обеспечение невозможности подделки варианта реализации LSTAG thring-подписей, использующих одноразовые ключи в стиле CrypytoNote, с расширением ключа просмотра остаётся открытой задачей.

Одной из моделей, которая могла бы помочь доказать невозможность подделки расширения ключа просмотра в рамках предлагаемого нами ниже варианта реализации, является получение каждой из сторон-участников общего секрета $y = a_{\text{sh}}$ и использование ключей $\underline{x} = (x_1, \ldots, x_n)$ для вычисления общего ключа в форме $Y + \Phi(\underline{X})$. Атаки с кражей ключа или его отменой при использовании этого метода можно избежать путём тщательного построения $y$. Например, в случае с протоколами типа CryptoNote фальсификация $Y$ требует фальсификации хеш-суммы ключа, полученного при обмене по протоколу Диффи-Хеллмана.

Подобным образом наш эвристический подход таким же естественным образом распространяется на MLSAG, но и тут наши доказательства безопасности нельзя будет применить напрямую, не доработав. Мы кратко описываем кольцевые конфиденциальные транзакции Monero и пороговое расширение конфиденциальных thring-транзакций.

MLSAG-подписи строятся на основе векторов ключей в форме $(\mathcal{H}_{\text{sess}}(a T) G + B, \texttt{PedCom}(v, r))$, где $\texttt{PedCom}$ является схемой обязательства Педерсена, $v$ - суммой транзакции, а $r$ является приватным ключом от суммы-обязательства. MLSAG-подписи по своей структуре являются мультиподписями, так как используют множество ключей для подписания сообщения, но они вычисляются не совместными усилиями. Размер подписи в этом случае не зависит от количества подписантов, но MLSAG-подписи всё же раскрывают количество подписывающих ключей. Интерпретируя список подписывающих ключей подписантов $\underline{P} = (P_1,\ldots,P_n)$ как вектор, подписант (или подписанты) случайно выбирает схожие векторы из блокчейна для построения кольца из таких векторов ключей $\widetilde{\underline{P}}$, объединяя $\underline{P}$ в столбец $\pi^{th}$ секрета $\pi$.
\begin{align*}
\widetilde{\underline{P}} =
\begin{pmatrix}
P_{1,1} & P_{1, 2} & \cdots & P_{1, r} \\
P_{2,1} & P_{2, 2} & \cdots & P_{2, r} \\
\vdots & & & \vdots \\
P_{n,1} & P_{n, 2} & \cdots & P_{n,r} \\
\end{pmatrix} = (\underline{P}_1, \ldots, \underline{P}_r)
\end{align*}
где каждое $\underline{P}_\ell = \left\{P_{j,\ell}\right\}_{j \in [n]}$. Для каждого $j = 1, 2, \ldots, n$ и $\ell = 1, 2, \ldots, r$ с составляющей $P_{j,\ell}$ в $\widetilde{\underline{P}}$ мы вычисляем $H_{j,\ell} := \mathcal{H}_{\text{ki}}(P_{j,\ell})$. Для каждого компонента $p_j \in \underline{p}$ подписант вычисляет образ ключа $J_j = p_j \mathcal{H}_{\text{ki}}(p_j G)$. Подписант выбирает вектор случайных скалярных величин $\underline{u} = (u_1, \ldots, u_n) \in \scalarField^n$ для столбца $\pi^{th}$ и для каждого $\ell \neq \pi$, подписант выбирает вектор скалярных величин $\underline{s}_\ell = (s_{1,\ell}, s_{2,\ell}, \ldots, s_{n,\ell})$. Затем для каждого подписывающего ключа $P_{j, \ell}$ подписант вычисляет пару точек и обязательство
\begin{align*}
L_{j, \ell} =& s_{j,\ell} G + c_\ell P_{j, \ell}, & R_{j,\ell} =& s_{j,\ell} H_{j, \ell} + c_\ell J_j, &
c_{\ell+1} =& \mathcal{H}_{\text{sig}}\left(M,\left\{(L_{\ell}^{j}, R_{\ell}^{j} )\right\}_{j=1}^{n}\right).
\end{align*}
Как только каждое обязательство будет вычислено, подписант обычным образом вычисляет каждое $s_{j,\pi} = u_j - c_\pi p_j$, собирает $\underline{s}_\pi = (s_{j, \pi})_{j \in [n]}$ и получает MLSAG-подпись $\sigma = (c_1, (\underline{s}_\ell)_{\ell \in [r]})$, которая верифицируется подобно LSAG-подписям.

Изначально эта схема может показаться недостаточно неопределённой в отношении идентификации подписанта. Любой может определить, что один из этих столбцов содержит все ключи подписания. Другими словами, не могут $p_{2,2}$ и $p_{1,1}$ одновременно являться действительными ключами, используемыми в кольцевой подписи. Это, скорее, не недостаток, а то, как Monero связывает ключи подписания с суммами транзакций. В случае с Monero первый ряд ключей в $\widetilde{\underline{P}}$ является ключами подписания, второй ряд составляют разницы между обязательствами Педерсена и по входящим суммам транзакций и выходящим суммам. Подписание с использованием этой матрицы демонстрирует как знание приватного ключа подписания со специальным индексом, так и способность раскрыть обязательство по сумме по этому индексу с точностью до нуля.

Чтобы увидеть, как эвристический подход к пороговому сравнению естественным образом распространяется на MLSAG-подписи, рассмотрим следующее. Для объединения подписантов допустим, что каждый участвующий подписант имеет часть ключа, которая накапливается, как и в случае с Musig, и каждый участник добавляет некоторые случайные скалярные величины, которые суммируются для получения $u_j$, $s_{j,\ell}$ и так далее на этапе обязательства и раскрытия. Формально доказательство невозможности подделки такого варианта реализации конфиденциальных MLSAG thring-транзакций, использующих одноразовые ключи в стиле CryptoNote при расширении ключа просмотра, также остаётся открытой задачей. Мы оставляем решение этой задачи более общего формального определения и реализации конфиденциальных thring-транзакций и их соответствующих свойств безопасности на будущее, например, в работе \cite{ruffct2}, которая будет вскоре опубликована.

%The first requirement to securely extend a threshold LSAG scheme to include CryptoNote-styled key structures and support ring confidential transactions with threshold MLSAGs is to demonstrate the security of the underlying scheme. While thresholdized MLSAG-style (MLSTAG) ring confidential transactions are perfectly functional (i.e.\ correct, linkable), the unforgeability of MLSTAGs remain an open question.

\subsubsection{Расширение до схемы $m$ из $n$}

В разделе \ref{naiveImplement} представлен простой пример реализации схемы $2$ из $2$ , который естественным образом расширяется до схемы $n$ из $n$. При помощи перестановки Диффи-Хеллмана мы можем расширить вышеуказанный подход до схемы пороговой подписи $(n-1)$ из $n$ следующим образом: участники делятся друг с другом своими $B_j$ и попарно вычисляют общие секреты $z_{i,j} = \mathcal{H}_{\text{agg}}(b_i B_j)$. Есть $\frac{n(n-1)}{2}$ отдельных общих секретов, совместно используемых $n$ участников, таким образом, $n-1$ участников могут восстановить все секреты. Следовательно, схема $(n-1)$ из $n$ может быть реализована как схема $\frac{n(n-1)}{2}$ из $\frac{n(n-1)}{2}$. Очевидно, существуют более общие подходы к реализации схемы $m$ из $n$, но мы не коснёмся их далее в этой работе.

\subsection{Конфиденциальные атомные свопы между блокчейнами с неопределённым отправителем}

Простые атомные свопы между блокчейнами с использованием thring-подписей возможны. Если всё идёт хорошо, своп происходит следующим образом: Элис отправляет $x$ монет AliceCoins в блокчейн AliceCoins с ключом $2$ из $2$, Боб отправляет $y$ монет BobCoins в блокчейн BobCoins с ключом $2$ из $2$, и как только обе стороны будут удовлетворены, они смогут забрать свои средства. Безусловно, мы не можем допускать, что всё пройдёт хорошо; как описано в работе \cite{back2014enabling}, транзакции возмещения позволяют не совсем честным сторонам остановить процесс в опасной среде. Остаётся закончить модель проведения атомным свопов между блокчейнами с неопределённым отправителем, описанную в работе \cite{back2014enabling}, для цифровой валюты, использующей схему проведения конфиденциальных транзакций, формализовав возможность транзакций возмещения для такой валюты (см.\ \cite{noether2018dlsag}).

\bibliographystyle{plain}
\bibliography{main}

\appendix

\section{Безопасность}\label{security}

В этом Приложении мы доказываем следующую теорему на основе игры, которая приводится в Определении \ref{game}. В Приложении \ref{otherProperties} нами рассматриваются некоторые другие свойства безопасности кольцевых подписей и их LSTAG варианта реализации. В пункте \ref{sigoracle} мы подробно описываем подписывающий оракул, о котором говорится в Определении \ref{game}, и его моделирование. В пункте \ref{forkingLemma} нами рассматривается лемма реализации форков «обратной перемоткой» при успешном выполнении. В пункте \ref{reducingA} мы обсуждаем первое сокращение возможности подделки и установку некоторых границ вероятности. В пункте \ref{forkingTwice} нами разъясняется подход к двойной реализации форка, а также приводится доказательство следующей теоремы.

\begin{theorem}
Допустим, $\adversary$ является фальсификатором $(t,\epsilon,q,n)$ для некоторого $\epsilon$, которое не является незначительным. Существует некоторое $t^\prime > 0$ и алгоритм $\mathcal{B}$, то есть решатель $(t+t^\prime, \epsilon^\prime, q)$ некоторой задачи дискретного логарифмирования для некоторого $\epsilon^\prime$, которое не является незначительным.
\end{theorem}

\subsection{Подписывающий оракул}\label{sigoracle}

В данном разделе мы объясняем, как используется подписывающий оракул в рамках игры, описанной в Определении \ref{game}.

Описывающий оракул, используемый в рамках игры по обеспечению невозможности подделки, предполагает наличие ситуации, когда фальсификатор $\adversary$ убеждает честную сторону вместе подписать какие-то документы перед тем, как сделать подделку. В случае с мультиподписями нам также необходимо учесть то, что злоумышленник $\adversary$ будет пытаться убедить честную сторону совместно построить некоторые мультиподписи для схожих документов. Благодаря такому сотрудничеству $\adversary$ получает некоторый контроль над данными подписи, поэтому необходимо, чтобы $\mathcal{SO}$ был интерактивным. При честном сотрудничестве $\adversary$ также необходимо знать, что индекс $\pi$ соответствует действительному подписанту, поэтому мы допускаем, что подписывающий оракул запрашивается со специальным индексом подписания $\pi$. Более того, сокращение $\adversary^\prime$ от $\adversary$ должно моделировать взаимодействие между $\adversary$ и любыми другими оракулами, в частности, с подписывающим оракулом.

$\mathcal{SO}$ берёт в качестве входа некоторый $\texttt{inp}_{\mathcal{SO}} = (\m, \underline{P}, \pi, \left\{\underline{X}^{(\ell)}\right\}_{\ell \in [r]})$, где $\m \in \left\{0,1\right\}^*$ является сообщением, $\underline{P}$ является кольцом публичных ключей, $\pi$ является специальным индексом, а $\left\{\underline{X}^{(\ell)}\right\}_{\ell \in [r]}$ является мультимножеством публичных ключей. $\mathcal{SO}$ и $\adversary$ взаимодействуют. $\mathcal{SO}$ выводит выделенный символ ошибки $\bot_{\mathcal{SO}}$, или же $\adversary$ успешно моделирует сотрудничество с честной стороной для получения мультиподписи.

\begin{description}
\item [Оракул:] $\adversary$ запрашивает $\mathcal{SO}$ при помощи некоторого $\left(M, \underline{P}, \pi, \left\{\underline{X}^{(\ell)}\right\}_{\ell \in [r]}\right)$.

\begin{enumerate}
\item $\mathcal{SO}$ проверяет, для каждого ли $\ell$ будет действительным $P_\ell = \Phi(\underline{X}^{(\ell)})$, а также проверяет соответствие $X_h \in \underline{X}^{(\ell)}$ и проверяет, чтобы было накоплено по крайней мере одно $P_\ell$. Если это не так, $\mathcal{SO}$ выводит $\bot_{\mathcal{SO}}$ и завершает процесс.

\item \label{dat1} В противном случае, $\mathcal{SO}$ выбирает данные подписания $\texttt{dat}_1 = (U_1, V_1, \left\{s_{1, \ell}\right\}_{\ell \neq \pi})$, вычисляет обязательство $\texttt{com}_1 \leftarrow \mathcal{H}_{\text{com}}(\texttt{dat}_1)$ и отправляет $\texttt{com}_1$ для $\adversary$.
%Otherwise, for each $\ell$, an honest orphan is selected randomly from the set of honest orphans in $\left\{L_{\ell,\lambda}\right\}_{\lambda \in \Lambda_\ell}$. Denote the associated index in $\left\{X_1, \ldots, X_R\right\}$ as $i(\ell)$. $\mathcal{SO}$ plays the role of one instance of the honest key $X_{i(\pi)}$ and $\adversary$ plays the role of all other keys in the famgraph of $Y_\pi$.

\item После того как $\adversary$ ответит множеством $\left\{\texttt{com}_j\right\}_{j = 2}^{n}$, $\mathcal{SO}$ отправляет $\texttt{dat}_{1}$ для $\adversary$.

\item После того как $\adversary$ ответит $\left\{\texttt{dat}_{j}\right\}_{j=2}^{n}$, $\mathcal{SO}$ проверяет, чтобы $\texttt{com}_j = \mathcal{H}_{\text{com}}(\texttt{dat}_j)$ для каждого $j$. Если это не так, $\mathcal{SO}$ выводит $\bot_{\mathcal{SO}}$ и завершает процесс.

\item $\mathcal{SO}$ завершает этап предварительной офлайн обработки подписи, решает $s_{\pi, j}$ и отправляет $s_{\pi,j}$ для $\adversary$.

\end{enumerate}

\end{description}

Символ $\bot_{\mathcal{SO}}$ означает только то, что моделирование $\mathcal{SO}$ не удалось. Если $\adversary$ ведёт себя неверно, но $\mathcal{SO}$ был смоделирован успешно, тогда возможно, что $\mathcal{SO}$ успешно смоделирует фальшивое выполнение $\texttt{Sign}$. Если $\mathcal{SO}$ был смоделирован успешно, это не приводит к $\bot_{\mathcal{SO}}$, но приводит к неверной подписи или сбою $\bot_{\texttt{Sign}}$ из $\texttt{Sign}$.

\subsection{Лемма реализации форка «обратной перемоткой» при успешном выполнении}\label{forkingLemma}

В данном разделе нами рассматривается технология двойного форка и общая лемма реализации форка. Вспомните, что для доказательства невозможности подделки нашей схемы достаточно доказать, что фальсификатор $\adversary$ с значимым преимуществом в рамках экзистенциальной игры невозможности подделки может быть сокращён до некоторого $\mathcal{B}$, который создаст четыре подделки, как было описано выше. Как обычно, мы используем сокращения и метасокращения $\adversary$ и общую лемму реализации форка для выполнения нашей задачи. Мы обозначаем сокращение $\adversary$ со скрытым (black box) доступом к $\adversary$ как $(\adversary^\prime)^\adversary$, и мы обозначаем процесс принятия сокращений как $\adversary \leadsto \adversary^\prime$. Наша стратегия доказательства примерно соответствует стратегии, описанной в работе \cite{maxwell2018simple}, и может быть представлена следующим образом:
\[\reduxChain.\]

К слову, наша стратегия состоит в доказательстве того, что если существует фальсификатор $\mathcal{A}$, то есть и сокращение $\adversary^\prime$ от $\adversary$, удовлетворяющее условие Леммы \ref{genfork}, позволяющей реализовать форк. Алгоритм реализации форка может быть «обёрнут» в $\adversary^{\prime \prime}$, по которому так же может быть реализован форк. Если $\adversary^\prime$ и $\adversary^{\prime \prime}$ имеют значимую вероятность принятия, то и $\texttt{fork}^{\adversary^{\prime \prime}}$ тоже, сокращается нами до некоторого алгоритма решения дискретного логарифма $\mathcal{B}$.

%We first reduce the forger $\adversary$ to some $\adversary^\prime$ that produces a forgery and some transcript information. We use a rewind-on-success forking meta-reduction $\texttt{fork}^{\adversary^\prime}$ to rewind the transcript of $\adversary$ to the first oracle query for a verification equation $c_{\ell+1} = H_{\texttt{sig}}(M,U_\ell,V_\ell)$ for some $\ell$ used in the successful forgery, seeking a second successful forgery. If successful, we have two forgeries with different $c_{\ell+1}$ values. We wrap $\texttt{fork}^{\adversary^\prime}$ in a reduction $\adversary^{\prime \prime}$ compatible with the forking lemma. We then use $\texttt{fork}^{\adversary^{\prime \prime}}$ to rewind the transcript of $\adversary^{\prime \prime}$ to the final key aggregation query of the form $\mathcal{H}_{\text{agg}}(X_h,L_\ell)$ that is used to compute any ring member $P_\ell$ or $P_\ell^\prime$ used in either forgery. $\texttt{fork}^{\adversary^{\prime \prime}}$ proceeds from this second rewind point with a new aggregation coefficient, looking for another success; that all previously computed aggregation coefficients are preserved. We then reduce $\texttt{fork}^{\adversary^{\prime \prime}}$ to some $\mathcal{B}$ that takes as input a discrete logarithm challenge $X_h$, has black-box access to $\texttt{fork}^{\adversary^{\prime \prime}}$, extracts oracle queries from its transcript, and uses them to solve the discrete logarithm problem for $X_h$.

\begin{lemma}[Общая лемма реализации форка]\label{genfork}
Допустим, $q, \eta \geq 1$. Допустим, $\mathcal{P}$ является любым PPT алгоритмом, который в качестве входа берёт $\texttt{inp}_\mathcal{P} = (\texttt{inp}, \underline{h})$, где $\underline{h} = (h_1, \ldots, h_q)$ является последовательностью ответов на запросы оракула ($\eta$-битными строками), и возвращает в качестве выхода $\texttt{out}_{\mathcal{P}}$ либо выделенный символ ошибки $\bot$, либо пару $(i, \texttt{out})$, где $i \in [q]$ а $\texttt{out}$ является некоторым выходом. Допустим, $\texttt{acc}_{\mathcal{P}}$ обозначает вероятность, что $\mathcal{P}$ не выводитt $\bot$ (где эта вероятность берётся по всем случайным монетам $\mathcal{P}$, распределению $\texttt{inp}$, всем выбранным $\underline{h}$).

Есть алгоритм $\texttt{fork}^{\mathcal{P}}$, который берёт в качестве входа некоторый $\texttt{inp}_{\texttt{fork}^{\mathcal{P}}} = \texttt{inp}_{\mathcal{P}}$ и в качестве выхода $\texttt{out}_{\texttt{fork}^{\mathcal{P}}}$ производит либо выделенный символ ошибки $\bot$, либо пару, состоящую из пар $((i, \texttt{out}), \linebreak (i^\prime, \texttt{out}^\prime))$, где $(i, \texttt{out})$ и $(i^\prime, \texttt{out}^\prime)$ являются выходами $\mathcal{P}$, при этом $i = i^\prime$. Кроме того, допуская вероятность, что $\texttt{fork}^{\mathcal{P}}$ связан снизу, мы получаем \[\texttt{acc}_{\texttt{fork}^{\mathcal{P}}} \geq \texttt{acc}_{\mathcal{P}} \left(\frac{\texttt{acc}_{\mathcal{P}}}{q} - \frac{1}{2^\eta}\right).\]
\end{lemma}

Доказательство читатель может найти в работе \cite{bellare2006multi}.

% of a version of this lemma where $\underline{i}$ is a single index, say $i^*$, not a vector of indices; that if $\adversary$ satisfies our definition with a list $\underline{i}$, we can parse the output $(\underline{i}, \texttt{out}) = ((i_1, i_2, \ldots), \texttt{out})$ as $(i_1, ((i_2, i_3, \ldots), \texttt{out}))$, to interpret as $(i^\prime, \texttt{out}^\prime)$ where $i^\prime = i_1$ and $\texttt{out}^\prime = ((i_2, i_3, \ldots), \texttt{out})$. Certainly this is also possibly with any of the indices. That is to say, the above vector extension of the index output $\underline{i}$ still satisfies the forking lemma from \cite{}.
% that since any finite totally ordered set with $k$ elements is order isomorphic to $\left\{1, 2, \ldots, k\right\}$, the lemma still holds true if the output $i$ can refer to an element in any finite totally ordered set.

\begin{description}
\item [Алгоритм $\texttt{fork}^{\mathcal{P}}$:] Допустим, $\eta > 1$ является параметром безопасности, $q > 1$ является полиномиальной функцией $\eta$. Допустим, $\mathcal{P}$ является любым PPT алгоритмом, соответствующим условиям Леммы \ref{genfork}.

%Let $\mathcal{I}$ be a deterministic polynomial-time algorithm that takes as input some $\texttt{inp}_{\mathcal{I}} = \texttt{out}_{\mathcal{P}}$ and produces as output an index $\texttt{out}_{\mathcal{I}} = j \in [q]$.

%The algorithm $\texttt{fork}^{\mathcal{P}}$ has access to $\mathcal{I}$, takes as input some $\texttt{inp}_{\texttt{fork}^{\mathcal{P}}} = \texttt{inp}_{\mathcal{P}}$, and

Алгоритм $\texttt{fork}^{\mathcal{P}}$ в качестве выхода выдаёт выделенный символ ошибки $\texttt{out}_{\texttt{fork}^{\mathcal{P}}} = \bot$ или какой-то $\texttt{out}_{\texttt{fork}^{\mathcal{P}}} = (i^\prime, \texttt{out}^\prime)$, где $j$ является индексом в $[q]$, а $\texttt{out}^\prime = (\texttt{out}, \texttt{out}^{\prime\prime}, \texttt{aux})$ таким образом, что $\texttt{out}$, $\texttt{out}^{\prime\prime}$ являются двумя выходами $\mathcal{P}$.

\begin{enumerate}
\item Берутся случайные монеты $\rho=\rho_\mathcal{P}$ для $\mathcal{P}$ и выбирается $\underline{h} \leftarrow (\left\{0,1\right\}^{\eta})^q$.

\item Выполняется $\texttt{out}_\mathcal{P} \leftarrow \mathcal{P}(\texttt{inp}_{\mathcal{P}}, \underline{h}; \rho)$.

\item Если $\texttt{out}_\mathcal{P} = \bot_\mathcal{P}$, выводится $\bot_{\texttt{fork}^{\mathcal{P}}}$ и процесс завершается. В противном случае $\texttt{out}_{\mathcal{P}} = (i, \texttt{out})$ для некоторых $\texttt{out}$.

\item Берётся новый $\underline{h}^\prime \leftarrow (\left\{0,1\right\}^\eta)^q$.

\item Последовательности запросов оракула склеиваются вместе $\underline{h}^* := (h_1, \ldots, h_{i-1}, h^\prime_i, \ldots, h^\prime_q)$.

\item Выполняется $\texttt{out}_{\mathcal{P}}^{\prime \prime} \leftarrow \mathcal{P}(\texttt{inp}_{\mathcal{P}}, \underline{h}^*; \rho)$.

\item Если $\texttt{out}_{\mathcal{P}}^{\prime \prime} = \bot_\mathcal{P}$, выводится $\bot_{\texttt{fork}^{\mathcal{P}}}$ и процесс завершается. В противном случае $\texttt{out}_{\mathcal{P}}^{\prime \prime} = (i^{\prime \prime}, \texttt{out}^{\prime \prime})$.

\item Если $i \neq i^{\prime \prime}$ или $i = i^{\prime \prime}$, но $h_{i} = h^{\prime}_{i}$, выводится $\bot_{\texttt{fork}^{\mathcal{P}}}$, и процесс завершается.

\item В противном случае выбираются некоторые вспомогательные данные $\texttt{aux}$, собирается $\texttt{out}^\prime = (\texttt{out}, \texttt{out}^{\prime\prime}, \texttt{aux})$, выводится $(i, \texttt{out}^\prime)$, и процесс завершается.
\end{enumerate}

\end{description}
%These immediately provide the following corollary.
Если $\mathcal{P}$ в качестве входа берёт сразу несколько последовательностей запросов оракула, мы можем провести соответствующий разбор, чтобы включить их в $\texttt{inp} \in \texttt{inp}_{\mathcal{P}}$. Если $\texttt{inp}_{\mathcal{P}}$ имеет некоторую другую последовательность $\underline{h}^*$ запросов оракула, объединённую подобным образом, то форк $\texttt{fork}^{\mathcal{P}}$ может быть снова реализован в блокчейне. В следующем разделе мы описываем каждый алгоритм в цепочке сокращений, включающих нашу стратегию $\reduxChain$, доказывающую их существование и значимость вероятности их принятия по мере развития.

\subsection{Сокращение $\mathcal{A}$}\label{reducingA}

В данном разделе мы начинаем наш процесс реализации форка путём построения первого сокращения $\adversary^\prime$ от $\adversary$ в цепочке сокращений. Мы объясняем, как $\adversary^\prime$ моделирует каждого оракула, и даём лемму в отношении вероятности принятия $\adversary^\prime$.

Мы производим сокращение $\adversary^\prime$ от $\adversary$подобно тому, как это происходит в случае с Леммой \ref{genfork}, которая применяется к алгоритму $\mathcal{P}$, который берёт в качестве входа некоторый $\texttt{inp}_\mathcal{P} = (\texttt{inp}, \underline{h})$. $\adversary^\prime$ берёт в качестве входа $\texttt{inp}_{\adversary^\prime} = (\texttt{inp}, \underline{h}_{\text{sig}})$. Тем не менее $\adversary^\prime$ должен смоделировать оба запроса $\mathcal{H}_{\text{sig}}$ и $\mathcal{H}_{\text{agg}}$, поэтому мы определяем $\texttt{inp} := (\texttt{inp}_{\adversary}, \underline{h}_{\text{agg}})$. Другими словами, $\adversary^\prime$ берёт в качестве входа $\texttt{inp}_{\adversary^\prime} = (\texttt{inp}_\mathcal{P}, \underline{h}_{\text{agg}}) = \left((X_h, \underline{h}_{\text{agg}}), \underline{h}_{\text{sig}}\right)$.

$\adversary^\prime$ отвечает на запросы оракула, отправляя $\underline{h}_{\text{agg}}$ и $\underline{h}_{\text{sig}}$, как описано ниже. $\adversary^\prime$ дополняет выход $\adversary$, используя в качестве выхода $\bot$, если $\adversary$ выдаст ошибку. С другой стороны, если выход $\adversary$ будет не $\bot$, допустим, $\texttt{forg} = \left(\m^*, \sigma, \left\{\underline{X}^{(\ell)}\right\}_\ell\right)$, $\adversary^\prime$ воспроизведёт это в своём выходе, но дополнит некоторой информацией транскрипта, $\texttt{out}_{\adversary^\prime} = (i_{\text{sig}}, \texttt{out}^*)$, где $\texttt{out}^* = (\texttt{forg}, i_{\text{sig}}, h_{\text{sig}, i_{\text{sig}}}, \ell_{\text{sig}}, \pi_{\text{sig}}, i_{\text{agg}}, h_{\text{agg}, i_{\text{agg}}}, \underline{a})$ для некоторой подписи и накопления индексов $i_{\text{sig}}, i_{\text{agg}}$ и ответов $h_{\text{sig}, i_{\text{sig}}}, h_{\text{agg}, i_{\text{agg}}}$, некоторых индексов кольца $\ell_{\text{sig}}, \pi_{\text{sig}}$ и списка коэффициентов $\underline{a}$ выделенных из транскрипта следующим образом:
\begin{enumerate}
\item $(i_{\text{sig}}, \ell_{\text{sig}})$ определяются таким образом, что ответ на первый запрос, обращённый $\adversary$ к $\mathcal{H}_{\text{sig}}$ для решения любого уравнения верификации, используемого при фальсификации, будет $i_{\text{sig}}^{th}$ запросом и займёт место для $\ell_{\text{sig}}^{th}$ члена кольца, то есть $h_{\text{sig}, i_{\text{sig}}} = c_{\ell_{\text{sig}}+1} = \mathcal{H}_{\text{sig}}(M, P_{\ell_{\text{sig}}}, L_{\ell_{\text{sig}}}, R_{\ell_{\text{sig}}})$ для некоторого индекса $\ell$.

\item $\pi_{\text{sig}}$ определяется таким образом, что ответ на окончательный запрос, сделанный $\adversary$ к $\mathcal{H}_{\text{sig}}$ для решения любого уравнения верификации, используемого при фальсификации, будет $\pi_{\text{sig}}^{th}$ задачей подписи, то есть окончательной задачей подписи, которая должна быть решена в транскрипте, будет $c_{\pi_{\text{sig}}} = \mathcal{H}_{\text{sig}}(M, P_{\pi_{\text{sig}}-1}, L_{\pi_{\text{sig}}-1}, R_{\pi_{\text{sig}}-1})$.

\item $i_{\text{agg}}$ является индексом первого запроса накопления, сделанного любым членом $\underline{X}^{(\ell_{\text{sig}})}$, то есть коэффициентом накопления по $X_h$ в $\underline{X}^{(\ell)}$ будет $h_{\text{agg},i_{\text{agg}}}$.

\item $\underline{a}$ содержит коэффициенты накопления всех выбранных со злым умыслом ключей в $\underline{X}^{(\ell_{\text{sig}})}$ (упорядоченных некоторым установившимся образом).


%\item the aggregation coefficients are $\underline{a} = (\underline{a}^{(1)}, \ldots, \underline{a}^{(R)})$ where each $\underline{a}^{(\ell)} = (a^{(\ell)}_1, a^{(\ell)}_2, \ldots)$ are the aggregation coefficients for the keys in $\underline{X}^{(\ell)}$.
\end{enumerate}
%In particular, $\adversary$ sees the first oracle response from $\mathcal{H}_{\text{sig}}$ used in a verification equation as $c_{\ell_{\text{sig}}+1} = h_{\text{sig}, i_{\text{sig}}}$, sees the final oracle response from $\mathcal{H}_{\text{sig}}$ used in a verification equation used to compute $c_{\pi_{\text{sig}}}$, and sees the coefficient on $X_h$ for the $\ell_{\text{sig}}^{th}$ ring member as $\alpha = h_{\text{agg}, i_{\text{agg}}}$. $\adversary^\prime$ reports all this information together with the forgery itself (and possibly additional data packed into $\texttt{out}$ besides $\texttt{forg}$).


\begin{lemma}
Допустим, $\adversary$ делает самое большее $q$ запросов случайного оракула и не выводит $\bot_\adversary$. Каждый запрос, обращённый к $\mathcal{H}_{\text{sig}}$ для решения уравнений верификации, делается $\adversary$ до завершения процесса, за исключением вероятности, заданной выше $1 - (1-(\p - q)^{-1})^{r}$ (обусловленной тем, что $\adversary$ не выдаст $\bot_\adversary$).
\end{lemma}
\begin{proof}
В случае если $\adversary$ не запросит у $\mathcal{H}_{\text{sig}}$ верификации, запрос потребует, чтобы $\adversary$ угадал выход $\mathcal{H}_{\text{sig}}$ для некоторого запроса случайным образом. Это может произойти с самой большой вероятностью $(\p - q)^{-1}$ (результат должен исключать уже сделанные запросы). Следовательно, вероятность успеха в этом случае даже по одному для любого из запросов верификации $r$ составит $1 - (1 - (\p - q)^{-1})^{r}$. Это верхний предел вероятности, что $\adversary$ сделает это случайным образом, а не запрашивая решения уравнения верификации.
\end{proof}

Следствием этой леммы является то, что $\adversary^\prime$ может без каких-либо затруднений найти $i_{\text{sig}}$, $h_{\text{sig}, i_{\text{sig}}}$, $\ell_{\text{sig}}$ и $\pi_{\text{sig}}$.

\begin{lemma}
Допустим, $\adversary$ делает самое большее $q$ запросов случайного оракула и не выводит $\bot$. Каждый запрос, обращённый к $\mathcal{H}_{\text{agg}}$ для получения каждого коэффициента накопления по $X_h$, делается $\adversary$ до завершения процесса, за исключением вероятности, заданной выше $1 - (1- (\p - q)^{-1})^{nr}$ (обусловленной тем, что $\adversary$ не выдаст $\bot_\adversary$).
\end{lemma}
\begin{proof}
В случае если $\adversary$ не сделает один этих запросов, необходимо, чтобы $\adversary$ угадал выход $\mathcal{H}_{\text{agg}}$. При наличии $r$ членов кольца, каждый из которых имеет дополняющие ключи $\underline{X}^{(\ell)}$ таким образом, что $\left|\underline{X}^{(\ell)}\right| \leq n$ имеет самое большее $nr$ запросов с вероятностью успешного угадывания $(\p - q)^{-1}$. Следовательно, вероятность успеха в этом случае, даже в случае $nr$ попыток, составит $1 - (1- (\p - q)^{-1})^{nr}$.
\end{proof}

Следствием является то, что $\adversary^\prime$ может без каких-либо затруднений выделить $i_{\text{agg}}$ и $h_{\text{agg}, i_{\text{agg}}}$.

\begin{lemma}
Допустим, $\adversary$ является фальсификатором $(t, \epsilon, n, q)$. Допустим, $E$ является случаем, когда $\adversary$ не выводит $\bot$. В случае $E$ для каждой $1 \leq \ell \leq r$, запрос, направленный $\mathcal{H}_{\text{sig}}$ для решения задачи решения уравнения верификации $c_{\ell+1}$, делается после запроса, направленного $\mathcal{H}_{\text{agg}}$ для получения коэффициента накопления по $X_h$ в соответствующем $\underline{X}^{(\ell)}$, за исключением вероятности, заданной выше $1-(1-(\p - q)^{-1})^{r}$.
\end{lemma}
\begin{proof} Так как $\Phi(\underline{X}^{(\ell)}) = P_\ell$ является частью предварительного образа, для $c_{\ell+1}$, вероятность того, что $\adversary$ сможет вычислить $c_{\ell+1}$ до запроса вычисления $P_\ell$ (если допустить, что все запросы, кроме этого окончательного, были сделаны), составляет самое большее $(\p - q)^{-1}$, и существует самое большее $r$ таких запросов, связанных с фальшивкой.
\end{proof}

Эти леммы и следствия демонстрируют, что все запросы верификации появляются, и каждое из них появляется после того, как будут вычислены коэффициенты накопления. Имея данные леммы, мы можем описать $\adversary^\prime$. $\adversary^\prime$ помещает $\adversary$ в «чёрный ящик», моделируя все запросы оракулов, которые делает $\adversary$. $\adversary^\prime$ ведёт внутренние таблицы, обозначенные как $\mathbb{T}_{\text{sig}}$, $\mathbb{T}_{\texttt{agg}}$, и счётчик, обозначенный как $\texttt{ctr}$, чтобы отслеживать запросы, которые делаются с целью поддержания внутренней согласованности, а также, чтобы отслеживать индексы запросов оракула.

\begin{description}
\item [Алгоритм $\adversary^\prime$:] В качестве входа $\adversary^\prime$ берёт $\texttt{inp}_{\adversary^\prime} = ((X_h, \underline{h}_{\text{agg}}), \underline{h}_{\text{sig}})$. $\adversary^\prime$ имеет доступ к «чёрному ящику» с $\adversary$, моделирует запросы, как описано ниже, и в качестве выхода выдаёт либо выделенный символ ошибки $\bot$, либо некоторый $(\underline{i}, \texttt{out})$.

\begin{enumerate}
\item $\adversary^\prime$ выбирает случайные монеты $\rho = \rho_\adversary$, устанавливает $\texttt{ctr}:=0$ и задаёт $\texttt{inp}_\adversary := \left\{X_h\right\}$.

\item $\adversary^\prime$ выполняет $\adversary(\texttt{inp}_\adversary; \rho_\adversary)$, отвечая на запросы оракула, которые делает $\adversary$, как описано ниже.

\item Если $\adversary$ выводит $\bot_\adversary$, $\adversary^\prime$ выводит $\bot_{\adversary^\prime}$ и завершает процедуру.

\item В противном случае $\adversary$ выводит поделку $\texttt{forg} = (\m^*, \sigma, \left\{\underline{X}^{(\ell)}\right\}_{\ell})$.

\item $\adversary^\prime$ находит все запросы верификации в транскрипте и находит следующее:

\begin{enumerate}
\item индекс запроса $i_{\text{sig}}$ первого уравнения верификации, которое использовалось при фальсификации;

\item ответ $h_{\text{sig},i_{\text{sig}}}$ на этот первый запрос верификации;

\item индекс кольца $\ell_{\text{sig}}$ для входа этого первого запроса верификации (соответствующий уравнению верификации $c_{\ell_{\text{sig}}+1} = \mathcal{H}(M, P_{\ell_{\text{sig}}}, L_{\ell_{\text{sig}}}, R_{\ell_{\text{sig}}}) = h_{\text{sig}, i_{\text{sig}}}$);

\item ответ $h_{\text{sig}, i_{\text{sig}}^\prime}$ на окончательный запрос верификации;

\item индекс кольца $\pi_{\text{sig}}-1$ для входа этого запроса, соответствующий схожему уравнению верификации $c_{\pi_{\text{sig}}} = \mathcal{H}(M, P_{\pi_{\text{sig}}-1}, L_{\pi_{\text{sig}} -1}, R_{\pi_{\text{sig}} - 1})$;

\item индекс запроса $i_{\text{agg}}$ первого запроса накопления для любого члена $\underline{X}^{(\ell_{\text{sig}})}$;

\item ответ $h_{\text{agg}, i_{\text{agg}}}$ на этот запрос; и, наконец,

\item $\adversary^\prime$ находит все остальные коэффициенты накопления для членов $\underline{X}^{(\ell_\text{sig})}$ в $\mathbb{T}_{\texttt{agg}}$, скажем, $\underline{a}$. Смотрите описание оракула $\mathcal{H}_{\text{agg}}$ для получения дополнительной информации.
\end{enumerate}
%\item $\adversary^\prime$ c

\item $\adversary^\prime$ выводит $\texttt{out}_{\adversary^\prime} = (i_{\text{sig}}, (\texttt{forg}, i_{\text{sig}}, h_{\text{sig}, i_{\text{sig}}}, \ell_{\text{sig}}, \pi_{\text{sig}}, i_{\text{agg}}, h_{\text{agg}, i_{\text{agg}}}, \underline{a}))$.
\end{enumerate}

%A complete description of $\adversary^\prime$ requires describing oracle query responses.


%From $\mathcal{A}^{\mathcal{SO},\underline{\mathcal{H}}}$, we consider how a reduction $\adversary^\prime$ simulates $\mathcal{SO}$ and the members of $\underline{\mathcal{H}}$ for $\adversary$. We assume $\mathcal{A}^\prime$ takes as input an honest key $X_h$, a pair of oracle query responses $\underline{h}_{\text{agg}} = (h_{\text{agg},1}, h_{\text{agg},2}, \ldots)$ and $\underline{h}_{\text{sig}} = (h_{\text{sig},1}, h_{\text{sig},2}, \ldots)$, and we assume $\adversary^\prime$ tracks internal tables $\mathbb{T}_{\texttt{com}}$, $\mathbb{T}_{\texttt{agg}}$, $\mathbb{T}_{\texttt{sig}}$, and counters $\texttt{ctr}_{\texttt{agg}}, \texttt{ctr}_{\texttt{sig}}$.

\begin{description}


\item [Моделирование $\mathcal{H}_{\text{com}}$:] Чтобы смоделировать запросы в форме $\mathcal{H}_{\text{com}}(\texttt{inp})$, $\adversary^\prime$ отслеживает внутреннюю таблицу $\mathbb{T}_{\text{com}}$. $\adversary^\prime$ проверяет, пуста или нет $\mathbb{T}_{\text{com}}[\texttt{inp}]$. Если пуста, выбирается случайный $\texttt{out} \overset{\$}{\leftarrow} \left\{0,1\right\}^\eta$ и сохраняет $\mathbb{T}_{\text{com}}[\texttt{inp}] \leftarrow \texttt{out}$. В противном случае $\mathbb{T}_{\text{com}}[\texttt{inp}]$ отправляется $\adversary$.

\item [Моделирование $\mathcal{H}_{\text{ki}}$:] Чтобы смоделировать запросы, которые делает $\adversary$ в форме $\mathcal{H}_{\text{ki}}(\texttt{inp})$, $\adversary^\prime$ отслеживает внутреннюю таблицу $\mathbb{T}_{\text{ki}}$. $\adversary^\prime$ проверяет, пуста или нет $\mathbb{T}_{\text{ki}}[\texttt{inp}]$. Если пуста, выбирается случайная точка $Y^\prime \in \group$ и сохраняется $\mathbb{T}_{\text{ki}}[\texttt{inp}] \leftarrow Y^\prime$. В противном случае $\mathbb{T}_{\text{ki}}[\texttt{inp}]$ отправляется $\adversary$.


\item [Моделирование $\mathcal{H}_{\text{agg}}$:] $\adversary^\prime$ тщательно отслеживает запросы накопления и всегда гарантирует, что коэффициент накопления для $X_h$ будет выбран после всех остальных коэффициентов.

\begin{enumerate}
\item $\adversary$ запрашивает $\mathcal{H}_{\text{agg}}$, отправляя $\texttt{inp}$.

\item $\adversary^\prime$ проверяет, определена или нет $\mathbb{T}_{\text{agg}}[\texttt{inp}]$. Если не определена, $\adversary$ делает следующее:

\begin{enumerate}
\item $\adversary^\prime$ проверяет, можно ли разобрать $\texttt{inp}$ как некоторое $(Y,\underline{X})$. Если нет, $\adversary^\prime$ берёт случайные данные $\mathbb{T}_{\texttt{agg}}[\texttt{inp}] \overset{\$}{\leftarrow} \scalarField$;

\item в противном случае $\adversary^\prime$ разбирает $\texttt{inp} = (Y,\underline{X})$ и проверяет, чтобы $X_h \in \underline{X}$. Если это не так, то для каждого $Y^\prime \in \underline{X}$, $\adversary^\prime$ берёт случайные данные $\mathbb{T}_{\texttt{agg}}[Y^\prime, \underline{X}] \overset{\$}{\leftarrow} \scalarField$;

\item в противном случае $\texttt{inp} = (Y, \underline{X})$ для некоторого $Y \in \underline{X}$ так, чтобы $X_h \in \underline{X}$, но $\mathbb{T}_{\texttt{agg}}[\texttt{inp}]$ пока остаётся неопределённой. $\adversary^\prime$ проверяет, является ли $\mathbb{T}_{\texttt{agg}}[X_h, \underline{X}]$ определённой. Если да, $\adversary^\prime$ выводит $\bot_{\text{agg}}$ и завершает процесс;

\item в противном случае для каждого $Y^\prime \in \underline{X} \setminus\left\{X_h\right\}$ так, чтобы $\mathbb{T}_{\text{agg}}[Y^\prime, \underline{X}]$ была неопределённой, $\adversary^\prime$ выбирает случайные данные $\mathbb{T}_{\texttt{agg}}[Y^\prime, \underline{X}] \overset{\$}{\leftarrow} \scalarField$;

\item после того как все данные $\underline{X}$, кроме $X_h$, будут введены в $\mathbb{T}_{\text{agg}}$, $\adversary^\prime$ увеличит значение $\texttt{ctr}_{\texttt{agg}}$ и сохранит $\mathbb{T}_{\texttt{agg}}[X_h, \underline{X}] \leftarrow h_{\text{agg}, \texttt{ctr}_{\texttt{agg}}}$.
\end{enumerate}

\item $\adversary^\prime$ выводит $\mathbb{T}_{\text{agg}}[\texttt{inp}]$.

\end{enumerate}

Следует отметить, что $\adversary^\prime$ выдаёт $\bot_{\text{agg}}$ только в том случае, если $\mathbb{T}_{\text{agg}}[X_h, \underline{X}]$ определена, но некоторое $Y \in \underline{X}$ имеет определённую $\mathbb{T}_{\text{agg}}[Y, \underline{X}]$. Если $\adversary^\prime$ следует протоколу, этого никогда не произойдёт. Во всех остальных случаях коэффициент накопления для $X_h$ определяется после того, как будут определены все остальные коэффициенты. Это важно для нашего доказательства невозможности подделки.

\item [Моделирование $\mathcal{H}_{\text{sig}}$:] Чтобы смоделировать запросы, которые делает $\adversary$ для подписания \linebreak $\mathcal{H}_{\text{sig}}(\texttt{inp})$, $\adversary^\prime$ проверяет, определена или нет $\mathbb{T}_{\texttt{sig}}[\texttt{inp}]$. Если нет, $\adversary^\prime$ проверяет, можно ли разобрать $\texttt{inp}$ как $\texttt{inp} = (M,P,U,V)$ для некоторого $M$ и групповых точек $P,U,V$. Если нет, случайным образом выбирается $\mathbb{T}_{\texttt{sig}}[\texttt{inp}] \overset{\$}{\leftarrow} \left\{0,1\right\}^\eta$. В противном случае $\texttt{ctr}_{\texttt{sig}}$ увеличивается и сохраняется $\mathbb{T}_{\texttt{sig}}[M,P,U,V] \leftarrow h_{\text{sig},\texttt{ctr}_{\texttt{sig}}}$. Так или иначе, $\adversary^\prime$ отправляет $\mathbb{T}_{\texttt{sig}}[\texttt{inp}]$ для $\adversary$.

\item [Моделирование $\mathcal{SO}$:] Для простоты обозначения $\mathcal{SO}$ использует обозначения, предполагающие, что это первый член объединения, начинающий процесс подписания (с индексом $j=1$ в объединении). $\adversary^\prime$ моделирует $\mathcal{SO}$ следующим образом:

%We now describe how the reduction $\adversary^\prime$ simulates signing oracle queries made by $\adversary$. We take care to construct $\adversary^\prime$ so as to output some $\bot_i$ if oracle queries occur in an order that does not allow simulation of $\mathcal{SO}$ by backpatching as described in \cite{} and \cite{maxwell2018simple}.

\begin{enumerate}
\item $\adversary$ запрашивает $\mathcal{SO}$, используя $\texttt{inp}_{\mathcal{SO}}$.

\item После получения запроса $\adversary^\prime$ разбивает $\texttt{inp}$ как $\left(M, \underline{P}, \pi, \left\{\underline{X}^{(\ell)}\right\}_{1 \leq \ell \leq r}\right)$ так, чтобы $\left|\underline{X}^{(\ell)}\right| \geq 2$ для некоторого $\ell$ и для каждого $\ell$, $\left|\underline{X}^{(\ell)}\right| \leq n$, $X_h \in \underline{X}^{(\ell)}$ и $P_\ell \in \underline{P}$ выводились на основе соответствующего $\underline{X}^{(\ell)}$. Если $\adversary^\prime$ не может произвести такое разбиение, $\adversary^\prime$ отправляет $\bot_{\mathcal{SO}}$ $\adversary$, чтобы обозначить, что запрос отклонён, и останавливает моделирование $\mathcal{SO}$.

\item В противном случае $\adversary^\prime$ выбирает данные подписания $\texttt{dat}_1$, как это делалось на этапе \ref{dat1}, описанном в разделе \ref{sigoracle}, вычисляет обязательство $\texttt{com}_1$ и отправляет $\texttt{com}_1$ $\adversary$ следующим образом:

\begin{enumerate}
\item $\adversary^\prime$ увеличивает значение $\texttt{ctr}$ и берёт критическое обязательство $c_\pi \leftarrow h_{\text{sig},\texttt{ctr}_{\texttt{sig}}}$.

\item $\adversary^\prime$ выбирает случайный набор данных подписания $\left\{s_{1,\ell}\right\}_{\ell \in [r]}$ (включая индекс $\ell = \pi$).

\item $\adversary^\prime$ вычисляет $L_{1, \pi} = s_{1,\pi} G + c_{\pi} P_\pi$ и $R_{1, \pi} = s_{1,\pi} H_\pi + c_\pi J$, собирает данные подписи $\texttt{dat}_1 := (L_{1,\pi}, R_{1,\pi}, \left\{s_{1,\ell}\right\}_{\ell \in [r], \ell \neq \pi})$ и выбирает случайное $\texttt{com}_1 \overset{\$}{\leftarrow} \left\{0,1\right\}^\eta$.

\item если $\mathbb{T}_{\texttt{com}}[\texttt{dat}_1]$ определена, $\adversary^\prime$ останавливает моделирование $\mathcal{SO}$, выводит $\bot_1$ чтобы указать, что некоторые $\texttt{dat}_1$ уже были использованы, и завершает процедуру;

\item в противном случае, $\adversary^\prime$ моделирует запрос $\mathcal{H}_{\text{com}}$ устанавливая $\mathbb{T}_{\texttt{com}}\left[\texttt{dat}_1\right] \leftarrow \texttt{com}_1$, отправляет $\texttt{com}_1$ to $\adversary$.

%\item Later, the assignment will be made $\mathbb{T}_{\texttt{sig}}[M,U_{\pi-1}, V_{\pi-1}] \leftarrow c_\pi$.

\end{enumerate}

\item После того как $\adversary$ ответит обязательствами $\underline{\texttt{com}} = \left\{\texttt{com}_j\right\}_{j \in [n], j \neq 1}$, $\adversary^\prime$ произведёт некоторую «распаковку», после чего отправит $\texttt{dat}_1$ $\adversary$.
\begin{enumerate}
\item Для каждого $j > 1$, $\adversary^\prime$ ищет $\mathbb{T}_{\texttt{com}}$ на предмет наличия $\texttt{dat}$ так, чтобы $\mathbb{T}_{\texttt{com}}\left[\texttt{dat}\right] = \texttt{com}_j$.

\item Если для какого-либо $j$ найдено более одного $\texttt{dat}$, $\adversary^\prime$ останавливает моделирование $\mathcal{SO}$, выводит $\bot_2$ и завершает процедуру.

\item Если для какого-либо $j$ не было найдено никаких $\texttt{dat}$, $\adversary^\prime$ задаёт $\texttt{alert}_1 \leftarrow \texttt{true}$.

\item \label{gather} В противном случае для каждого $\texttt{dat} = \texttt{dat}_j$ в $\mathbb{T}_{\texttt{com}}$ обнаруживаются ровно одни $\texttt{com}_j$. Ели какие-либо $\texttt{dat}_j$ не могут быть разбиты как $(U_j, V_j, \left\{s_{j, \ell}\right\}_{\ell \neq \pi})$, $\adversary^\prime$ задаёт $\texttt{alert}_2 \leftarrow \texttt{true}$.

%halts simulation of $\mathcal{SO}$ with $\bot_3$.

\item В противном случае для каждого $\texttt{dat}_j$ в $\mathbb{T}_{\texttt{com}}$ обнаруживаются ровно одни $\texttt{com}_j$, и они могут быть разбиты на последовательность $(U_j, V_j, \left\{s_{j,\ell}\right\})$. После разбиения каждых $\texttt{dat}_j$, $\adversary^\prime$ выполняет следующее:
\begin{enumerate}
\item $\adversary^\prime$ вычисляет $U = \sum_j U_j$, $V = \sum_j V_j$ и $s_\ell = \sum_j s_{j,\ell}$ для каждого $\ell \neq \pi$;

\item $\adversary^\prime$ проверяет, есть ли последовательность $(M, P_\ell, U, V)$ в $\mathbb{T}_{\texttt{sig}}$. Если есть, $\adversary^\prime$ станавливает моделирование $\mathcal{SO}$, выводит $\bot_3$ и завершает процедуру;

\item в противном случае, $\adversary^\prime$ увеличивает значение $\texttt{ctr}_{\texttt{sig}}$, задаёт $c_{\pi+1} \leftarrow h_{\text{sig},\texttt{ctr}_{\texttt{sig}}}$ и сохраняет $\mathbb{T}_{\texttt{sig}}[M, P_\ell, U,V] \leftarrow c_{\pi+1}$;

\item для каждого $\ell = \pi+1, \pi+2, \ldots, \pi-2$, $\adversary^\prime$ вычисляет $L_\ell = s_\ell G + c_\ell P_\ell$ и $R_\ell = s_\ell H_\ell + c_\ell J$ и проверяет есть ли последовательность $(M, P_\ell, L_\ell, R_\ell)$ в $\mathbb{T}_{\texttt{sig}}$. Если есть, $\adversary^\prime$ останавливает моделирование $\mathcal{SO}$, выводит $\bot_3$ и завершает процедуру;

\item в противном случае, $\adversary^\prime$ увеличивает значение $\texttt{ctr}_{\texttt{sig}}$, задаёт $c_{\ell+1} \leftarrow h_{\text{sig},\texttt{ctr}_{\texttt{sig}}}$ и сохраняет \[\mathbb{T}_{\texttt{sig}}[M, P_\ell, L_\ell, R_\ell] \leftarrow c_{\ell+1}\] а затем переходит к следующему $\ell$;

\item $\adversary^\prime$ проверяет, является ли $\mathbb{T}_{\texttt{sig}}\left[M, P_{\pi-1}, L_{\pi-1}, R_{\pi-1}\right]$ пустой. Если нет, $\adversary^\prime$ останавливает моделирование $\mathcal{SO}$, выводит $\bot_3$ и завершает процедуру;

\item в противном случае, $\mathbb{T}_{\texttt{sig}}\left[M,s_{\pi-1}G + c_{\pi-1} P_{\pi-1}, s_{\pi-1}H_{\pi-1} + c_{\pi-1}J\right] \leftarrow c_\pi$.

\end{enumerate}

\item $\adversary^\prime$ отправляет $\texttt{dat}_1$ $\adversary$.

\end{enumerate}

\item После того как $\adversary$ ответит, отправив $\underline{\texttt{dat}}^\prime = \left\{\texttt{dat}^\prime_j\right\}_{j \neq 1}$, $\adversary^\prime$ проверит $\texttt{com}_j = \mathbb{T}_{\texttt{com}}[\texttt{dat}^\prime_j]$ для каждого $j$. Если есть какое-либо несоответствие, $\adversary^\prime$ отправляет $\bot_{\mathcal{SO}}$ $\adversary$, чтобы указать на успешное моделирование неудавшегося процесса подписания.

\item В противном случае, если $\texttt{alert}_1=\texttt{true}$ или $\texttt{alert}_2 = \texttt{true}$, $\adversary^\prime$ выдаёт $\bot_4$ и завершает процедуру.

\item В противном случае, $\adversary^\prime$ отправляет $s_{1, \pi}$ $\adversary$ что для $\adversary$ является достаточной информацией для того, чтобы вычислить оставшуюся часть подписи.

%some $\texttt{dat}_j$ distinct from the signing data Otherwise, $\adversary^\prime$ sends $s_{j^\prime, \pi}$ to $\adversary$.

\end{enumerate}

\end{description}

\end{description}

%Note that although $\adversary^\prime$ outputs $(\underline{i}, \texttt{out})$, we can still apply $\texttt{fork}^\cdot$ by interpreting the output as $(i_1, \texttt{out}^\prime)$ where $\texttt{out}^\prime := \underline{i}\setminus \left\{i_1\right\}$, $\underline{i} = (i_1, i_2, \ldots)$, and $\underline{i} \setminus \left\{i_1\right\} = (i_2, \ldots)$.

Если выход является одним из символов из $\left\{\bot_1, \bot_2, \bot_3, \bot_4\right\}$, то $\adversary^\prime$ фактически завершает процесс: это символы ошибки, которые указывают на то, что происходит что-то странное с порядком присвоения значений оракулом при моделировании $\mathcal{SO}$. Это указывает на ошибку подписывающего оракула из-за неправильно сформированного запроса или какого-либо другого неверного порядка событий. Мы докажем, что такая вероятность ничтожна.

Более того, $\bot_{\mathcal{SO}}$ появляется только в том случае, если $\adversary$ запрашивает $\mathcal{SO}$, используя что-то, что выходит за рамки игры доказательства невозможности подделки, описанной в определении \ref{game}, или же отправляет обязательства, которые не открылись надлежащим образом. $\adversary^\prime$ не заканчивает процесс, поскольку это удачные случаи моделирования ошибки процесса подписания, а не ошибка моделирования.

Нами исследуется вероятность приемлемости для $\adversary^\prime$.

\begin{lemma}\label{firstNonFail}
Допустим $\mathcal{A}$ является фальсификатором $(t,\epsilon,q,n)$, имеющим доступ к $\mathcal{SO}$ и $\underline{\mathcal{H}}$, и допустим, что $\adversary^\prime$ является каким-либо сокращением $\mathcal{A}$, моделирующим запросы оракула, как это было описано выше. Допустим $t^\prime > 0$, и, допустим, $c > 0$ является тем временем, что необходимо $\adversary^\prime$ для того, чтобы случайным образом выбрать новый элемент $\mathbb{Z}_\mathfrak{p}$ или $\group$. Тогда за время, составляющее самое большее $t+t^\prime$ и с самой большей вероятностью $\epsilon^\prime = \epsilon_1 + \epsilon_2 + \epsilon_3 + \epsilon_4$, $\adversary^\prime$ завершит процесс, не выводя какой-либо $\bot_i \in \left\{\bot_1, \bot_2, \bot_3, \bot_4, \bot_{\text{agg}}\right\}$, где
\begin{align*}
\epsilon_1 =& 1 - \prod_{k \in [q-1]} (1-k \mathfrak{p}^{-r-1}) &
\epsilon_2 =& 1 - \prod_{k \in [q-1]} (1-k \mathfrak{p}^{-1}) \\
\epsilon_3 =& 1 - \prod_{k \in [q-1]} (1-k \mathfrak{p}^{-4}) &
\epsilon_4 =& 1 - \text{exp}(-\frac{-t^\prime(t^\prime-c)}{2(\mathfrak{p}-q)c^2}).
\end{align*}
\end{lemma}

\begin{proof}
Символы ошибки разбиваются, если $\adversary^\prime$ выдаёт некоторый $\bot$ и завершает процесс, поэтому вероятность появления какого-либо символа $\bot$ равна сумме каждого из них, взятого отдельно. Другими словами, если $E$ является случаем, когда $\adversary^\prime$ выдаёт некоторый $\bot$ и завершает процесс, а $E_i$ является случаем, когда $\adversary^\prime$ выдаёт $\bot_i$ для некоторого $ i \in \left\{1,2,3,4,\text{agg}\right\}$ и завершает процесс, то мы получаем $\epsilon_i = \mathbb{P}[E_i]$ и по закону полной вероятности $\mathbb{P}[E] = \mathbb{P}[E \mid E_{\text{agg}}]\mathbb{P}[E_{\text{agg}}] + \sum_{i \in [4]} \mathbb{P}[E \mid E_i]\mathbb{P}[E_i]$.

Более того, каждая условная вероятность в данном случае, очевидно, будет равна $1$ (вероятность того, что $\adversary^\prime$ некоторый $\bot_i$, учитывая тот факт, что $\adversary^\prime$ выводит $\bot_3$, равна $1$, например), поэтому мы имеем простую сумму. Следовательно, ограничение вероятности приемлемости, описанное ниже, эквивалентно ограничению каждой вероятности каждого из этих случаев ошибки, описанных выше. Мы упрощаем анализ: $\mathbb{P}[E_{\text{agg}}] = 0$ по структуре.

%Define for convenience $\epsilon_i := \mathbb{P}\left[E_i\right]$.

\begin{description}
\item [Ограничение $\epsilon_1$:] Если $\adversary^\prime$ при моделировании запроса $\mathcal{SO}$ для $\adversary$ выбирает $\texttt{dat}_1$ таким образом, что $\mathbb{T}_{\texttt{com}}[\texttt{dat}_1]$ не будет пустой, то $\bot_1$ будет выходом. Следовательно, этот символ появляется, только если $\adversary^\prime$ выберет случайные данные подписания $\texttt{dat}_1$, для которых уже был определён образ по $\mathcal{H}_{\text{com}}$. $\adversary^\prime$ никогда не выбирает одни и те же случайные данные дважды в соответствии со спецификацией моделирования $\mathcal{SO}$, а это подразумевает, что $\adversary$ запросил $\mathcal{H}_{\text{com}}$, отправив $\texttt{dat}_1$ в какой-то момент в прошлом, и, более того, $\adversary^\prime$ случайно раскрыл свой предварительный образ. Существует $\p^{r+1}$ выборов $(U_\ell, V_\ell, \left\{s_\ell\right\})$; этот сценарий является точным сценарием атаки «дня рождения». Если предположить, что при самом большем $q$ такие выборы будут использоваться в $\mathcal{H}_{\text{com}}$, вероятность того, что $\adversary^\prime$ не увидит конфликтов, точно составляет $\prod_{k \in [q-1]}(1 - k\mathfrak{p}^{-r-1})$. Следовательно, мы получаем
\[\epsilon_1 \leq 1 - \prod_{k \in [q-1]}(1 - k\mathfrak{p}^{-r-1}).\]

\item [Ограничение $\epsilon_2$:] Символ ошибки $\bot_2$ появляется только в том случае, если в таблице $(U, V, \left\{s_\ell\right\})$ будет найдено по крайней мере два $\mathbb{T}_{\texttt{com}}[U,V,\left\{s_\ell\right\}] = \texttt{com}_j$ для одного и того же $\texttt{com}_j$. Это подразумевает конфликт смоделированного случайного оракула. Мы получаем
\[\epsilon_2 \leq 1 - \prod_{k \in [q-1]} (1-k\mathfrak{p}^{-1}).\]

\item [Ограничение $\epsilon_3$:] Допустим, $E$ является случаем, когда $\adversary^\prime$ моделирует запрос для $\mathcal{SO}$, проверяет $\mathbb{T}_{\texttt{sig}}$ и обнаруживает, что некоторый запрос в форме $(M, P_\ell, U_\ell, V_\ell)$ уже был сделан, и выдаёт $\bot_3$. Это также представляет собой сценарий атаки «дня рождения»: так как $M$ является выходом $\mathcal{H}_{\text{msg}}$, мы имеем $\mathfrak{p}^{4}$ таких возможных выборов, и мы делаем до $q$ запросов, таким образом, вероятность двух конфликтов составляет точно $\prod_{k \in [q-1]}(1 - k\mathfrak{p}^{-4})$.

\item [Ограничение $\epsilon_4$:] Символ ошибки $\bot_4$ появляется только в том случае, если $\texttt{alert}_1 = \texttt{true}$ и моделирование практически подошло к концу. $\adversary^\prime$ добирается до этой точки только в том случае, если $\adversary$ ведёт себя неправильно и отправляет обязательство $\texttt{com}_j$ на этапе обязательства и раскрытия, который не был связан ещё ни с одним запросом в форме $\mathcal{H}_{\text{com}}$ и всё же создал данные открытия $\left\{\texttt{dat}_j\right\}_j$, которые переходят на фазу раскрытия: $\adversary$ угадал $\texttt{com}_j = \mathcal{H}_{\text{msg}}(\text{dat}_j)$, не запрашивая $\mathcal{H}_{\text{msg}}$. Это также сценарий атаки «дня рождения». Вероятно, что злоумышленнику, проводящему атаку, понадобится более $k$ попыток до того, как он увидит, что первый конфликт ограничен сверху при помощи $\text{exp}(\frac{-k(k-1)}{2(\mathfrak{p}-q)})$. Если допустить, что каждая попытка занимает постоянное количество времени (скажем, $c$ единиц времени на попытку), так как $\adversary^\prime$ даётся $t^\prime > 0$ времени в добавок к времени выполнения $\adversary$, вероятность того, что $\adversary^\prime$ выдаст $\bot_4$ составляет самое большее $1 - \text{exp}(-\frac{-t^\prime(t^\prime-c)}{2(\mathfrak{p}-q)c^2})$.
\end{description}
\end{proof}

Следует отметить, что путём перемасштабирования времени $(t^\prime, t) \mapsto (\frac{t^\prime}{c}, \frac{t}{c})$ мы можем переписать $\epsilon_4 = 1 - e^{-t^\prime(t^\prime - 1)/(\alpha(\mathfrak{p} - q))}$ для некоторого $\alpha > 0$. Также следует отметить, что каждое $\epsilon_i$ является незначительным в $\mathfrak{p}$, поэтому и их сумма будет незначительной в $\mathfrak{p}$. Так как $\adversary^\prime$ сравним с гипотезой, изложенной в лемме \ref{genfork}, мы получаем непосредственно следующее.

\begin{cor}
Алгоритм $\texttt{fork}^{\adversary^\prime}$ и $\texttt{fork}^{\adversary^{\prime \prime}}$ имеют вероятность принятия, ограниченную снизу:

\begin{align*}
\texttt{acc}_{\texttt{fork}^{\adversary^\prime}} \geq& \texttt{acc}_{\adversary^\prime} \left(\frac{\texttt{acc}_{\adversary^\prime}}{q} - \frac{1}{2^\eta}\right) \\
\texttt{acc}_{\texttt{fork}^{\adversary^{\prime \prime}}} \geq& \texttt{acc}_{\texttt{fork}^{\adversary^\prime}} \left(\frac{\texttt{acc}_{\texttt{fork}^{\adversary^\prime}}}{q} - \frac{1}{2^\eta}\right)
\end{align*}
\end{cor}

В следующем разделе мы описываем $\texttt{fork}^{\adversary^\prime}$ и $\texttt{fork}^{\adversary^{\prime \prime}}$.

%Since $\epsilon$ is non-negligible and $\epsilon_{\texttt{fail}}$ is negligible, Corollary \ref{genfork} implies that, $\texttt{fork}^{\adversary^{\prime \prime}}$ has a non-negligible acceptance probability.

\subsection{Двойная реализация форка}\label{forkingTwice}

В данном разделе мы дважды применим общую лемму реализации форка и достигнем кульминации - решения дискретного логарифма. Мы реализуем форк $\adversary^\prime$ в два этапа. Сначала мы строим $\texttt{fork}^{\adversary^\prime}$, чтобы взять в качестве входа некоторый $\texttt{inp}_{\texttt{fork}^{\adversary^\prime}} = (X_h, \underline{h}_{\text{agg}})$, случайным образом выбрать некоторое $\underline{h}_{\text{sig}}$ и выполнить $\adversary^\prime$ со входом $\texttt{inp}_{\adversary^\prime} = (X_h, \underline{h}_{\text{sig}})$. Если $\adversary^\prime$ выдаёт какой-либо символ ошибки $\bot$, то $\texttt{fork}^{\adversary^\prime}$ выдаёт $\bot_{\texttt{fork}^{\adversary^\prime}}$ и завершает процесс.

В противном случае $\adversary^\prime$ выводит некоторый $(i_{\text{sig}}, \texttt{out})$, где $\texttt{out} = (h_{\text{agg}, i_{\texttt{agg}}}, h_{\text{sig}, i_{\texttt{sig}}}, \underline{a}, \texttt{forg})$. Второй $\underline{h}_{\text{sig}}^*$ выбирается случайным образом, последовательности $\underline{h}_{\text{sig}}$ и $\underline{h}_{\text{sig}}^*$ объединяются, как обычно, чтобы получить $\underline{h}_{\text{sig}}^\prime$. $\adversary^\prime$ запускается снова за исключением $(X_h, \underline{h}_{\text{sig}}^\prime)$ вслед за вторым успешным выполнением. Если $\adversary^\prime$ выдаёт какой-либо символ ошибки $\bot$, то $\texttt{fork}^{\adversary^\prime}$ выводит $\bot_{\texttt{fork}^{\adversary^\prime}}$ и завершает процесс.

В противном случае $\adversary^{\prime}$ проходит второе успешное выполнение, скажем, $(i_{\text{sig}}^*, \texttt{out}^*)$. Если $i_{\text{sig}} \neq i_{\text{sig}}^*$, $\texttt{fork}^{\adversary^\prime}$ выдаёт $\bot_{\texttt{fork}^{\adversary^\prime}}$ и завершает процесс. В противном случае $\texttt{fork}^{\adversary^\prime}$ выводит \[\texttt{out}_{\texttt{fork}^{\adversary^\prime}} = (i_{\text{sig}}, (i, \texttt{out}), (i^*, \texttt{out}^*)).\]

\begin{description}
\item [Алгоритм $\texttt{fork}^{\adversary^\prime}$:] берёт в качестве входа $\texttt{inp}_{\texttt{fork}^{\adversary^\prime}} = (\texttt{inp}, \underline{h}_{\text{agg}}) = (X_h, \underline{h}_{\text{agg}})$.

\begin{enumerate}
\item $\texttt{fork}^{\adversary^\prime}$ берёт случайные монеты для $\adversary^\prime$, выбирает $\underline{h}_{\text{sig}} \leftarrow (\left\{0,1\right\}^{\eta})^q$, собирает $\texttt{inp}_{\adversary^\prime} = \linebreak (\texttt{inp}, \underline{h}_{\text{agg}})$.

\item $\texttt{fork}^{\adversary^\prime}$ запускает $\adversary^\prime$, используя $\texttt{inp}_{\adversary^\prime}$.

\item Если $\adversary^\prime$ выдаёт $\bot_{\adversary^\prime}$, $\texttt{fork}^{\adversary^\prime}$ выводит $\bot_{\texttt{fork}^{\adversary^\prime}}$ и завершает процесс.

\item В противном случае $\adversary^\prime$ выводит некоторый $\texttt{out}_{\adversary^\prime} = (i_{\text{sig}}, \texttt{out})$ где \[\texttt{out} = (i_{\text{sig}}, \ell_{\text{sig}}, \pi_{\text{sig}}, i_{\text{agg}}, h_{\text{sig}, i_{\text{sig}}}, h_{\text{agg}, i_{\text{agg}}}, \underline{a}, \texttt{forg}).\]

\item $\texttt{fork}^{\adversary^\prime}$ выбирает $\underline{h}_{\text{sig}}^{\prime} \leftarrow (\left\{0,1\right\}^\eta)^q$, задаёт объединяющий индекс $j = i_{\texttt{sig}}$ и, как обычно, объединяет последовательности ответов на запросы оракула \[\underline{h}_{\text{sig}}^{\prime \prime}= (h_{\text{sig},1}, h_{\text{sig},2}, \ldots, h_{\text{sig}, j - 1}, h^{\prime}_{\texttt{sig}, j}, h^{\prime}_{\texttt{sig}, j+1}, \ldots).\]

\item $\texttt{fork}^{\adversary^\prime}$ запускает $\adversary^\prime$, используя $\texttt{inp}^{\prime}_{\adversary^\prime} = (\texttt{inp}, \underline{h}_{\text{sig}}^{\prime \prime})$.



\item Если $\adversary^\prime$ выдаёт $\bot$, $\texttt{fork}^{\adversary^\prime}$ выводит $\bot$.

\item В противном случае $\adversary^\prime$ выводит некоторый $\texttt{out}_{\adversary^\prime}^* = (i_{\text{sig}}^*, \texttt{out}^*)$ где \[\texttt{out}^* = (i_{\text{sig}}^*, \ell_{\text{sig}}^*, \pi_{\text{sig}}^*, i_{\text{agg}}^*, h_{\text{sig}, i_{\text{sig}}^*}^{\prime \prime}, h_{\text{agg}, i_{\text{agg}}^*}, \underline{a}^*, \texttt{forg}^*).\]

\item Если $i_{\text{sig}} \neq i_{\text{sig}}^*$, выводится $\bot_{\texttt{fork}^{\adversary^\prime}}$ и процесс завершается.

\item В противном случае выводится $(i_{\text{sig}}, \texttt{out}^{\prime})$ где $\texttt{out}^\prime = (\texttt{out}, \texttt{out}^*)$.
\end{enumerate}
\end{description}

%We define $\texttt{fork}^{\adversary^\prime}$ this way to satisfy our description of the forking lemma, although we always parse a non-$\bot$ output of $\texttt{fork}^{\adversary^\prime}$, $(j, \texttt{out}^*)$, as $(\underline{i}, \texttt{out})$ where $\underline{i} = (i_{\texttt{agg}}, i_{\texttt{agg}}^\prime, i_{\texttt{sig}} ,\ell_{\texttt{sig}})$ and $\texttt{out} = ((\underline{a}, \texttt{forg}), (\underline{a}^\prime, \texttt{forg}^\prime))$. This way, we can fork again.

Следующая лемма очевидна: коэффициенты накопления для $P_\ell$ должны быть определены до того, как будет запрошен оракул $\mathcal{H}_{\text{sig}}$ при помощи $(M, P_\ell, L_\ell, R_\ell)$ за исключением ничтожной вероятности. Следовательно, запросы, определяющие $h_{\text{agg},i_{\text{agg}}}$ и $h_{\text{agg},i_{\text{agg}}^*}^*$, делаются до форка, поэтому они должны быть теми же запросами.

\begin{lemma}
Успешный выход $\texttt{fork}^{\adversary^\prime}$ содержит $i_{\text{agg}} = i^*_{\text{agg}}$ за исключением ничтожной вероятности.
\end{lemma}

\begin{proof}
Угадать выход $\mathcal{H}_{\text{sig}}(M, P_\ell, L_\ell, R_\ell)$ до того, как случится $P_\ell$, с вероятностью самое большее $(\p - q)^{-1}$. Этого достаточно, но совсем не обязательно: также можно узнать $P_\ell$, не делая запросов коэффициентов накопления.

Следовательно, за исключением некоторой вероятности, составляющей самое большее $(\p - q)^{-1}$, $P_\ell$ можно узнать до того, как будет сделан этот запрос. При условии, что $\adversary^\prime$ известно $P_\ell$, вероятность, что $P_\ell$ будет угадано без вычисления каких-либо коэффициентов накопления, также составляет самое большее $(\p -q )^{-1}$.

Вероятность, что такой порядок не сохранится, ограничивается сверху $(\p - q)^{-1} + (1 - (\p - q)^{-1})(\p - q)^{-1} = (2 - (\p - q)^{-1})(\p - q)^{-1})$. Таким образом, вероятность, что данный порядок сохранится, составляет по крайней мере $(1-(\p-q)^{-1})^2$.
\end{proof}

Вероятность приемлемости для $\texttt{fork}^{\adversary^\prime}$обеспечивается общей леммой реализации форка. Из-за нашего выбора варианта реализации форка запрос $\mathcal{H}_{\text{sig}}$ в двух полученных транскриптах имеет одинаковый вход $(M, P_\ell, L_\ell, R_\ell)$, но различные выходы. Это условие, что $c_\ell \neq c_\ell^{\prime}$ взято из \textit{уравнений и неравенств системы подделки по дискретному логарифму}. Мы оборачиваем этот алгоритм алгоритмом $\adversary^{\prime \prime}$, который отклоняет определённые исполнения и переформатирует выходы.

\begin{description}
\item [Алгоритм $\adversary^{\prime \prime}$:]

\begin{enumerate}
\item В качестве входа берёт некоторый $\texttt{inp}_{\texttt{fork}^{\adversary^\prime}} = (X_h, \underline{h}_{\text{agg}})$.

\item Выбирает некоторые случайные монеты $\rho = \rho_{\texttt{fork}^{\adversary^\prime}}$.

\item Выполняет $\texttt{fork}^{\adversary^\prime}$, используя $\texttt{inp}_{\texttt{fork}^{\adversary^\prime}}$ и эти случайные монеты.

\item Если результатом является $\bot_{\texttt{fork}^{\adversary^\prime}}$, выводится $\bot_{\adversary^{\prime \prime}}$ и процесс завершается. В противном случае объединяются $\texttt{out}_{\texttt{fork}^{\adversary^\prime}} = (i_{\text{sig}}, \texttt{out}^{\prime})$ где $\texttt{out}^{\prime} = (\texttt{out}, \texttt{out}^*)$ и $\texttt{out}_{\texttt{fork}^{\adversary^\prime}}$.

\item Находится $\ell_{\text{sig}}, \pi_{\text{sig}} \in \texttt{out}$; находится $\ell_{\text{sig}}^*, \pi^*_{\text{sig}} \in \texttt{out}^*$.

\item Если $\ell_{\text{sig}} \neq \ell_{\text{sig}}^*$ или $\pi_{\text{sig}} \neq \pi_{\text{sig}}^*$, выводится $\bot$ и процесс завершается. В противном случае объединяются $\texttt{out}_{\adversary^{\prime \prime}} = (i_{\text{agg}}, \texttt{out}^{\prime})$ и выход $\texttt{out}_{\adversary^{\prime\prime}}$.
\end{enumerate}
\end{description}

Доказательство значимости вероятности приемлемости $\adversary^{\prime \prime}$ довольно схоже с доказательством, представленным в работе \cite{liu2004linkable} для не пороговых LSAG-подписей. Мы пропустим это, но отметим, что пороговое свойство нашей схемы подразумевает отсутствие разницы при определении вероятности приемлемости.

Теперь мы делаем форк по $i_{\texttt{agg}}$. Таким образом, все запросы, сделанные до этого момента, остаются теми же. Более того, так как коэффициенты накопления по выбранным со злым умыслом ключам определяются случайными монетами, а не по ряду запросов хешей и из-за нашей структуры моделей $\mathcal{H}_{\texttt{agg}}$, эти случайные монеты всегда выбираются до появления выхода для честного ключа. Следовательно, если некоторый алгоритм принимает решения адаптивно на основе предыдущего входа, случайные монеты, выбранные для коэффициентов накопления по выбранным со злым умыслом ключей, будут идентичными в двух ветках с вероятностью, равной $1$.

\begin{description}

\item [Алгоритм $\texttt{fork}^{\adversary^{\prime \prime}}$:] В качестве входа берёт некоторый $\texttt{inp}_{\texttt{fork}^{\adversary^{\prime \prime}}} = X_h$.
\begin{enumerate}
\item Выбирает некоторые случайные монеты $\rho = \rho_{\adversary^{\prime \prime}}$.

\item $\texttt{fork}^{\adversary^{\prime \prime}}$ выбирает $\underline{h}_{\text{agg}} \leftarrow (\left\{0,1\right\}^{\eta})^q$ и задаёт $\texttt{inp}_{\adversary^{\prime\prime}} = \texttt{inp}_{\texttt{fork}^{\adversary^\prime}} = (X_h, \underline{h}_{\text{agg}})$.

\item $\texttt{fork}^{\adversary^{\prime \prime}}$ запускает $\adversary^{\prime\prime}$, используя $\texttt{inp}_{\adversary^{\prime\prime}}$.

\item Если $\adversary^{\prime\prime}$ выдаёт $\bot_{\adversary^{\prime\prime}}$, $\texttt{fork}^{\adversary^{\prime \prime}}$ выводит $\bot_{\texttt{fork}^{\adversary^{\prime \prime}}}$ и завершает процесс. В противном случае $\texttt{fork}^{\adversary^{\prime \prime}}$ получает $(i_{\text{agg}}, \texttt{out}_{\adversary^{\prime \prime}})$.

\item $\texttt{fork}^{\adversary^{\prime \prime}}$ выбирает $\underline{h}_{\text{agg}}^{\prime} \leftarrow (\left\{0,1\right\}^\eta)^q$, задаёт объединяющий индекс $j = i_{\texttt{agg}}$ и, как обычно, объединяет последовательности ответов на запросы оракула \[\underline{h}_{\text{agg}}^{\prime \prime}= (h_{\text{agg},1}, h_{\text{agg},2}, \ldots, h_{\text{agg}, j - 1}, h^{\prime}_{\texttt{agg}, j}, h^{\prime}_{\texttt{agg}, j+1}, \ldots),\] и объединяет $\texttt{inp}^{\prime}_{\adversary^{\prime \prime}} = (X_h, \underline{h}_{\text{agg}}^{\prime \prime})$

\item $\texttt{fork}^{\adversary^{\prime \prime}}$ запускает $\adversary^{\prime \prime}$, используя $\texttt{inp}^{\prime}_{\texttt{fork}^{\adversary^{\prime \prime}}}$.

\item Если $\adversary^{\prime \prime}$ выдаёт $\bot$, $\texttt{fork}^{\adversary^{\prime \prime}}$ выводит $\bot$. В противном случае $\texttt{fork}^{\adversary^{\prime \prime}}$ получает некоторый $(i_{\text{agg}}^*, \texttt{out}_{\adversary^{\prime \prime}}^*)$.

\item Если $i_{\text{agg}} \neq i_{\text{agg}}^*$, выводится $\bot_{\texttt{fork}^{\adversary^{\prime \prime}}}$ и процесс завершается.

\item В противном случае выводится $(i_{\texttt{agg}}, \texttt{out}_{\texttt{fork}^{\adversary^{\prime \prime}}})$, где $\texttt{out}_{\texttt{fork}^{\adversary^{\prime \prime}}} = (\texttt{out}_{\adversary^{\prime \prime}}, \texttt{out}_{\adversary^{\prime \prime}}^*)$
\end{enumerate}
\end{description}

%The forking lemma implies that if $\adversary^\prime$ has acceptance probability of $\epsilon_1$, then $\texttt{fork}^{\adversary^\prime}$ has acceptance probability at least $\epsilon_1(\frac{\epsilon_1}{q} - \frac{1}{2^\eta})$ and $\texttt{fork}^{\adversary^{\prime \prime}}$ has acceptance probability at least \[\epsilon_1(\frac{\epsilon_1}{q} - \frac{1}{2^\eta})\left(\frac{\epsilon_1(\frac{\epsilon_1}{q} - \frac{1}{2^\eta})}{q} - \frac{1}{2^\eta}\right).\]

Вероятность приемлемости $\texttt{fork}^{\adversary^{\prime \prime}}$ ограничивается снизу некоторой значимой функцией, соответствующей общей лемме реализации форка, ограниченной снизу:
\[\texttt{acc}_{\texttt{fork}^{\adversary^{\prime \prime}}}
\geq \texttt{acc}_{\adversary^{\prime\prime}} \left(\frac{\texttt{acc}_{\adversary^{\prime\prime}}}{q} - \frac{1}{2^\eta}\right).\]

Наконец, мы строим наш решатель. Следует отметить, что следующий алгоритм будет выполнен успешно только в случае успешного выполнения $\texttt{fork}^{\adversary^{\prime \prime}}$, поэтому и вероятность успеха будет идентичной, на чём основывается наша теорема.

\begin{description}
\item [Алгоритм $\mathcal{B}$:] $\mathcal{B}$ имеет скрытый доступ к $\texttt{fork}^{\adversary^{\prime \prime}}$. В качестве входа $\mathcal{B}$ берёт честный публичный ключ $X_h$, получает доступ к случайному оракулу и выводит дискретный логарифм $x_h$.

\begin{enumerate}
\item В качестве входа $\mathcal{B}$ берёт некоторый $X_h$.

\item $\mathcal{B}$ выполняет $\texttt{fork}^{\adversary^{\prime \prime}}$, используя $\texttt{inp} = \left\{X_h\right\}$.

\item Если $\texttt{fork}^{\adversary^{\prime \prime}}$ выдаёт $\bot_{\texttt{fork}^{\adversary^{\prime \prime}}}$, $\mathcal{B}$ выводит $\bot_{\mathcal{B}}$ и завершает процесс. В противном случае $\mathcal{B}$ получает $(i_{\text{agg}}, \texttt{out}_{\texttt{fork}^{\adversary^{\prime \prime}}})$.

\item $\mathcal{B}$ проверяет $\texttt{out}_{\texttt{fork}^{\adversary^{\prime \prime}}}$, чтобы выделить четыре подписи, $\sigma^{(j)}$ (для $j \in [4]$), индексы запросов подписания $i_{\text{sig}}^{(j)}$, ответы на запросы подписания $h_{\text{sig}, i_{\text{sig}}^{(j)}}^{(j)}$, индексы кольца $\ell_{\text{sig}}^{(j)}$ и $\pi_{\text{sig}}^{(j)}$ индексы накопления $i_{\text{agg}}$ и ответы на запросы накопления $h_{\text{agg}, i_{\text{agg}}^{(j)}}^{(j)}$.

\item $\mathcal{B}$ проверяет следующую систему уравнений и неравенств:

\begin{align*}
i_{\text{sig}}^{(1)} =& i_{\text{sig}}^{(2)} & \ell_{\text{sig}}^{(1)} =& \ell_{\text{sig}}^{(2)} & \pi_{\text{sig}}^{(1)} =& \pi_{\text{sig}}^{(2)} \\ i_{\text{sig}}^{(3)} =& i_{\text{sig}}^{(4)} & \ell_{\text{sig}}^{(3)} =& \ell_{\text{sig}}^{(4)} & \pi_{\text{sig}}^{(3)} =& \pi_{\text{sig}}^{(4)} \\
i_{\text{agg}}^{(i)} =& i_{\text{agg}}^{(j)}\text{ для каждого }i, j &
h_{\text{agg}, i_{\text{agg}}}^{(1)} =& h_{\text{agg}, i_{\text{agg}}}^{(2)} &
h_{\text{agg}, i_{\text{agg}}}^{(3)} =& h_{\text{agg}, i_{\text{agg}}}^{(4)}\\
h_{\text{sig}, i_{\text{sig}}^{(1)}}^{(1)} \neq& h_{\text{sig}, i_{\text{sig}}^{(1)}}^{(2)} & h_{\text{sig}, i_{\text{sig}}^{(1)}}^{(3)} \neq& h_{\text{sig}, i_{\text{sig}}^{(1)}}^{(4)} & h_{\text{agg}, i_{\text{agg}}}^{(1)} \neq& h_{\text{agg}, i_{\text{agg}}}^{(3)}
\end{align*} и выводит $\bot_\mathcal{B}$, если происходит ошибка.

\item Из каждой $\texttt{forg}^{(j)}$ можно выделить случайные данные подписи $s_{\ell}^{(j)}$.

\item $\mathcal{B}$ выводит \[\widehat{x}_h := (h_{\text{agg}, i_{\text{agg}}}^{(1)} - h_{\text{agg}, i_{\text{agg}}}^{(3)})^{-1}\left(\frac{s_\ell^{(2)} - s_\ell^{(1)}}{h_{\text{sig}, i_{\text{sig}}^{(2)}}^{(2)} -h_{\text{sig}, i_{\text{sig}}^{(1)}}^{(1)}} - \frac{s_\ell^{(4)} - s_\ell^{(3)}}{h_{\text{sig}, i_{\text{sig}}^{(3)}}^{(3)} -h_{\text{sig}, i_{\text{sig}}^{(4)}}^{(4)}}\right). \]

Безусловно, $\mathcal{B}$ не выполняется только в том случае, если не выполняется $\texttt{fork}^{\adversary^{\prime \prime}}$ или же если система не верифицирована, но это уже подсобытие невыполнения $\texttt{fork}^{\adversary^{\prime \prime}}$. Таким образом, вероятность того, что $\mathcal{B}$ будет не выполнен, ограничена сверху вероятностью того, что не будет выполнен $\texttt{fork}^{\adversary^{\prime \prime}}$.
\end{enumerate}
\end{description}

%Introduced in \cite{maxwell2015confidential}, a confidential transaction may be loosely regarded as a multisignature fashioned using the usual private signing key but also the secret opening information for some corresponding homomorphic commitments to transaction amounts. To accomplish this, each private one-time signing key $p$  comes paired with an amount $\alpha$ and mask $r$ (both from $\mathbb{Z}_\mathfrak{q}$), and each public one-time key $P$ comes with a Pedersen commitment $C$. A sender with public key-commitment pair $(P,C)$ and private $(p, (\alpha, r))$ who desires to send amount $0 \leq \alpha^\prime \leq \alpha$ to another user does the following.

%The sender constructs two new Pedersen commitments by selecting two new random masks $r^{\prime}$, $r^{\prime \prime}$ and computing the commitments $C^\prime = \texttt{Com}(\alpha^{\prime}, r^{\prime})$ and $C^{\prime \prime} = \texttt{Com}(\alpha - \alpha^{\prime}, r^{\prime \prime})$. These commitments must be paired with one-time signing keys so that the receivers can subsequently construct new transactions, so one-time keys $P^{\prime}$ and $P^{\prime \prime}$ are selected; $P^{\prime}$ is addressed to the receiver of the transaction and $P^{\prime \prime}$ is addressed back to the sender for chagne. The signer constructs an MLSAG signature with a signing matrix of the form
%\[Q = \begin{pmatrix} \widetilde{P}_1 & \widetilde{P}_2 & \cdots & \widetilde{P}_R \\
%\widetilde{C}_1 - C^{\prime} - C^{\prime \prime} & \widetilde{C}_2 - C^{\prime} - C^{\prime \prime} & \cdots & \widetilde{C}_R - C^{\prime} - C^{\prime \prime} \end{pmatrix}\] where each $(\widetilde{P}_\ell, \widetilde{C}_\ell)$ is chosen at random from the blockchain for $\ell \neq \pi$, and where $\widetilde{P}_{\pi} = P$ and $\widetilde{C}_{\pi} = C$.  if the receiver of $C^{\prime}$ learns the opening information for $C^{\prime}$ and the private key for $P^{\prime}$, they may subsequently construct new transactions. In Monero, these are accomplished via encryption with secrets generated by ECDH transfer as described herein.

%This approach forces transactions to be \textit{balanced} by construction (the input amount and output amount must match in order for the signer to k the discrete logarithm of the $(2,\ell^*)^{th}$ entry in $\widetilde{Q}$) and still functions as a ring signature for message authentication. The sender should also include in $M$ a \textit{range proof}, which verifies whether $\alpha^{\prime}$ is a reasonable amount, say $0 \leq \alpha^{\prime} < 2^\iota$ for some large $\iota$ (say $2^{64}$ as in Monero), so that integer-like arithmetic for these transactions are not spoiled by the modular arithmetic of the underlying (finite order) group. Applying the thresholdizing heuristic we present here yields MLSTAG Ring Confidential Transactions.


\section{Другие свойства, кроме невозможности подделки}\label{otherProperties}

Мы определяем правильность и связываемость, а также описываем некоторые свойства безопасности, такие как неопределённость подписанта и её связь с невозможностью определения того, как накапливаются ключи. Правильность и связываемость учитывают действия получестных злоумышленников, использующих алгоритмы, соответствующие спецификации (вместе с тем они могут предпринять дополнительные шаги, не предусмотренные спецификацией). В данном случае это группа «странных, но честных» друзей, желающих вместе создать подпись.

\begin{lemma}\label{correctness}
Пример \ref{implementation} правилен.
\end{lemma}

\begin{proof}

В случае $S((\mathfrak{m}, \underline{P}, \pi, \underline{x}), (\mathfrak{m}^*, \sigma))$, где $\sigma = (c_1, \underline{s})$ and $\mathfrak{m}^* = (\mathfrak{m}, \underline{P}, J, \texttt{aux})$, получестный подписант вычисляет $c_{\pi+1}$, $c_{\pi+2}$, $\ldots$, $c_r$ и $c_1$ при помощи обычных/честных запросов, отправляемых $\mathcal{H}_{\text{sig}}$, с вероятностью, равной $1$. Кроме того, получестный подписант также отправляет $c_2, \ldots, c_{\pi-1}, c_\pi$ при помощи обычных/честных запросов, отправляемых $\mathcal{H}_{\text{sig}}$, с вероятностью, равной $1$. Получестный подписант также по спецификации убеждается в соответствии уравнений верификации при помощи секретного ключа $p_\pi$. Следовательно, получестный верификатор при наличии $\mathfrak{m}^*$ и $\sigma = (c_1, (s_1, s_2, \linebreak \ldots, s_r))$ вычисляет следующее
\begin{align*}
L_1^\prime :=& c_1 G + s_1 P_1 & R_1^\prime :=& c_1 H_1 + s_1 J & c_2^\prime :=& \mathcal{H}_{\text{sig}}(M, P_1, R_1, L_1) \\
L_2^\prime :=& c_2^\prime G + s_2 P_2 & R_2^\prime :=& c_2^\prime H_2 + s_2 J & c_3^\prime :=& \mathcal{H}_{\text{sig}}(M, P_2, R_2, L_2) \\
 & \vdots & & \vdots & & \vdots \\
L_r^\prime :=& c_r^\prime G + s_r P_r & R_r^\prime :=& c_r^\prime H_r + s_r J & c_1^\prime :=& \mathcal{H}_{\text{sig}}(M, P_r, R_r, L_r)
\end{align*}
и получает $c_1^\prime = c_1$ с вероятностью, равной $1$.
\end{proof}

\begin{lemma}
Пример \ref{implementation} может быть связан.
\end{lemma}

\begin{proof}
В случае $S^\prime(\mathfrak{m}_1^*, \sigma_1, \mathfrak{m}^*_2, \sigma_2)$ получестный злоумышленник использовал один и тот же ключ в каждой подписи. Другими словами, для колец $\underline{P}_1$, $\underline{P}_2$ существует общий ключ; то есть для некоторых индексов $i_1$, $i_2$, $(\underline{P}_1)_{i_1} = (\underline{P}_2)_{i_2} = P_{\text{common}}$. В обеих подписях образом ключа будет $J = P_{\text{common}}\mathcal{H}_{\text{ki}}(P_{\text{common}})$, и поэтому связывание происходит с вероятностью, равной $1$.
\end{proof}

Мы изменяем определение анонимности, дополняя его членами кольца, выбранными со злым умыслом, как это описано в работе \cite{bender2006ring}, учитывая таким образом накопление ключей; более сильное определение, представленное в работе \cite{bender2006ring} с \textit{полным раскрытием ключей} невозможно удовлетворить в случае со связываемыми транзакциями с кольцевыми подписями CryptoNote, которые используются Monero.

\begin{defn}[Невозможность порогового определения подписанта при наличии членов кольца, выбранных со злым умыслом]
Допустим, $f(-)$ положительным полиномом. Рассмотрим следующую игру:
\begin{enumerate}
\item Множество пар приватных-публичных ключей $\left\{(x_i, X_i)\right\}_{i\in [f(\lambda)]}$ выбирается запросчиком при помощи $\texttt{KeyGen}$. Обозначим $SK = \left\{x_i\right\}$ and $PK = \left\{X_i\right\}$.

\item Публичные ключи $PK$ отправляются $\adversary$, у которого есть доступ к подписывающему оракулу $\mathcal{SO}$.

\item $\adversary$ выводит сообщение $\mathfrak{m}$ два непустых мультимножества накопленных ключей $\underline{X}^{(0)}$, $\underline{X}^{(1)} \subset PK$ и кольцо $\underline{P}$ так, чтобы $P_{i_j} = \Phi(\underline{X}^{(j)})$ для $j = 0, 1$.

\item Запросчик выбирает случайный бит $b$, вычисляет $(\mathfrak{m}^*, \sigma) \leftarrow \texttt{Sign}(\mathfrak{m}, \underline{P}, \pi_b)$, где $\pi_b$ означает индекс $P_{i_b}$ in $\underline{P}$, and sends $(\mathfrak{m}^*, \sigma)$ $\adversary$.

\item $\adversary$ выводит бит $b^\prime$.
\end{enumerate} $\adversary$ побеждает в игре, если $b^\prime = b$, а образы ключей для $P_{i_0}$ и $P_{i_1}$ не появляются в выходе какого-либо запроса, отправленного $\mathcal{SO}$ от $\adversary$.
\end{defn}

Следующая лемма, которая определяется невозможностью определения того, как накапливаются ключи, очевидна в том случае с получестным злоумышленником, так как распределение $(c_1, \underline{s})$ в рамках обеих схем подписи определяется хеш-функцией $\mathcal{H}_{\text{sig}}$ и выбором подписанта, сделанным для $\underline{s}$. В рамках модели случайного оракула $c_1$ равномерно распределяется по $\mathbb{Z}_\mathfrak{p}$. В случае с получестным злоумышленником каждое $s_i \in \underline{s}$ также равномерно распределяется по $\mathbb{Z}_\mathfrak{p}$ и, более того, все они не зависят друг от друга.

\begin{lemma}
Подписи, создаваемые получестными злоумышленниками, при помощи Примера \ref{implementation}, статистически неотличимы от LSAG-подписей.
\end{lemma}

Как следствие, злоумышленник, который может нарушить неопределённость подписанта из Примера \ref{implementation}, подобным образом должен быть способен нарушить неопределённость подписанта в LSAG-подписях.
\begin{cor}
В случае с Примером \ref{implementation} подписант остаётся неопределённым при наличии членов кольца, выбранных со злым умыслом.
\end{cor}

%Lastly, we consider the notion of privacy, where semi-honest signers do not reveal their signing keys to each other.

%\begin{defn}[Privacy]
%Consider the following game.
%\begin{enumerate}
%\item A private-public key pair $(x_h, X_h)$ is selected by the challenger with $\texttt{KeyGen}$. The key $X_h$ is sent to $\adversary$.
%\item The adversary $\adversary$ outputs a message $\mathfrak{m}$, an aggregate key $X_{\text{sh}}$ such that $X_h$ is an aggregant, a ring $\underline{P}$, and a special index $\pi$ such that $P_\pi = X_{\text{sh}}$.
%\item The challenger and the adversary collaborate to execute $\texttt{Sign}$ semi-honestly with the key $X_{\text{sh}}$, where the challenger plays the signer with key $x_h$ and the adversary plays all other signers.
%\item The adversary $\adversary$ outputs a scalar $x^*$, winning if $X_{\text{sh}} = x^* G$.
%\end{enumerate}
%\end{defn}

%Note that in any signing transcript, $\adversary$ (who, say, acts as the $j^{th}$ signer in the coalition) receives from the challenger some $(U_j, V_j, \left\{s_{\ell,j}\right\}_{\ell \neq \pi})$ and $s_{\pi,j} = u_j - c_\pi x_h$. Since the discrete logarithm problem is hard, $\adversary$ cannot easily compute the discrete logarithm $U_j = u_j G$, and without knowledge of $u_j$, $s_{\pi, j}$ is perfectly hiding of $-c_\pi x_h$, and so our scheme is private. A similar argument holds to demonstrate the weaker property that the discrete logarithm of the signing key $P_\pi$ is not revealed except with negligible probability.

\end{document}
